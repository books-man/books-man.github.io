<?XmL version="1.0" encoding="utf-8"?><!DOCTYPE html>
<titLE>II. Key Syntactical Differences</TitLe>
<lInk HreF=../Styles/style0001.css TYPe=text/css REL=stylesheet/>

<dIv>
<H1 id="leanpub-auto-ii-key-syntactical-differences">II. Key Syntactical Differences</h1>

<P>This part of the book is about the key differences between Java and Scala language syntax. Given some typical Java code, we’ll look at equivalent Scala syntax. In Part III., we’ll look more at Scala features for which there is no direct equivalent in Java.</P>

<P>We’re going to look at:</P>

<ul><lI>Lots of things around classes and objects, creating classes, fields, methods. We’ll do some round-tripping from Scala-generated bytecode back to Java, so that you can get a feel for how Scala relates to Java.</lI>
  <Li>Inheritance, interfaces, abstract classes and mixins.</lI>
  <li>Common control structures like <codE>for</coDE> loops.
  <li>Generics.
</uL><h4 id="leanpub-auto-flexibility">Flexibility</h4>

<p>Scala is very flexible. There are generally several ways to achieve the same thing. I don’t mean the difference between using a <codE>while</COde> loop or <CoDE>for</CODE> loop; I mean that the language has different syntax options for expressing the same thing. This flexibility gives a lot of freedom but can be confusing when you’re reading code from different authors.

<p>An example is the infix notation we saw earlier. You can often drop the dots and brackets when calling methods. Scala is opinion-less; it’s up to you if you want to use the dots or not.</P>

<P>Java, on the other hand, is very restrictive; there are generally very few ways to express the same things. It’s often easier to recognise things at a glance. You might have to work a little harder to recognise some of the more exotic syntax options in Scala.

<P>This is true when it comes to the structure of your code too; you can create functions within functions, import statements in the middle of a class, or have a class live in a file with an unrelated name. It can all be a little disorienting when you’re used to the rigidity of Java.

<H4 id="leanpub-auto-immutable-and-declarative">Immutable and Declarative</h4>

<P>Because Scala favours immutability, you might also notice a different approach to solving problems. For example, you might notice a lack of looping over mutable variables. Scala programs usually favour more functional idioms to achieve the same thing.</P>

<p>This more <Em>declarative</eM> way of doing things says “tell me what to do, not how to do it”. You may be more used to the Java / imperative way of doing things that says “tell me exactly how to do it”. Ultimately, when you give up the micro-management style of imperative programming, you allow the language more freedom in how it goes about its business.

<P>For example, a traditional imperative for loop in Java looks like this:

<diV clASS=code-block>
<dIV cLASS=highlight><pRe>  <codE claSs="c1">// java</code>
  <coDe CLasS=k>for</Code> <code Class="o">(</Code><COdE cLASs="kt">int</COdE> <cOdE cLAss="n">count</cOdE> <coDE ClaSs="o">=</codE> <COde CLass="mi">0</CODe><CoDE claSS="o">;</coDE> <cOdE ClASS="n">count</CodE> <coDE CLasS="o">&lt;</coDe> <CoDE ClasS=mi>100</cODe><cOde cLaSS=o>;</coDe> <CODE CLASS=n>count</cOdE><cOdE cLAsS=o>++)</cOdE> <CODe CLASS=o>{</coDE>
      <codE cLAsS="n">System</cOde><COdE cLASs="o">.</CodE><cODe class=na>out</CODE><CODE cLASs="o">.</CODE><CodE clASS=na>println</COde><cODe ClASS=o>(</CodE><coDe cLASs="n">count</CODe><code ClasS="o">);</coDe>
  <cODE ClASs="o">}</codE>
</PRe></DiV>

</DIV>

<P>It’s a typical imperative loop. We’re telling it explicitly to enumerate serially from zero to one hundred. If, on the other hand, we use a more declarative mechanism, like this:</p>

<DiV ClasS="code-block">
<DIv clAsS=highlight><pRe>  <CoDE Class="c1">// scala</cOdE>
  <CoDe ClASs=o>(</COde><cOdE CLASs="mi">0</Code> <coDe CLAss="n">to</Code> <COdE ClAsS="mi">100</CoDe><CodE Class="o">).</CoDe><cOde clAss="n">foreach</CoDE><cOde CLaSs=o>(</cOdE><cODe ClaSs=n>println</CODE><CODe CLASs=o>(</code><CoDE cLaSs=k>_</codE><coDE CLAss="o">))</codE>
</prE></div>

</DiV>

<P>…the enumeration is done within the <Code>foreach</CodE> method, not by a language construct. We’re saying, “for a range of numbers, perform some function on each”. Although only subtly different, we’re not saying <EM>how</em> to enumerate the sequence. It means Scala is free to implement the enumeration however it likes.  (For example, it may choose to do it in parallel.)

<p>Interestingly, Oracle has adopted these ideas in Java 8. If you’ve been using that, you’re probably already familiar with the concepts.</P>
</dIv>
