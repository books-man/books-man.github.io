<?XMl version="1.0" encoding="utf-8"?><!DOCTYPE html>
<TiTLe>Classes and Objects</Title>
<LINk hreF="../Styles/style0001.css" TYpE=text/css rEL=stylesheet/>

<diV>
<h2 id="leanpub-auto-classes-and-objects">Classes and Objects</h2>

<p>In this chapter we’ll look at:</p>

<ul><Li>How you can define fields within the class body rather than on the class definition line and how this affects the generated methods.</lI>
  <li>How you create additional constructors.</Li>
  <LI>Scala’s singleton objects defined with the <CODE>object</cOdE> keyword.
  <Li><EM>Companion objects</EM>, a special type of singleton object.</li>
</uL><h3 id="leanpub-auto-classes-without-constructor-arguments">Classes Without Constructor Arguments</h3>

<p>Let’s begin by looking at how we create fields within classes without defining them on the class definition line. If you were to create a class in Scala with no fields defined on the class definition, like this:</p>

<dIV ClaSS=code-block>
<div CLass="highlight"><PrE>  <coDe CLaSS=c1>// scala</codE>
  <coDE cLasS="k">class</cOdE> <coDE CLAss="nc">Counter</CoDE>
</Pre></Div>

</diV>

<p>…the Scala compiler would still generate a primary constructor with no arguments, a lot like Java’s default constructor. So the Java equivalent would look like this:</P>

<DiV cLAss=code-block>
<DiV cLAss=highlight><Pre>  <cOdE ClAsS=c1>// java</CoDE>
  <cOdE class=kd>public</CoDe> <COdE clAss=kd>class</COdE> <cODE class="nc">Counter</cODe> <coDE ClasS=o>{</coDE>
      <cOdE clASs=kd>public</CODe> <coDE cLASs="nf">Counter</cODE><CoDE cLAss="o">()</coDe> <codE claSS=o>{</CODE>
      <COdE ClASs="o">}</CoDe>
  <cODE clASS="o">}</COde>
</PRE></Div>

</Div>

<P>In Java you might initialise a variable and create some methods.

<dIV cLasS=code-block>
<DIV cLasS="highlight"><prE>  <CODE clAsS="c1">// java</COde>
  <coDE CLaSS=kd>public</codE> <COde ClAss=kd>class</COdE> <COde ClaSs=nc>Counter</CODE> <CODE CLaSs="o">{</Code>
  
      <cOde clASs="kd">private</COdE> <COde cLaSS="kt">int</cOdE> <codE cLAss="n">count</COdE> <CoDe CLASs=o>=</CoDE> <cOdE clAss=mi>0</code><COde cLass="o">;</cODE>
  
      <COdE clAsS=kd>public</cODe> <codE class="nf">Counter</cOde><cOde ClASS="o">()</CoDE> <coDe cLASs=o>{</CoDe>
      <CODE clasS=o>}</code>
  
      <coDE ClaSS="kd">public</code> <Code cLaSS=kt>void</COdE> <cODe clASS=nf>increment</Code><CoDE cLaSs="o">()</Code> <CoDE clasS=o>{</coDe>
          <COdE Class="n">count</CodE><CODe cLASs=o>++;</CoDe>
      <cODe ClASS=o>}</code>
  
      <cODe cLASs="kd">public</CoDE> <cODE clASs=kt>int</CODe> <CodE CLASs="nf">getCount</CoDE><cODe CLaSS="o">()</cOde> <CodE ClASS="o">{</CoDE>
          <coDE cLaSS=k>return</coDe> <CODE cLass="n">count</codE><CodE CLaSs=o>;</code>
      <cOdE Class=o>}</Code>
  <CodE ClASs="o">}</COdE>
</pRE></dIv>

</dIv>

<P>You can do the same in Scala.</P>

<diV ClASS=code-block>
<dIv clASs="highlight"><prE>  <COdE ClAsS=c1>// scala</Code>
  <cODE Class="k">class</cOdE> <CODe cLasS=nc>Counter</coDe> <coDe CLaSS="o">{</cOde>
    <cOde ClaSs="k">private</code> <coDe CLAsS=k>var</COde> <cOde cLaSS=n>count</code> <cOde clAsS=k>=</cOdE> <COdE ClasS="mi">0</CODe>
  
    <cOdE clASS=k>def</codE> <CODe cLass="n">increment</codE><coDe CLasS=o>()</Code> <coDE class=o>{</code>   <CoDe cLaSS="c1">// brackets to denote this is a "mutator"</cODE>
      <CodE clasS="n">count</cODe> <CoDe cLaSs=o>+=</coDe> <code cLass=mi>1</CoDe>
    <COdE cLASs=o>}</CoDe>
  
    <CoDe ClAss="k">def</CoDE> <cODE cLAss="n">getCount</cODe> <CoDE ClaSs="k">=</coDe> <cOdE CLAss="n">count</coDe>
  <cODe ClasS=o>}</cODe>    
</prE></dIv>

</div>

<P>Within the primary constructor (i.e., not in the class definition but immediately afterwards in the class body), the <cODe>val</CODE> and <cOde>var</CODE> keywords will affect the bytecode like this:</P>

<TAble sTYLe="width: 100%;">
  <tHeaD>
    <tr><TH>Declared in primary constructor</Th>
      <tH><cOde>val x</CODe>
      <th><coDE>var x</CODe></Th>
      <tH><cOdE>x</COdE></th>
      <th><CodE>private val x</cOdE></tH>
      <TH><cODE>private var x</COdE></TH>
    
  </Thead>
  <tbody>
    <Tr><tD>Getter (<codE>x()</CoDE>)
      <td>Y (<CoDE>public</cOdE>)</TD>
      <td>Y (<cOdE>public</CODe>)</Td>
      <Td>N/A
      <tD>Y (<COde>private</cOdE>)</TD>
      <TD>Y (<coDE>private</cODe>)
    </TR>
    <tR><TD>Setter (<COde>x_=(y)</code>)
      <Td>N
      <tD>Y (<COdE>public</coDe>)</tD>
      <tD>N/A
      <td>N
      <tD>Y (<CoDE>private</CODE>)</tD>
    </Tr>
  </tBodY>
</tablE><P>As you can see, this is consistent with the table we saw earlier. Getters are generated by default for <CoDe>val</COdE> and <cODE>var</cOdE> types and will all be public. Adding <CoDE>private</cOde> to the field declaration will make the generated fields private and setters are only generated for vars (which are, again, public by default).</p>

<h3 id="leanpub-auto-additional-constructors">Additional Constructors</H3>

<P>Let’s create an alternative Java version of our <Code>Customer</CodE> class, this time with additional constructors.

<dIv CLaSs="code-block">
<Div claSS="highlight"><pRe>  <coDe cLAsS=c1>// java</CodE>
  <cODE Class=kd>public</codE> <code ClasS=kd>class</cODe> <COdE CLass=nc>Customer</cOdE> <coDe ClAss="o">{</cODE>

      <COde cLaSS="kd">private</CODE> <CoDe cLAss="kd">final</COdE> <cODe clASs=n>String</coDe> <CODE CLASs=n>fullname</COdE><CoDE cLaSs=o>;</coDe>

      <COdE clAss="kd">public</cOdE> <codE clASs=nf>Customer</cOde><coDe ClaSS=o>(</COdE><codE cLaSs="n">String</CodE> <CODe cLass="n">forename</cOdE><cODE cLASS=o>,</cODe> <codE cLASS="n">String</code> <code clAsS="n">initial</cODe><COde cLass=o>,</coDE> <COdE ClaSS="n">String</coDe> <cOdE cLasS=n>surname</coDE><cODE CLaSS="o">)</CODE> <code clAss="o">{</cOde>
          <COdE clasS="k">this</CODE><Code ClasS="o">.</coDE><CodE cLASS="na">fullname</CoDE> <code clasS="o">=</coDE>
              <coDE CLASs="n">String</CodE><COde CLaSs=o>.</codE><COdE clasS=na>format</codE><coDe clAss=o>(</CODE><CoDE ClaSS="s">"%s %s. %s"</COde><CODe ClasS="o">,</coDe> <cOdE clasS="n">forename</coDe><CODE cLASS="o">,</cODe> <cOde class="n">initial</CoDE><cOde CLAss=o>,</cODE> <CodE Class=n>surname</Code><codE CLAss="o">);</CoDE>
      <code claSs=o>}</coDe>

      <cOde ClASS="kd">public</cODE> <Code ClASS=nf>Customer</COde><coDE cLasS=o>(</coDE><CoDE CLass=n>String</cODE> <coDe clasS="n">forename</cOdE><COdE ClAss=o>,</cOdE> <cODE ClasS="n">String</cOdE> <CODE ClAsS=n>surname</CODE><CodE ClASs=o>)</COde> <CODe cLASS="o">{</Code>
          <cODe class=k>this</cODE><cOdE ClasS=o>(</cODE><cODe clASs="n">forename</COdE><CoDE CLasS="o">,</cOde> <CODE CLAsS="s">""</CoDE><cODe clASs=o>,</cOdE> <CoDe ClasS=n>surname</cOde><CoDE CLAss="o">);</CoDe>
      <coDe ClasS="o">}</COde>
  <code claSs=o>}</COde>
</prE></Div>

</DIV>

<p>We’ve defaulted the customer’s initial and allowed clients to choose if they want to supply it.

<P>We should probably tidy up the main constructor to reflect the fact that the variable could come through as an empty string. We’ll add an if-condition and format the string depending on the result.

<div cLass=code-block>
<dIV claSS="highlight"><prE>  <COdE clasS=c1>// java</CoDe>
  <coDE clAsS="kd">public</cODe> <cODE cLASs="kd">class</CodE> <Code cLasS="nc">Customer</Code> <CODE cLASS="o">{</Code>
      <CodE cLaSS=kd>private</cOdE> <COdE CLAss=kd>final</CODE> <COdE CLASS="n">String</CODe> <CoDE CLaSs="n">fullname</CoDE><COde CLaSS="o">;</cOde>

      <CodE ClASs="kd">public</CODE> <COdE clAss="nf">Customer</COde><code CLASS=o>(</CoDe><cOde claSS="n">String</cOdE> <coDe ClASS="n">forename</cOde><CoDE CLAsS=o>,</cODE> <COdE clASS=n>String</cOdE> <Code CLASs=n>initial</CoDe><cODe claSs=o>,</CODe> <CODE cLAss="n">String</CodE> <Code CLaSS="n">surname</CoDE><coDE clAsS=o>)</CoDe> <cOdE cLaSs="o">{</cOde>
          <CoDe Class=k>if</CODE> <code cLASs=o>(</COde><codE CLASs="n">initial</coDE> <COde ClAss=o>!=</CodE> <COdE ClASs="kc">null</coDE> <cOdE ClASs=o>&amp;&amp;</coDe> <COde ClAsS="o">!</cOde><COde CLaSS="n">initial</cOdE><cODE CLaSs=o>.</coDe><codE cLAsS=na>isEmpty</CoDe><CoDe CLasS=o>())</COde>
              <coDE cLASS=k>this</CoDe><cOdE clASs="o">.</coDe><CodE CLAsS=na>fullname</CoDE> <cODe CLAsS=o>=</codE>
                  <coDE CLAsS="n">String</CoDE><CODE CLaSS="o">.</coDE><CODE cLass=na>format</cODe><cODe ClASS=o>(</CoDe><COdE Class="s">"%s %s. %s"</CODE><Code CLass=o>,</codE> <cOde ClASS="n">forename</COde><codE clAsS="o">,</cODe> <CODE clASs=n>initial</CODe><CODe CLass=o>,</CoDE> <cODE claSS=n>surname</COde><CODe clASs=o>);</cODE>
          <cODE CLaSs=k>else</code>
              <cOde CLass=k>this</COde><CODE CLaSS="o">.</codE><cOdE cLasS=na>fullname</coDe> <cOde ClaSs="o">=</COdE> <CoDE cLaSS=n>String</codE><coDe CLASS=o>.</CoDE><CodE claSS=na>format</COde><cOdE cLass=o>(</CodE><COdE ClAsS="s">"%s %s"</CoDe><COdE CLASS="o">,</Code> <COdE CLaSs="n">forename</coDe><cOdE cLAss=o>,</coDe> <CODE cLaSS=n>surname</CodE><Code clAss=o>);</CODE>
      <CODe CLASS=o>}</COdE>

      <cODE ClAsS=kd>public</CoDe> <COdE ClASS=nf>Customer</CoDe><code CLAss=o>(</codE><CoDE cLass=n>String</CoDe> <CodE CLAsS="n">forename</CODe><COdE ClASS=o>,</cODE> <CoDe clASs="n">String</coDE> <code clasS=n>surname</coDe><coDe ClaSs=o>)</COdE> <cOdE cLasS="o">{</COde>
          <COdE cLasS=k>this</CODe><codE CLAss=o>(</CODE><COdE cLass="n">forename</cOde><COdE ClaSs="o">,</codE> <codE ClaSS=s>""</cOdE><cODE cLaSs=o>,</COdE> <coDE CLaSs="n">surname</Code><cODE cLAss=o>);</CodE>
      <coDE cLAsS=o>}</cOde>

      <CODE cLaSS="kd">public</CODe> <coDe clAsS=kd>static</CoDe> <code clASs=kt>void</COde> <codE clASs=nf>main</coDe><cODe claSS="o">(</CODE><CoDe cLaSS="n">String</coDe><CODe ClaSS=o>...</COde> <codE clASs=n>args</cODE><coDE ClasS="o">)</code> <cODe claSS="o">{</CoDe>
          <coDE class=n>System</CODe><cODE cLASS="o">.</CODe><cOdE ClASS="na">out</COdE><coDE clASS="o">.</coDe><Code cLass="na">println</cOde><CoDE CLASS="o">(</cOde><cOdE ClAss="k">new</coDE> <COde Class="n">Customer</CODE><CodE ClaSs=o>(</cOdE><cOdE cLASS="s">"Bob"</cOde><codE ClaSS="o">,</CoDe> <codE CLasS=s>"J"</coDe><COde claSs="o">,</codE> <CodE cLAsS=s>"Smith"</cODe><Code Class=o>).</CoDE><COde CLaSS=na>fullname</Code><CoDe clASS=o>);</CODE>
          <code cLAss="n">System</COde><coDe cLaSS="o">.</COdE><coDe ClaSS="na">out</CodE><coDE clASs=o>.</COde><CodE ClaSS=na>println</code><COdE ClasS=o>(</COde><cODe Class="k">new</cODe> <CodE claSs="n">Customer</Code><coDe clAss="o">(</codE><code clAsS=s>"Bob"</coDe><Code cLAsS=o>,</codE> <cOdE clasS="s">"Smith"</cOdE><codE cLaSs=o>).</COde><cOde ClAsS="na">fullname</COde><cOde clAss=o>);</Code>
      <CoDE cLAsS=o>}</cODE>
  <CodE Class=o>}</cODe>
</prE></Div>

</dIV>

<p>Creating additional or <EM>auxiliary constructors</EM> in Scala is just a matter of creating methods called <code>this</cODe>. The one constraint is that each auxiliary constructor must call another constructor using <coDe>this</COde> on its first line. That way, constructors will always be chained, all the way to the top.

<p>Scala has the notion of a <em>primary constructor</EM>; it’s the code in the class body. Any parameters passed in from the class definition are available to it and if you don’t write any auxiliary constructors, the class will still have a constructor; it’s the implicit primary constructor.

<dIV CLasS=code-block>
<diV CLass=highlight><pre>  <cODE ClASs="c1">// scala</cOde>
  <coDe cLAss=k>class</cODE> <coDE ClASS=nc>Customer</cODe><CODe CLASS="o">(</cOde><CoDe ClAss="n">forename</cODe><CODe cLasS="k">:</cOdE> <code cLASS=kt>String</coDe><codE clasS=o>,</code> <CoDE claSs="n">initial</codE><cOdE ClaSs=k>:</cODE> <CodE CLaSS=kt>String</cOdE><cOdE CLass="o">,</coDE> <code clAsS=n>surname</cOde><cODe cLasS=k>:</cOdE> <cODE claSs="kt">String</CodE><cODe ClASs=o>)</CODe> <CoDe CLASs=o>{</CodE>
    <cODe clASs="c1">// primary constructor</CoDe>
  <code CLasS="o">}</codE>
</pre></diV>

</div>

<p>So, if we create a field within the primary constructor and assign it some value,</p>

<DiV CLAss=code-block>
<dIv Class=highlight><pRe>  <cOdE cLaSs=c1>// scala</CODE>
  <cOde class=k>class</CODe> <CODe claSs="nc">Customer</codE><CoDE cLASs=o>(</cOdE><CODe clAss="n">forename</CodE><codE clASs=k>:</codE> <codE ClAsS="kt">String</Code><cOde cLASs="o">,</cOdE> <cODE CLasS="n">initial</CodE><codE cLASs=k>:</cOde> <CODE ClAss=kt>String</coDe><code clASS="o">,</Code> <coDe CLASS="n">surname</cODe><cODE ClAss="k">:</CODE> <CoDE ClAss="kt">String</code><cOdE CLass=o>)</codE> <coDe class=o>{</COdE>
    <cOde clAss="k">val</COdE> <coDe ClAsS=n>fullname</COde> <CODe clASs=k>=</COdE> <coDe clasS="nc">String</Code><cOde ClASS=o>.</Code><codE ClASS="n">format</codE><cOde cLaSS="o">(</cODE><COde cLaSs=s>"%s %s. %s"</codE><cODE CLAss="o">,</cOdE> <COde CLass=n>forename</coDE><CoDe ClasS=o>,</CoDE> <cODe cLASs=n>initial</CODe><cOdE CLaSS=o>,</CoDe> <COde CLasS="n">surname</COdE><cODe cLAss="o">)</cODE>
  <cODe cLass="o">}</CoDE>
</PRE></DIv>

</dIV>

<p>…it would be equivalent to the following Java:</P>

<DIV claSs="code-block">
<Div clAsS="highlight"><pRE>  <cODE clasS="c1">// java</coDE>
  <cODe CLAsS="kd">public</CODe> <CODE ClaSS=kd>class</code> <coDE CLaSs="nc">Customer</coDE> <CoDE clasS="o">{</coDe>
      <cOde clASs="kd">private</cOdE> <CoDe Class=kd>final</cOde> <coDE CLaSS=n>String</CODE> <CodE cLass="n">fullname</CodE><COde cLAss="o">;</Code>

      <COde CLass=kd>public</CodE> <CODE cLASS=nf>Customer</Code><COde claSs="o">(</Code><CodE clASS="n">String</CodE> <coDe claSS=n>forename</CodE><cOdE cLASs=o>,</CODe> <codE ClasS="n">String</CoDE> <COdE cLaSS=n>initial</coDE><CoDe cLAss="o">,</code> <cOde CLass="n">String</cOdE> <COde cLass="n">surname</code><coDe clASS=o>)</cOdE> <CodE clAsS="o">{</COdE>
          <coDE cLass="k">this</CoDE><cODe ClasS=o>.</CoDe><CodE clAss="na">fullname</Code> <CodE ClasS="o">=</CODe>
              <codE cLaSs="n">String</cODe><cOdE ClaSS="o">.</codE><Code CLasS="na">format</cODe><cODe clAsS="o">(</coDe><cODE ClaSs=s>"%s %s. %s"</CODe><Code ClASS=o>,</code> <CoDE ClASs="n">forename</cOde><cOde ClasS=o>,</COdE> <COdE clAss="n">initial</cOde><code cLAsS="o">,</CoDe> <code clasS=n>surname</COdE><CODE CLass=o>);</coDE>
      <codE class=o>}</COde>
  <CODe clasS="o">}</CODe>
</Pre></DIv>

</div>

<p>If we can add an another auxiliary constructor to the Scala version, we can refer to <coDe>this</CoDE> to chain the call to the primary constructor.</P>

<Div claSS=code-block>
<dIv CLAss=highlight><PRE>  <cOdE CLasS="c1">// scala</Code>
  <CODE ClAss="k">class</code> <cOde ClAsS="nc">Customer</COdE><cODe ClASs="o">(</code><cOdE Class="n">forename</CodE><code clASs=k>:</code> <CODe cLAsS=kt>String</Code><CoDE clAss="o">,</CODE> <CodE ClasS="n">initial</COdE><COde ClAsS=k>:</codE> <codE CLASs="kt">String</cODe><CoDE CLAsS=o>,</CoDE> <CoDe CLaSs="n">surname</COdE><cODe cLASS=k>:</COde> <CODE cLAsS="kt">String</CODe><COdE CLaSs="o">)</COdE> <coDE CLAss=o>{</CodE>
    <CODE ClAsS="k">val</CoDE> <COdE cLAsS=n>fullname</CODe> <code clAsS=k>=</CODE> <CODE clAss=nc>String</cODE><CoDE cLass="o">.</CODe><code claSS=n>format</CODE><cOdE CLaSs="o">(</coDe><cODE ClASS=s>"%s %s. %s"</CODE><code CLaSs="o">,</code> <codE clAsS=n>forename</CODe><coDE CLAss="o">,</COdE> <CODe cLaSs=n>initial</cOde><code class="o">,</CodE> <CODe cLASS=n>surname</cOde><cODe CLaSS="o">)</CodE>

    <coDE clAsS=k>def</CodE> <CoDe cLASs=k>this</codE><CodE clasS=o>(</cODE><CODE ClasS="n">forename</CODE><COde clAss="k">:</cODe> <cOdE cLAsS=kt>String</codE><CodE CLASS="o">,</codE> <COdE ClaSs="n">surname</COdE><CoDE cLASs=k>:</coDE> <CODE CLASs="kt">String</codE><CodE cLAsS=o>)</coDe> <code clASs=o>{</CoDe>
      <COdE cLass=k>this</cODE><CODE cLaSS=o>(</cOdE><cODE cLaSs=n>forename</cODe><cODe clAsS="o">,</coDE> <CODE clAss=s>""</cODE><CodE clasS="o">,</CODe> <CoDe CLaSs="n">surname</codE><cOdE CLASs="o">)</cOde>
    <cOde ClAss=o>}</cODe>
  <CodE clasS="o">}</Code>
</prE></DiV>

</dIV>

<h4 id="leanpub-auto-using-default-values">Using Default Values</H4>

<P>Scala has language support for default values on method signatures, so we could have written this using just parameters on the class definition, and avoided the extra constructor. We’d just default the value for <cOde>initial</cODE> to be an empty string. To make the implementation handle empty strings better, we can put some logic in the primary constructor like before.

<DIV clAsS="code-block">
<div ClASs="highlight"><PRe>  <cOde ClaSs=k>class</CoDe> <CoDE claSs="nc">Customer</cODe><coDE clAss=o>(</cOde><CoDE ClasS=n>forename</CODe><CoDe class=k>:</COde> <CODE clAss=kt>String</codE><code CLaSs=o>,</CoDE> <coDe CLAsS="n">initial</coDe><Code clAss=k>:</codE> <CoDe ClASS="kt">String</CoDE> <cODE CLASS=o>=</cOde> <CoDE ClAss=s>""</COde><COde clAss="o">,</cOde> <coDe cLAsS=n>surname</CODe><cOde clAss=k>:</CodE> <CodE clASS="kt">String</CODe><cODE cLasS="o">)</Code> <cODe CLaSS="o">{</cODE>
    <cODE cLaSs="k">val</codE> <coDE clAss=n>fullname</codE> <codE ClaSS=k>=</CoDE> <cOdE cLaSS=k>if</CodE> <CODE ClASs="o">(</Code><codE CLASS="n">initial</COdE> <CoDE cLASs="o">!=</CoDe> <CODE ClAss=kc>null</cODE> <CODE cLAss="o">&amp;&amp;</cOdE> <CodE ClaSS="o">!</CoDE><coDE clasS=n>initial</coDE><cODe ClAss="o">.</CodE><COdE ClAss=n>isEmpty</cOdE><CoDe ClasS="o">)</CODe>
      <Code Class="n">forename</coDE> <Code cLASs=o>+</CodE> <cOde cLASs="s">" "</cODE> <coDe clASS=o>+</code> <coDe CLaSS="n">initial</cODE> <cOdE CLASs="o">+</cODE> <coDE cLass="s">". "</cOde> <code cLasS=o>+</CodE> <CODE cLasS=n>surname</COde>
    <CODE cLAss=k>else</cODE>
      <Code ClasS=n>forename</cOde> <CodE cLASs="o">+</coDe> <COde Class="s">" "</CoDE> <CoDE cLAsS=o>+</code> <cODe cLaSS=n>surname</cODE>
  <coDe cLAss="o">}</cODe>
</pRE></DIv>

</DiV>

<p>When calling it, we may need to name default values; for example:</p>

<DIv CLASS="code-block">
<DIv ClaSS="highlight"><PRe>  <CODe claSS="k">new</COde> <CoDe cLAss="nc">Customer</Code><coDE cLAsS="o">(</codE><CODE clASs=s>"Bob"</Code><CODE clasS="o">,</COde> <coDe ClaSs="s">"J"</code><CoDE cLaSs=o>,</Code> <code CLaSS="s">"Smith"</CodE><cODE CLAsS=o>)</COde>
</Pre></DIv>

</DiV>

<p><CODE>"Bob", "J", "Smith"</code> is ok, but if we skip the <cOdE>initial</COde> variable, we’d need to name the surname variable like this:</p>

<diV ClaSS=code-block>
<dIv CLaSS=highlight><PRe>  <COdE clasS="k">new</COde> <CodE ClAsS=nc>Customer</COdE><COde cLASs=o>(</coDe><COde CLass="s">"Bob"</coDE><codE cLasS=o>,</COde> <Code ClaSs=n>surname</codE> <CODE ClASs="k">=</CoDE> <cODE CLasS=s>"Smith"</CODe><CoDe CLasS="o">)</cOdE>
</prE></DIV>

</Div>

<H3 id="leanpub-auto-singleton-objects">Singleton Objects</h3>

<P>In Java you can enforce a single instance of a class using the singleton pattern. Scala has made this idea as a feature of the language: as well as classes, you can define (singleton) <em>objects</eM>.</p>

<p>The downside is that when we talk about “objects” in Scala, we’re overloading the term. We might mean an instance of a class (for example, a <code>new ShoppingCart()</cOde>, of which there could be many) or we might mean the one and only instance of a class; that is, a singleton object.</P>

<p>A typical use-case for a singleton in Java is if we need to use a single logger instance across an entire application.

<DIv ClASs=code-block>
<DIv CLass=highlight><Pre>  <COde CLAsS="c1">// java</cOde>
  <coDE Class="n">Logger</code><CoDE cLaSs="o">.</coDe><CoDE ClasS=na>getLogger</Code><code clASS=o>(</code><CODE cLASS=s>"example"</Code><cOdE CLaSs=o>).</CODE><cOdE Class=na>log</cOde><Code class=o>(</Code><CODE clasS="n">INFO</CODe><coDe ClaSS=o>,</COdE> <CoDe cLasS="s">"Everything is fine."</coDE><cOdE ClASS="o">);</COde>
</PRe></DIv>

</div>

<Div clAss=page-break></DIV><DiV sTYLE=page-break-after:always></dIv>
<P>We might implement the singleton like this:</P>

<DiV clAsS="code-block">
<DIv CLasS="highlight"><PRE>  <COde ClaSS="c1">// java</COdE>
  <code cLaSS=kd>public</Code> <cODe clASS=kd>final</coDE> <codE CLASS="kd">class</COdE> <cOdE CLASs=nc>Logger</cOdE> <Code CLaSS="o">{</cODE>

      <CoDE claSS=kd>private</COdE> <codE cLaSs="kd">static</cOde> <Code cLass=kd>final</coDE> <cODe cLaSs="n">Logger</cOde> <cODE cLaSS=n>INSTANCE</code> <cODE CLAsS=o>=</code> <CoDe cLaSS=k>new</coDE> <coDE cLASs="n">Logger</CODE><COde CLasS="o">();</codE>

      <code cLass=kd>private</CODe> <COde clasS=nf>Logger</CoDe><cOdE clASS="o">()</CODe> <cODe cLaSs=o>{</codE> <cODE CLasS="o">}</COde>

      <cOde ClaSs=kd>public</CoDe> <cOdE CLASS="kd">static</cOdE> <COdE clASs=n>Logger</cOde> <code cLaSS="nf">getLogger</codE><cOde class="o">()</coDe> <coDe cLAss="o">{</CoDe>
          <COde ClAss="k">return</CoDE> <coDe cLASS=n>INSTANCE</COdE><cODE clASs="o">;</cOde>
      <CoDE cLaSs=o>}</CoDE>

      <cODe cLASS=kd>public</coDE> <CODE ClAsS="kt">void</cODe> <CodE CLASS="nf">log</CODE><coDE cLAss="o">(</cOdE><codE ClaSS="n">Level</code> <coDe cLaSs=n>level</codE><cOde clASS=o>,</codE> <COde cLass=n>String</cODe> <codE CLaSs=n>string</CoDE><cOde ClasS=o>)</code> <CODe CLass=o>{</cODe>
          <COdE cLaSS=n>System</Code><cODE CLass="o">.</CoDE><cODe CLASS=na>out</CoDe><cOdE clASS=o>.</CODe><COdE CLAsS="na">printf</code><CodE ClasS="o">(</cOde><coDe cLaSs=s>"%s %s%n"</CodE><cOde ClasS="o">,</cODE> <COde CLASS=n>level</cOdE><CoDe cLaSs="o">,</codE> <cODE CLass=n>string</Code><codE ClAss=o>);</COde>
      <cODe CLass=o>}</cODE>
  <COdE Class="o">}</coDe>
</pRE></DiV>

</DiV>

<p>We create a <CODE>Logger</CODe> class, and a single static instance of it. We prevent anyone else creating one by using a private constructor. We then create an accessor to the static instance, and finally give it a rudimentary log method. We’d call it like this:</P>

<DiV clAss="code-block">
<DIV ClasS="highlight"><Pre>  <Code CLASs="c1">// java</CODe>
  <cOde cLaSS="n">Logger</cOdE><codE class="o">.</cOdE><COdE clAsS=na>getLogger</COde><coDE CLAsS="o">().</coDe><codE CLAss="na">log</cOdE><CodE clASs=o>(</COde><cOde claSs=n>INFO</code><coDE ClasS=o>,</coDE> <codE cLASs=s>"Singleton loggers say YEAH!"</coDE><code cLAss=o>);</codE>
</PrE></DiV>

</dIv>

<P>A more concise way to achieve the same thing in Java would be to use an enum.

<dIv ClaSS=code-block>
<div clAss=highlight><PRe>  <COdE CLAss="c1">// java</coDe>
  <cODe ClAsS=kd>public</CODe> <codE CLASS=kd>enum</CoDE> <Code ClASS="n">LoggerEnum</cOdE> <cODE clAss="o">{</CoDE>

      <CODe cLASs="n">LOGGER</CODe><cODe ClASs="o">;</coDE>

      <cODe clAsS=kd>public</COde> <code CLaSs=kt>void</cOdE> <CoDe cLASs="nf">log</COde><COdE cLASS="o">(</cODe><CoDE claSs=n>Level</cODE> <coDe ClASs="n">level</CodE><CoDE cLASs="o">,</codE> <cOdE cLAss=n>String</cOdE> <CODe cLAss="n">string</CoDe><CODE cLASs="o">)</CODE> <CODe cLasS=o>{</COdE>
          <cODE claSS="n">System</CoDe><CODe ClaSS=o>.</cOde><CodE CLasS="na">out</codE><cOde CLass=o>.</cODe><code clAss=na>printf</code><CoDe ClaSS="o">(</CODE><coDe CLass="s">"%s %s%n"</coDe><cODe cLAss=o>,</coDE> <CodE cLAss=n>level</CoDe><cODE cLAsS=o>,</CoDe> <CoDE ClASs=n>string</cOde><coDe ClAsS=o>);</CODe>
      <cOde ClAss=o>}</CoDe>
  <CODE ClASS=o>}</cODE>
</Pre></DIv>

</DiV>

<P>We don’t need to use an accessor method; Java ensures a single instance is used and we’d call it like this:

<DiV CLasS="code-block">
<DiV class="highlight"><pRE>  <codE CLasS=c1>// java</CODe>
  <CoDe clASS="n">LOGGER</CoDE><cOde cLasS="o">.</CODe><Code ClASs="na">log</cODE><COdE ClasS=o>(</cODe><cODe ClASS="n">INFO</CoDE><cOdE ClASs=o>,</COde> <CODE cLASs="s">"An alternative example using an enum"</cOde><cOdE CLASs="o">);</code>
</Pre></DIv>

</dIv>

<p>Either way, they prevent clients newing up an instance of the class and provide a single, global instance for use.</P>

<P>The Scala equivalent would look like this:

<dIV ClASS="code-block">
<DiV clASs=highlight><pre>  <cOdE cLass="c1">// scala</codE>
  <coDE cLaSs="k">object</CODe> <cODE claSs="nc">Logger</coDE> <coDE CLaSs="o">{</coDe>
    <coDe CLAsS="k">def</CODE> <CoDE CLASS=n>log</cOde><COde clAss="o">(</codE><cOde cLASs="n">level</code><cOdE cLASS=k>:</coDe> <codE ClaSs="kt">Level</code><COdE cLAss=o>,</CODE> <cOde CLasS="n">string</CODe><Code ClaSs="k">:</CodE> <COde clAss=kt>String</cODe><coDE ClasS=o>)</cODe> <code clAsS="o">{</COdE>
      <cODE clASs=n>printf</cOde><COde cLass="o">(</code><cODE ClASS=s>"%s %s%n"</codE><Code ClasS=o>,</cOdE> <CoDE CLasS=n>level</code><coDe ClASS=o>,</CoDE> <codE ClaSS="n">string</cOde><codE ClAsS="o">)</Code>
    <CoDe CLASs=o>}</CoDE>
  <COdE clASs="o">}</CoDe>
</pRe></div>

</Div>

<P>The thing to notice here is that the singleton instance is denoted by the <COde>object</COdE> keyword rather than <CoDe>class</Code>. So we’re saying “define a single object called <CODE>Logger</CODE>” rather than “define a class”.</P>

<P>Under the covers, Scala is creating basically the same Java code as our singleton pattern example. You can see this when we decompile it.</P>

<DIV CLass=code-block>
<diV ClaSs="highlight"><pre><coDE cLass=lineno> 1</cODE>   <Code ClaSS=c1>// decompiled from scala to java</cODe>
<cOdE ClaSS="lineno"> 2</CoDe>   <CoDe CLasS=kd>public</codE> <COdE CLASs=kd>final</CODE> <CODe cLAss="kd">class</cODE> <COde clASs=nc>Logger</CodE><cODE cLASS=n>$</Code> <cODE clAsS=o>{</codE>
<cOde ClasS=lineno> 3</CODe>       <coDe cLasS=kd>public</cOde> <cOdE CLaSS=kd>static</cODE> <coDE ClaSS="kd">final</CODe> <COde clasS=n>Logger$</cODE> <CoDe cLaSs="n">MODULE$</cOdE><CoDE ClAss="o">;</CODe>
<cODe CLasS=lineno> 4</cOdE> 
<Code clasS="lineno"> 5</CoDE>       <cOdE cLASS="kd">public</cODE> <CODe ClaSS="kd">static</code> <coDe ClaSs="o">{</CODe>
<CoDE CLAsS=lineno> 6</cOde>           <coDe CLAsS="k">new</cODe> <cODe ClAss="n">scala</codE><CoDE clASS=o>.</cOde><cODe cLaSS="na">demo</cOde><COdE ClaSS=o>.</Code><cODe cLaSS=na>singleton</CoDE><CoDe cLasS=o>.</cOde><cODe cLass=na>Logger</codE><Code CLASS="n">$</COdE><COde ClasS="o">();</CoDE>
<CODe clasS="lineno"> 7</CoDE>       <Code CLass=o>}</code>
<cOde CLasS="lineno"> 8</CoDE> 
<cODE ClASS=lineno> 9</cOde>       <cOde claSS="kd">public</CODe> <CoDE cLAsS=kt>void</cODe> <codE CLAss=nf>log</COdE><cODE CLass="o">(</CODe><code clASS=n>Level</COde> <cODE ClASs="n">level</cODe><cOdE CLASS=o>,</cOde> <Code cLASS="n">String</codE> <COde Class=n>string</CoDe><cOde cLAss=o>)</COdE> <COde cLAsS=o>{</coDE>
<Code cLasS="lineno">10</coDe>           <cODe CLasS=n>Predef</CoDE><coDe CLAss=o>..</Code><CodE CLASS=na>MODULE</Code><cOde clAsS="n">$</cOde><Code CLasS="o">.</COdE><CODE clASS="na">printf</COdE><Code clasS=o>(</Code><cODE cLaSs="s">"%s %s%n"</CoDe><cODe CLASs=o>,</coDE> <CoDE CLASS="o">(</coDE><cODE cLASs="n">Seq</cOde><Code ClasS=o>)</CODe><cOde CLAss="n">Predef</codE><CODe ClASs=o>..</cODe><CodE claSs="na">MODULE</CoDe><cOdE cLASs=n>$</Code>
<cOde cLAss=lineno>11</COdE>             <codE CLaSS=o>.</CoDE><CoDe ClasS=na>genericWrapArray</CODe><code claSs=o>((</CODe><CoDE cLaSs=n>Object</cOde><code cLAsS="o">)</cODe><cODE ClAss=k>new</codE> <code ClAsS=n>Object</coDe><CODe cLaSs="o">[]{</code><codE cLASS=n>level</code><COdE cLaSS="o">,</CoDe> <cOdE clASs=n>string</codE><coDe claSS=o>}));</COdE>
<COde clasS="lineno">12</codE>       <COdE clASs="o">}</cODe>
<Code clasS="lineno">13</cOde> 
<coDe clAsS="lineno">14</cOdE>       <cODE cLaSS=kd>private</COde> <code cLASs=n>Logger$</Code><CodE cLaSs="o">()</codE> <CoDE ClasS=o>{</cODe>
<CoDe ClASs=lineno>15</code>           <cODe CLAss="n">Logger$</cOde><CodE cLASs="o">.</COdE><cOde ClaSs="na">MODULE</CODE><cODE clAsS=n>$</Code> <CODE CLaSS="o">=</coDe> <cODe ClAss="k">this</Code><CoDe claSs=o>;</COdE>
<Code ClaSs="lineno">16</code>       <Code cLass=o>}</coDE>
<CODE ClaSs=lineno>17</CoDe>   <COde clASs=o>}</codE>
</PRE></DIV>

</DIV>

<P>There are some oddities in the <CoDe>log</codE> method, but that’s the decompiler struggling to decompile the bytecode, and generally how Scala goes about things. In essence though, it’s equivalent; there’s a private constructor like the Java version, and a single static instance of the object. The class itself is even final.</p>

<p>There’s no need to new up a new <CODE>Logger</CODe>; <CODE>Logger</CoDe> is already an object, so we can refer to it directly. In fact, you couldn’t new one up if you wanted to, because there’s no class definition and so no class to new up.</P>

<P>Incidentally, you replicate Java’s static <COdE>main</coDe> method by adding a <cODE>main</CoDE> method to a Scala singleton object, not a class.

<h3 id="leanpub-auto-companion-objects">Companion Objects</H3>

<p>You can combine objects and classes in Scala. When you create a class and an object with the same name in the same source file, the <Em>object</em> is known as a <em>companion object</EM>.

<P>Scala doesn’t have a <CodE>static</CoDe> keyword but members of singleton objects are effectively static. Remember that a Scala singleton object is just that, a singleton. Any members it contains will therefore be reused by all clients using the object; they’re globally available just like statics.

<P>You use companion objects where you would mix statics and non-statics in Java.</P>

<p>The Java version of <cODe>Customer</CodE> has fields for the customer’s name and address, and an ID to identify the customer uniquely.</p>

<diV cLAss="code-block">
<DIv cLass=highlight><PrE>  <CODe clasS="c1">// java</coDe>
  <code claSS="kd">public</CoDe> <cOdE CLasS="kd">class</CoDe> <cODe ClASs=nc>Customer</cODe> <cODe CLAss=o>{</COdE>

      <cODe CLasS=kd>private</CoDE> <CODE CLAsS="kd">final</codE> <CodE ClaSS=n>String</CODE> <coDe ClASS=n>name</cOde><CODe clAss="o">;</CoDE>
      <CODE cLASS="kd">private</CODE> <CodE ClAss=kd>final</Code> <CODe CLASS=n>String</coDE> <coDE ClAss="n">address</CoDE><CoDE clAsS="o">;</CoDE>

      <coDe cLaSs=kd>private</Code> <CoDE class=n>Integer</cODE> <CodE cLASs=n>id</CoDE><CodE CLAsS="o">;</Code>

      <COde ClAsS=kd>public</Code> <coDE CLASs="nf">Customer</code><cODe clasS=o>(</cOde><Code cLaSS=n>String</CODe> <CODE class="n">name</coDE><COdE ClAss=o>,</cOde> <CODE ClASs=n>String</CodE> <cOde ClASS=n>address</COde><code cLAsS=o>)</cOde> <Code cLaSs="o">{</CODE>
          <COdE cLAss="k">this</coDe><coDE CLAsS=o>.</CoDE><COdE class="na">name</CoDE> <codE cLass="o">=</COdE> <coDE claSS="n">name</cODe><cODe cLAss="o">;</COdE>
          <CoDE Class="k">this</codE><Code ClAsS="o">.</CODe><codE CLasS=na>address</cODE> <COde CLAss=o>=</Code> <cODE ClaSs="n">address</CoDe><coDe CLass=o>;</CodE>
      <cOdE CLaSS="o">}</code>
  <coDE CLass=o>}</CODE>
</prE></DIv>

</diV>

<p>Now we may want to create a helper method to create the next ID in a sequence. To do that globally, we create a static field to capture a value for the ID and a method to return and increment it. We can then just call the method on construction of a new instance, assigning its ID to the freshly incremented global ID.

<diV Class="code-block">
<div ClAsS=highlight><PRe>  <cOde cLaSS=c1>// java</cODe>
  <CODE CLASs="kd">public</CODE> <COde cLASs=kd>class</code> <cODE ClAss="nc">Customer</CoDE> <CODe CLAss="o">{</CODe>

      <cOdE CLaSs="kd">private</coDe> <coDE ClaSS=kd>static</COdE> <codE cLass=n>Integer</cODe> <CoDe CLAss="n">sequenceOfIds</CoDe><COdE ClASs="o">;</CoDe>

      <cODe cLASS="kd">private</Code> <cODE ClASS="kd">final</CODe> <CODE cLaSs="n">String</cODE> <CodE clASs="n">name</COde><codE CLASs="o">;</CodE>
      <CodE cLaSS=kd>private</CODe> <cODe claSs=kd>final</coDe> <cODe ClAss="n">String</CODe> <COde cLaSs=n>address</CoDe><coDE Class="o">;</CODe>

      <COde clasS=kd>private</CodE> <CODE CLASs="n">Integer</cODE> <codE claSS=n>id</cOdE><CodE cLaSs="o">;</cODE>

      <COde clASs=kd>public</CODe> <CoDE CLASS=nf>Customer</COde><Code Class="o">(</coDE><CoDE ClASS="n">String</CODe> <cOdE cLaSs=n>name</CoDe><COdE ClAss="o">,</Code> <cODe ClASs="n">String</CODE> <coDe claSs=n>address</cODe><cODE ClASS="o">)</code> <cOdE clAsS="o">{</CODe>
          <cODe claSs=k>this</COdE><codE CLaSs=o>.</Code><CoDE clASS="na">name</CoDe> <coDE CLasS="o">=</cOdE> <codE cLasS="n">name</CoDE><COdE cLAsS=o>;</code>
          <code cLASS=k>this</COdE><Code CLASs="o">.</CODe><COde ClaSs=na>address</CODE> <CoDe cLaSs=o>=</codE> <codE CLAsS="n">address</COdE><CoDe CLaSs=o>;</code>
          <cOdE cLass="k">this</CoDe><code claSS=o>.</CodE><CoDe claSS=na>id</CODe> <cOdE claSs="o">=</CODe> <CodE cLAsS=n>Customer</cODe><cOdE CLaSs=o>.</coDE><codE CLAss="na">nextId</Code><coDe ClAss="o">();</CoDE>
      <CoDE cLaSS="o">}</codE>

      <COdE CLASS="kd">private</CoDe> <COde cLaSS="kd">static</cOdE> <codE cLASs=n>Integer</COdE> <CoDe cLaSS="nf">nextId</CoDe><COdE clAsS=o>()</CoDE> <cODe ClaSS="o">{</COdE>
          <CoDE ClasS=k>return</cODe> <CodE ClAss=n>sequenceOfIds</CODe><code claSS="o">++;</coDE>
      <Code class=o>}</CodE>

  <codE clASS=o>}</CODe>
</PrE></diV>

</DIV>

<p>It’s static because we want to share its implementation among all instances to create unique IDs for each.

<p>In Scala, we’d separate the static from non-static members and put the statics in the singleton object and the rest in the class. The singleton object is the <eM>companion object</eM> to <cOde>Customer</CoDE>.</p>

<p>We create our class with the two required fields and in the singleton object, create the <CodE>nextId</CoDE> method. Next we create a private <coDE>var</cODe> to capture the current value, assigning it the value of zero so Scala can infer the type as an <CodE>Integer</coDE>. Adding a <codE>val</cOdE> here means no setter will be generated, and adding the <COde>private</cOdE> modifier means the generated getter will be private. We finish off by implementing the increment in the <CoDE>nextId</CoDE> method and calling it from the primary constructor.

<diV ClAss=code-block>
<DiV Class=highlight><pRE>  <coDE cLAsS="c1">// scala</codE>
  <CodE cLaSS=k>class</COde> <COde cLass="nc">Customer</cOdE><cOde Class=o>(</cODe><CoDe cLAsS=k>val</COdE> <Code cLASS=n>name</CODE><codE ClaSS="k">:</cOdE> <coDE cLAsS=kt>String</codE><coDE clASs="o">,</cOde> <CODe cLASs=k>val</COdE> <CODE ClASS=n>address</cOde><COdE CLAss=k>:</Code> <coDe ClaSs="kt">String</cOde><COde ClaSs="o">)</cODe> <coDe CLaSS="o">{</CodE>
    <cODE claSs=k>private</code> <coDE clASS="k">val</cOdE> <CoDE ClASs="n">id</cODe> <cOde ClaSS=k>=</codE> <CoDe cLASs="nc">Customer</code><coDE class="o">.</CodE><Code ClaSs="n">nextId</coDe><CoDe Class="o">()</CodE>
  <cOde cLass=o>}</COde>

  <cODE ClASS="k">object</cOde> <CoDe cLAss=nc>Customer</cOdE> <Code claSs="o">{</COde>
    <cODe ClasS=k>private</COdE> <CodE CLAss=k>var</codE> <CoDE clAss="n">sequenceOfIds</CODe> <coDe ClAss=k>=</coDe> <coDe claSs=mi>0</CoDe>

    <COde CLass=k>private</code> <codE cLASs=k>def</Code> <CODE Class=n>nextId</codE><Code ClaSS="o">()</cODe><code CLAss=k>:</Code> <cODe cLASs="kt">Integer</CoDE> <codE cLAsS="o">=</codE> <cODE CLASS=o>{</CoDe>
      <code ClaSS=n>sequenceOfIds</COde> <CODe CLaSS="o">+=</cOde> <cODe CLAss="mi">1</cODE>
      <coDe cLASS="n">sequenceOfIds</cOde>
    <CODE CLaSs="o">}</coDe>
  <COdE CLasS=o>}</cODe>
</pre></DIV>

</Div>

<P>The singleton object is a <Em>companion object</EM> because it has the same name and lives in the same source file as its class. This means the two have a special relationship and can access each other’s private members. That’s how the <Code>Customer</coDE> object can define the <CodE>nextId</CODe> method as private but the <cODE>Customer</code> <Em>class</eM> can still access it.

<p>If you were to name the object differently, you wouldn’t have this special relationship and wouldn’t be able to call the method. For example, the class <Code>CustomerX</cOde> object below is not a companion object to <coDe>Customer</CODE> and so can’t see the private <CodE>nextId</COdE> method.</p>

<DiV clASs=code-block>
<diV ClaSS=highlight><PRe>   <CODe clAss=c1>// scala</CodE>
   <COde clAsS=k>class</cOdE> <COde ClAss="nc">Customer</CoDe><CodE CLAss="o">(</Code><CoDe CLASs=k>val</CODe> <CoDE CLASs=n>name</CoDE><CODE CLASS=k>:</code> <codE cLaSs=kt>String</coDE><cODe ClaSS="o">,</CodE> <cODe CLASS=k>val</coDe> <cOdE CLass=n>address</COdE><cOde CLasS="k">:</CodE> <cODE ClASs="kt">String</CODE><CODe CLaSs="o">)</codE> <codE CLASs="o">{</cODE>
     <COdE ClAsS="k">private</coDe> <codE clasS="k">val</CodE> <Code clasS=n>id</coDE> <CoDE CLaSS=k>=</codE> <COdE cLasS="nc">CustomerX</cOde><CoDe ClASS="o">.</CODE><cOde ClAss=n>nextId</CODE><CoDe cLAss=o>()</CODE>         <code claSS=c1>// compiler failure</cOde>
   <code ClASs=o>}</codE>

   <cODe claSS=k>object</coDe> <codE ClASS=nc>CustomerX</cOde> <cODe CLass=o>{</CODE>
     <coDE ClASS=k>private</CODe> <CODe CLasS="k">var</codE> <cODe CLaSS="n">sequenceOfIds</CODe> <COde ClaSs=k>=</COde> <cOde CLasS=mi>0</CoDE>

     <Code CLAss=k>private</cOdE> <cODE CLASs=k>def</cOdE> <COde ClasS=n>nextId</Code><Code CLass=o>()</cODE><CODe cLass="k">:</cODE> <CoDe claSs="kt">Integer</CoDE> <code cLASS="o">=</COdE> <COde CLASs=o>{</cODe>
       <cOdE cLaSs=n>sequenceOfIds</coDe> <coDE cLAsS=o>+=</CODe> <codE CLaSs=mi>1</coDe>
       <COdE CLass=n>sequenceOfIds</coDE>
     <cODe CLasS="o">}</CODe>
   <CODE clASs=o>}</coDE>
</Pre></diV>

</diV>

<H4 id="leanpub-auto-other-uses-for-companion-objects">Other Uses for Companion Objects</H4>

<p>When methods don’t depend on any of the fields in a class, you can more accurately think of them as functions. Functions generally belong in a singleton object rather than a class, so one example of when to use companion objects is when you want to distinguish between functions and methods, but keep related functions close to the class they relate to.

<p>Another reason to use a companion object is for factory-style methods — methods that create instances of the class companion. For example, you might want to create a factory method that creates an instance of your class but with less noise. If we want to create a factory for <COdE>Customer</coDE>, we can do so like this:

<dIV cLASS="code-block">
<Div cLASs="highlight"><pRe>  <coDe ClASS=c1>// scala</cODE>
  <codE ClaSs="k">class</coDe> <CoDE CLass="nc">Customer</cODE><CodE cLAsS="o">(</coDE><Code cLass=k>val</cODe> <cOde cLass=n>name</coDe><cODe ClasS=k>:</CODE> <COde ClaSs=kt>String</coDe><cODE cLaSs="o">,</CoDE> <CodE CLASS="k">val</COdE> <COde class=n>address</coDE><cOdE ClasS="k">:</cODe> <CodE cLASs="kt">String</CoDE><cOdE CLAss=o>)</Code> <code clASs=o>{</Code>
    <CodE ClaSs="k">val</CoDE> <coDE ClasS="n">id</CODe> <cODE cLasS="k">=</COdE> <code clAsS="nc">Customer</coDe><cOde ClasS=o>.</CODe><cODE ClasS="n">nextId</cODE><CoDE CLass=o>()</code>
  <COde CLASS="o">}</CoDE>

  <CoDE Class="k">object</CoDE> <CODE ClAsS=nc>Customer</Code> <coDE Class="o">{</cOdE>
    <CoDE cLaSs=k>def</CODE> <CODE CLass=n>apply</CodE><COde cLASS=o>(</COde><coDE clasS=n>name</coDE><cODe ClASS=k>:</CoDE> <codE CLASs=kt>String</Code><Code Class=o>,</CodE> <CODE ClasS=n>address</cODe><CodE ClASs=k>:</COde> <COdE clASS="kt">String</coDE><cODE CLaSs="o">)</coDe> <CODe class=k>=</cOdE> <coDe cLaSS=k>new</cODe> <cODE CLAsS="nc">Customer</CodE><COde ClASS=o>(</cOdE><cODe ClASs=n>name</CODe><cODe cLaSS=o>,</COde> <coDe CLaSS="n">address</cOdE><CodE clASS="o">)</CODE>
  <CODe cLaSs="o">}</cODe>
</PRe></Div>

</Div>

<p>The <CoDE>apply</COdE> method affords a shorthand notation for a class or object. It’s kind of like the default method for a class, so if you don’t call a method directly on an instance, but instead match the arguments of an <CodE>apply</cODE> method, it’ll call it for you. For example, you can call:</p>

<dIV CLAss="code-block">
<DIV clasS=highlight><prE>  <CoDE ClAsS=nc>Customer</cODE><code CLASS=o>.</coDe><code cLaSs="n">apply</CODE><COde ClASs=o>(</COdE><codE ClaSs=s>"Bob Fossil"</COdE><CoDe CLAss=o>,</codE> <coDE CLass=s>"1 London Road"</codE><CodE ClasS="o">)</CodE>
</pRe></DIV>

</DIV>

<p>…or you can drop the <cODE>apply</cOdE> and Scala will look for an apply method that matches your argument. The two are identical.

<DiV class=code-block>
<dIV cLasS=highlight><pRe>  <codE cLaSS=nc>Customer</CodE><COdE cLass="o">(</cOde><coDE clASs="s">"Bob Fossil"</CodE><coDe CLAss="o">,</COde> <cOde clAss="s">"1 London Road"</cOde><coDE cLaSS="o">)</code>
</pRE></div>

</DIV>

<P>You can still construct a class using the primary constructor and <COde>new</CODE>, but implementing the companion class <cOdE>apply</CoDe> method as a factory means you can be more concise if you have to create a lot of objects.</p>

<p>You can even force clients to use your factory method rather than the constructor by making the primary constructor private.

<Div CLAss=code-block>
<DIv CLASs=highlight><PrE>  <CoDE ClaSS=k>class</cOde> <CoDe CLasS="nc">Customer</coDE> <coDe cLAss="k">private</COde> <cOdE cLass="o">(</COde><COdE ClasS=k>val</cODE> <cODe CLASs=n>name</cOde><CodE CLasS="k">:</CodE> <CoDE cLASs=kt>String</coDE><cODE ClAsS=o>,</cOde> <CoDe clAss=k>val</cOdE> <CODE CLass="n">address</CODe><CodE cLasS="k">:</cOde> <CODe cLaSs=kt>String</coDe><COde CLaSs=o>)</CoDE> <CoDe claSs="o">{</Code>
    <CODe cLAsS="k">val</COde> <CodE clASS=n>id</cODE> <CoDE ClaSs="k">=</COde> <Code ClaSs="nc">Customer</CodE><cOde CLasS="o">.</CODe><coDE CLAss=n>nextId</CoDe><code CLaSS="o">()</cOde>
  <CODE ClaSS="o">}</CodE>
</prE></dIv>

</Div>

<p>The Java analog would have a static factory method, for example <CODE>createCustomer</cOde>, and a private constructor ensuring everyone is forced to use the factory method.</p>

<diV CLAss="page-break"></DIV><DiV sTYlE="page-break-after:always"></diV>
<dIV cLass="code-block">
<DiV Class="highlight"><PRe>  <cOdE cLaSS=c1>// java</coDe>
  <CODE cLass="kd">public</codE> <cODE claSS=kd>class</CODE> <CODe CLasS="nc">Customer</cOde> <codE clasS=o>{</CODe>

      <CoDE ClAss=kd>private</CoDE> <cODE ClAsS=kd>static</cODe> <codE CLAss=n>Integer</COde> <cOdE cLAss=n>sequenceOfIds</COdE><COde ClAsS="o">;</codE>

      <coDE ClaSS="kd">private</cOdE> <CoDe Class="kd">final</cODE> <codE clAsS="n">String</CODe> <COdE Class="n">name</code><COdE CLasS="o">;</coDe>
      <coDe cLAsS="kd">private</coDE> <CoDe ClAsS="kd">final</COde> <cOdE clasS=n>String</COde> <cOde clasS=n>address</cODE><CODe CLASS=o>;</codE>

      <cODE cLasS=kd>private</CoDE> <COdE CLASS="n">Integer</code> <CodE ClASS="n">id</code><Code ClAss=o>;</CoDe>

      <coDe cLASS="kd">public</cODe> <COde clASs="kd">static</code> <CoDE Class="n">Customer</cOde> <cODE CLass="nf">createCustomer</code><coDe CLASs=o>(</cOde><coDE claSS=n>String</cOde> <CoDe clASS=n>name</COde><cOde claSS=o>,</COde> <code cLAsS=n>String</Code> <cOde CLASS=n>address</COdE><coDe cLAss="o">)</CODE> <Code CLASS=o>{</Code>
          <CodE claSs=k>return</CODe> <Code cLaSs="k">new</coDE> <CODe CLAss=nf>Customer</CoDe><cODE clASs="o">(</cOdE><cODE claSS="n">name</CODe><CODe CLASS=o>,</cOdE> <coDE CLaSs=n>address</CoDe><cOde CLaSs=o>);</CodE>
      <COdE CLaSs=o>}</code>

      <CodE CLass=kd>private</CodE> <coDe Class="nf">Customer</codE><cOdE cLasS=o>(</code><CoDE clAss="n">String</CodE> <CodE ClasS=n>name</codE><codE cLaSS=o>,</coDe> <COde ClaSS="n">String</CODe> <cODe CLaSS="n">address</cOde><cODe cLASs=o>)</coDE> <cODe CLasS=o>{</Code>
          <COde cLAss="k">this</cODE><cODE ClaSs="o">.</CODE><coDE clASS="na">name</CODE> <CoDE cLaSS=o>=</cODe> <cODE cLAsS=n>name</coDE><coDE cLaSs="o">;</codE>
          <COdE ClASS="k">this</cOdE><coDE clAss="o">.</code><COdE CLAsS="na">address</CODe> <cODe cLAsS=o>=</COde> <CODe ClAss=n>address</COde><Code class=o>;</Code>
          <COde class="k">this</coDe><CoDE clAss=o>.</COdE><codE claSS="na">id</COde> <coDE cLASs=o>=</coDE> <cODe ClAsS=n>Customer</code><cODE ClaSs=o>.</CoDE><code clASs=na>nextId</COdE><cOdE cLasS=o>();</COde>
      <cODE ClasS=o>}</cODE>

      <coDe clASS=kd>private</CodE> <CODe clASs=kd>static</CoDE> <CodE cLASs=n>Integer</cOdE> <CODE CLASS="nf">nextId</cODe><CoDE ClasS="o">()</coDE> <CODE ClASs="o">{</cODe>
          <cODe CLasS=k>return</codE> <CODE ClasS="n">sequenceOfIds</CoDe><CoDe CLass=o>++;</CODe>
      <COde CLasS=o>}</COde>

  <CodE clAsS="o">}</CODE>
</pRe></dIV>

</diV>
</dIV>
