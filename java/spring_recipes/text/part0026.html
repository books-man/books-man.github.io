<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Chapter 16 Spring Integration</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre"><p class="ChapterNumber"><a id="b9781430259084_16" class="calibre6"></a>CHAPTER 16</p>
<p class="Chapimage"><img src="../images/00008.jpeg" alt="image" class="calibre3"/></p>
<p class="ChapterTitle">Spring Integration</p>
<div class="calibre10"><p class="noindent">In this chapter, you will learn the principles behind enterprise application integration (EAI), used by many modern applications to decouple dependencies between components. The Spring framework provides a powerful and extensible framework called Spring Integration. Spring Integration provides the same level of decoupling for disparate systems and data that the core Spring framework provides for components within an application.</p>
<p class="indent">This chapter aims to give you all the required knowledge to understand the patterns involved in <i class="calibre8">EAI</i><a id="cXXX.1128" class="calibre5"></a>, to understand what an <i class="calibre8">enterprise service bus (ESB)</i><a id="cXXX.2031a" class="calibre5"></a> is, and - ultimately - how to build solutions using Spring Integration. If you’ve used an EAI server or an ESB<a id="cXXX.1129" class="calibre5"></a>, you’ll find that Spring Integration is markedly simpler than anything you’re likely to have used before.</p>
<p class="indent">After finishing this chapter, you will be able to write fairly sophisticated Spring Integration solutions to integrate applications, to let them to share services and data. You will learn Spring Integration’s many options for configuration, too. Spring Integration can be configured entirely in a standard XML namespace, if you like, but you’ll probably find that a hybrid approach, using annotations and XML, is more natural. You will also learn why Spring Integration is a very attractive alternative for people coming from a classic enterprise application integration background<a id="cXXX.2031" class="calibre5"></a>. If you’ve used an ESB before, such as Mule or ServiceMix, or a classical EAI server such as Axway’s Integrator or TIBCO’s ActiveMatrix, the idioms explained here should be familiar, and the configuration refreshingly straightforward.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To use Spring Integration, you need to have the requisite framework libraries and adapters on the classpath. If you are using Apache Maven, you should add - at a minimum for this chapter - the following dependencies to your project.</p>
<pre class="calibre19"><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;spring-integration-core&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;4.0.0.RELEASE&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span><br class="calibre2"/><br class="calibre2"/><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;spring-integration-httpinvoker&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;4.0.0.RELEASE&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span><br class="calibre2"/><br class="calibre2"/><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;spring-integration-file&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;4.0.0.RELEASE&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span><br class="calibre2"/><br class="calibre2"/><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;spring-integration-jms&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;4.0.0.RELEASE&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span><br class="calibre2"/><br class="calibre2"/><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;spring-integration-adapter&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;4.0.0.RELEASE&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span></pre></div>
<p id="Sec1" class="Heading">16-1. Integrating One System with Another Using EAI</p>
<p id="Sec2" class="Heading1">Problem</p>
<p class="noindent">You have two applications that need to talk to each other through external interfaces. You need to establish a connection between the applications’ services and/or their data.</p>
<p id="Sec3" class="Heading1">Solution</p>
<p class="noindent">You need to employ <i class="calibre8">EAI</i>, which is the discipline of integrating applications and data using a set of well-known patterns. These patterns are usefully summarized and embodied in a landmark book called <i class="calibre8">Enterprise Integration Patterns</i>, by Gregor Hohpe, Bobby Woolf, and colleagues. Today the patterns are canonical and are the lingua franca of the modern-day ESB<a id="cXXX.1130" class="calibre5"></a>.</p>
<p id="Sec4" class="Heading1">How It Works</p>
<p id="Sec5" class="Heading2">Picking an Integration Style</p>
<p class="noindent">There are multiple integration styles, each best suited for certain types of applications and requirements. The basic premise is simple: your application can’t speak directly to the other system using the native mechanism in one system. So you can devise a bridging connection, something to build on top of, abstract, or work around some characteristic about the other system in a way that’s advantageous to the invoking system. What you abstract is different for each application. Sometimes it’s the location, sometimes it’s the synchronous or asynchronous nature of the call, and sometimes it’s the messaging protocol<a id="cXXX.1131" class="calibre5"></a>. There are many criteria for choosing an integration style, related to how tightly coupled you want your application to be, to server affinity, to the demands of the messaging formats, and so on. In a way, TCP/IP<a id="cXXX.1132" class="calibre5"></a> is the most famous<a id="cXXX.1133" class="calibre5"></a> of all integration techniques because it decouples one application from another’s server.</p>
<p class="indent">You have probably built applications that use some or all of the following integration styles (using Spring, no less!). Shared Database, for example, is easily achieved using Spring’s JDBC support; Remote Procedure Invocation<a id="cXXX.1134" class="calibre5"></a> is easily achieved using Spring’s exporter functionality.</p>
<p class="indent">The four integration styles are as follows:</p>
<ul class="bulleted">
<li class="calibre17"><i class="calibre8">File transfer</i>: Have each application produce files of shared data for others to consume and consume files that others have produced.</li>
<li class="calibre17"><i class="calibre8">Shared database</i>: Have the applications store the data they want to share in a common database. This usually takes the form of a database to which different applications have access. This is not usually a favored approach because it means exposing your data to different clients who might not respect the constraints you have in place (but not codified). Using views and stored procedures can often make this option possible, but it’s not ideal. There’s no particular support for talking to a database, per se, but you can build an endpoint that deals with new results in a SQL database as message payloads. Integration with databases doesn’t tend to be granular or message-oriented, but batch-oriented instead. After all, a million new rows in a database isn’t an event so much as a batch! It’s no surprise then that Spring Batch (discussed in Chapter 21) included terrific support for JDBC<a id="cXXX.1135" class="calibre5"></a>-oriented input and output.</li>
<li class="calibre17"><i class="calibre8">Remote Procedure Invocation</i>: Have each application expose some of its procedures so that they can be invoked remotely and have applications invoke them to initiate behavior and exchange data. There is specific support for optimizing RPC (remote procedure calls such as SOAP, RMI, and HTTP Invoker) exchanges using Spring Integration.</li>
<li class="calibre17"><i class="calibre8">Messaging</i>: Have each application connect to a common messaging system and exchange data and invoke behavior using messages. This style, most enabled by JMS in the JEE world, also describes other asynchronous or multicast publish/subscribe architectures. In a way, an ESB or an EAI container such as Spring Integration lets you handle most of the other styles as though you were dealing with a messaging queue: a request comes in on a queue and is managed, responded to, or forwarded onward on another queue.</li></ul>
<p id="Sec6" class="Heading2">Building on an ESB Solution</p>
<p class="noindent">Now that you know how you want to approach the integration, it’s all about actually implementing it. You have many choices in today’s world. If the requirement is common enough, most middleware or frameworks will accommodate it in some way. JEE, .NET, and others handle common cases very well: SOAP, XMLRPC, a binary layer such as EJB or binary remoting, JMS, or a MQ abstraction. If, however, the requirement is somewhat exotic, or you have a lot of configuration to do, then perhaps an ESB is required. An ESB is middleware that provides a high-level approach to modeling integrations, in the spirit of the patterns described by EAI<i class="calibre8">.</i> The ESB provides a manageable configuration format for orchestrating the different pieces of an integration in a simple high-level format.</p>
<p class="indent">Spring Integration, an API in the SpringSource Portfolio<a id="cXXX.1136" class="calibre5"></a>, provides a robust mechanism for modeling a lot of these integration scenarios that work well with Spring. Spring Integration has many advantages over a lot of other ESBs, especially the lightweight nature of the framework. The nascent ESB market is filled with choices. Some are former EAI servers, reworked to address the ESB-centric architectures. Some are genuine ESBs, built with that in mind. Some are little more than message queues with adapters.</p>
<p class="indent">Indeed, if you’re looking for an extraordinarily powerful EAI server (with almost integration with the JEE platform and a very hefty price tag), you might consider Axway Integrator<a id="cXXX.1137" class="calibre5"></a>. There’s very little it can’t do. Vendors such as TIBCO and WebMethods made their marks (and were subsequently acquired) because they provided excellent tools for dealing with integration in the enterprise. These options, although powerful, are usually very expensive and middleware-centric: your integrations are deployed to the middleware.</p>
<p class="indent">Standardization attempts, such as Java Business Integration (JBI), have proven successful to an extent, and there are good compliant ESBs based on these standards (OpenESB and ServiceMix for example). One of the thought leaders in the ESB market is the Mule ESB, which has a good reputation; it is free/open source friendly, community friendly, and lightweight. These characteristics also make Spring Integration attractive. Often, you simply need to talk to another open system, and you don’t want to requisition a purchase approval for middleware that’s more expensive than some houses!</p>
<p class="indent">Each Spring Integration application is completely embedded and needs no server infrastructure. In fact, you could deploy an integration inside another application, perhaps in your web application endpoint. Spring Integration flips the deployment paradigms of most ESBs on their head: you deploy Spring Integration into your application; you don’t deploy your application into Spring Integration. There are no start and stop scripts and no ports to guard.</p>
<p class="indent">The simplest possible working Spring Integration application is a simple Java <span class="FontName">public static void main()</span> method<a id="cXXX.1138" class="calibre5"></a> to bootstrap a Spring context:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/>    <span class="FontName">public static void main(String [] args){</span><br class="calibre10"/>        <span class="FontName">String nameOfSpringIntegrationXmlConfigurationFile = args[0];</span><br class="calibre10"/>        <span class="FontName">ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(</span><br class="calibre10"/>                <span class="FontName">nameOfSpringIntegrationXmlConfigurationFile) ;</span><br class="calibre10"/>        <span class="FontName">applicationContext.start();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You created a standard Spring application context and started it. The contents of the Spring application context will be discussed in subsequent recipes, but it’s helpful to see how simple it is. You might decide to hoist the context up in a web application, an EJB container, or anything else you want. Indeed, you can use Spring Integration to power the e-mail polling functionality in a Swing/JavaFX application! It’s as lightweight as you want it to be.</p>
<p class="indent">In subsequent examples, the configuration shown should be put in an XML file and that XML file referenced as the first parameter when running this class. When the main method runs to completion, your context will start up the Spring Integration bus and start responding to requests on the components configured in the application context’s XML.</p>
<p id="Sec7" class="Heading">16-2. Integrating Two Systems Using JMS<a id="cXXX.1139" class="calibre6"></a></p>
<p id="Sec8" class="Heading1">Problem</p>
<p class="noindent">You want to build an integration to connect one application to another using JMS, which provides locational and temporal decoupling on modern middleware<a id="cXXX.1140" class="calibre5"></a> for Java applications. You’re interested in applying more sophisticated routing and want to isolate your code from the specifics of the origin of the message (in this case, the JMS queue or topic).</p>
<p id="Sec9" class="Heading1">Solution</p>
<p class="noindent">While you can do this by using regular JMS code or EJB’s support<a id="cXXX.1141" class="calibre5"></a> for message-driven beans (MDBs<a id="cXXX.1142" class="calibre5"></a>), or using core Spring’s message-driven POJO (MDP) support, all are necessarily coded for handling messages coming specifically from JMS. Your code is tied to JMS. Using an ESB lets you hide the origin of the message from the code that’s handling it. You’ll use this solution as an easy way to see how a Spring Integration solution can be built. Spring Integration provides an easy way to work with JMS, just as you might using MDPs in the core Spring container. Here, however, you could conceivably replace the JMS middleware with an e-mail, and the code that reacts to the message could stay the same.</p>
<p id="Sec10" class="Heading1">How It Works</p>
<p id="Sec11" class="Heading2">Building an Message Driven Pojo (MDP<a id="cXXX.1143" class="calibre6"></a>) Using Spring Integration</p>
<p class="noindent">As you recall from <a href="part0025.html" class="calibre5">Chapter 15</a>, Spring can replace EJB’s MDB functionality by using MDPs. This is a powerful solution for anyone wanting to build something that handles messages on a message queue. You’ll build an MDP, but you will configure it using Spring Integration’s more concise configuration and provide an example of a very rudimentary integration. All this integration will do is take an inbound JMS message (whose payload is of type <span class="FontName">Map&lt;String,Object&gt;</span>).</p>
<p class="indent">As with a standard MDP, configuration for the <span class="FontName">ConnectionFactory</span><a id="cXXX.1144" class="calibre5"></a> exists. There’s also a lot of other schema required for using the configuration elements available in Spring Integration. Shown following is a configuration file. You can store in on the classpath and pass it in as a parameter to the Spring <span class="FontName">ApplicationContext</span><a id="cXXX.1145" class="calibre5"></a> on creation (as you did in the previous recipe, in the <span class="FontName">Main</span> class).</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:beans xmlns:beans="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>            <span class="FontName"> xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration" class="calibre5">http://www.springframework.org/schema/integration</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xmlns:context="</span><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xmlns:jms="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration/jms" class="calibre5">http://www.springframework.org/schema/integration/jms</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans.xsd</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/context/spring-context.xsd" class="calibre5">http://www.springframework.org/schema/context/spring-context.xsd</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration" class="calibre5">http://www.springframework.org/schema/integration</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/spring-integration.xsd" class="calibre5">http://www.springframework.org/schema/integration/spring-integration.xsd</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/jms" class="calibre5">http://www.springframework.org/schema/integration/jms</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/jms/spring-integration-jms.xsd" class="calibre5">http://www.springframework.org/schema/integration/jms/spring-integration-jms.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;context:annotation-config/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="connectionFactory"       class="org.springframework.jms.connection.CachingConnectionFactory"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:property name="targetConnectionFactory"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;beans:bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;beans:property name="brokerURL" value="tcp://localhost:61616"/&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/beans:bean&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/beans:property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:property name="sessionCacheSize" value="10"/&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:property name="cacheProducers" value="false"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/beans:bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="inboundHelloWorldJMSPingServiceActivator"</span><br class="calibre10"/><b class="calibre4">class</b><span class="FontName">="com.apress.springrecipes.springintegration.InboundHelloWorldJMSMessageProcessor"/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;channel id="inboundHelloJMSMessageChannel"/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;jms:message-driven-channel-adapter</span><br class="calibre10"/>        <b class="calibre4">channel</b><span class="FontName">="inboundHelloJMSMessageChannel"</span><br class="calibre10"/>        <span class="FontName">extract-payload="true"</span><br class="calibre10"/>        <span class="FontName">connection-factory="connectionFactory"</span><br class="calibre10"/>        <span class="FontName">destination-name="solution011"/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;service-activator input-channel="inboundHelloJMSMessageChannel"</span><br class="calibre10"/><span class="FontName">ref="inboundHelloWorldJMSPingServiceActivator"/&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans:beans&gt;</span></pre>
<p class="indent">As you can see, the most intimidating part is the schema import! The rest of the code is standard boilerplate. You define a <span class="FontName">connectionFactory</span> exactly as if you were configuring a standard MDP.</p>
<p class="indent">Then, you define any beans specific to this solution: in this case a bean that responds to messages coming in to the bus from the message queue, <span class="FontName">inboundHelloWorldJMSPingServiceActivator</span>. A <span class="FontName">service-activator</span> is a generic endpoint in Spring Integration that’s used to invoke functionality—whether it be an operation in a service, or some routine in a regular POJO, or anything you want instead—in response to a message sent in on an input channel. Although this will be covered in some detail, it’s interesting here only because you are using it to respond to messages. These beans taken together are the collaborators in the solution, and this example is fairly representative of how most integrations look: you define your collaborating components; then you define the configuration using Spring Integration schema that configures the solution itself.</p>
<p class="indent">The configuration starts with the <span class="FontName">inboundHelloJMSMessageChannel</span><a id="cXXX.1146" class="calibre5"></a> channel, which tells Spring Integration what to name the point-to-point connection from the message queue to the <span class="FontName">service-activator</span>. You typically define a new channel for every point-to-point connection.</p>
<p class="indent">Next is a <span class="FontName">jms:message-driven-channel-adapter</span> configuration element that instructs Spring Integration to send messages coming from the message queue destination <span class="FontName">solution011</span> to Spring Integration <span class="FontName">inboundHelloJMSMessageChannel</span>. An <i class="calibre8">adapter</i> is a component that knows how to speak to a specific type of subsystem and translate messages on that subsystem into something that can be used in the Spring Integration bus. Adapters also do the same in reverse, taking messages on the Spring Integration bus and translating them into something a specific subsystem will understand. This is different from a <span class="FontName">service-activator</span> (covered next) in that it’s meant to be a general connection between the bus and the foreign endpoint. A <span class="FontName">service-activator</span><a id="cXXX.1147" class="calibre5"></a>, however, only helps you invoke your application’s business logic on receipt of a message. What you do in the business logic, connecting to another system or not, is up to you.</p>
<p class="indent">The next component, a <span class="FontName">service-activator</span>, listens for messages coming into that channel and invokes the bean referenced by the <span class="FontName">ref</span> attribute, which in this case is the bean defined previously: <span class="FontName">inboundHelloWorldJMSPingServiceActivator</span><a id="cXXX.1148" class="calibre5"></a>.</p>
<p class="indent">As you can see, there’s quite a bit of configuration, but the only custom Java code needed was the <span class="FontName">inboundHelloWorldJMSPingServiceActivator</span>, which is the part of the solution that Spring can’t infer by itself.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.slf4j.Logger;</span><br class="calibre10"/><span class="FontName">import org.slf4j.LoggerFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.ServiceActivator;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.Message;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.Map;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class InboundHelloWorldJMSMessageProcessor {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private final Logger logger = LoggerFactory.getLogger(InboundHelloWorldJMSMessageProcessor.class);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@ServiceActivator</span><br class="calibre10"/>    <span class="FontName">public void handleIncomingJmsMessage(Message&lt;Map&lt;String, Object&gt;&gt;inboundJmsMessage)</span><br class="calibre10"/>            <span class="FontName">throws Throwable {</span><br class="calibre10"/>        <span class="FontName">Map&lt;String, Object&gt; msg = inboundJmsMessage.getPayload();</span><br class="calibre10"/>        <span class="FontName">logger.debug("firstName: {}, lastName: {}, id: {}", msg.get("firstName"),</span><br class="calibre10"/>                                                            <span class="FontName">msg.get("lastName"),</span><br class="calibre10"/>                                                            <span class="FontName">msg.get("id"));</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">// you can imagine what we could do here: put</span><br class="calibre10"/>        <span class="FontName">// the record into the database, call a webservice,</span><br class="calibre10"/>        <span class="FontName">// write it to a file, etc, etc</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Notice that there is an annotation, <span class="FontName">@ServiceActivator</span>, that tells Spring to configure this component, and this method as the recipient of the message payload from the channel, which is passed to the method as <span class="FontName">Message&lt;Map&lt;String, Object&gt;&gt;inboundJmsMessage</span>. In the previous configuration, <span class="FontName">extract-payload="true"</span>, which tells Spring Integration to take the payload of the message from the JMS queue (in this case, a <span class="FontName">Map&lt;String,Object&gt;</span>) and extract it and pass <i class="calibre8">that</i> as the payload of the message that’s being moved through Spring Integration’s channels as a <span class="FontName">org.springframework.messaging.Message&lt;T&gt;</span>. The Spring Integration <span class="FontName">Message</span> is not to be confused with the JMS <span class="FontName">Message</span> interface, although they have some similarities. Had you not specified the <span class="FontName">extract-payload</span> option, the type of payload on the Spring Integration Message interface would have been <span class="FontName">javax.jms.Message</span><a id="cXXX.1149" class="calibre5"></a>. The onus of extracting the payload would have been on you, the developer, but sometimes getting access to that information is useful. Rewritten to handle unwrapping the <span class="FontName">javax.jms.Message</span>, the example would look a little different:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.slf4j.Logger;</span><br class="calibre10"/><span class="FontName">import org.slf4j.LoggerFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.ServiceActivator;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.Message;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.jms.MapMessage;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class InboundHelloWorldJMSMessageProcessor {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private final Logger logger = LoggerFactory.getLogger(InboundHelloWorldJMSMessageProcessor.class);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@ServiceActivator</span><br class="calibre10"/>    <span class="FontName">public void handleIncomingJmsMessageWithPayloadNotExtracted(</span><b class="calibre4">        Message&lt;javax.jms.Message&gt;</b> <span class="FontName">msgWithJmsMessageAsPayload) throws Throwable {</span><br class="calibre10"/>        <span class="FontName">javax.jms.MapMessage jmsMessage = (MapMessage) msgWithJmsMessageAsPayload.getPayload();</span><br class="calibre10"/>        <span class="FontName">logger.debug("firstName: {}, lastName: {}, id: {}", jmsMessage.getString("firstName"),</span><br class="calibre10"/>                                                            <span class="FontName">jmsMessage.getString("lastName"),</span><br class="calibre10"/>                                                            <span class="FontName">jmsMessage.getLong("id"));</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">// you can imagine what we could do here: put</span><br class="calibre10"/>        <span class="FontName">// the record into the database, call a websrvice,</span><br class="calibre10"/>        <span class="FontName">// write it to a file, etc,</span> <span class="FontName">etc</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You could have specified the payload type as the type of the parameter passed into the method. If the payload of the message coming from JMS was of type <span class="FontName">Cat</span>, for example, the method prototype could just as well have been <span class="FontName">public void handleIncomingJmsMessageWithPayloadNotExtracted( Cat inboundJmsMessage) throws Throwable</span>. Spring Integration will figure out the right thing to do. In this case, we prefer access to the Spring Integration <span class="FontName">Message&lt;T&gt;</span>, which has header values that can be useful to interrogate.</p>
<p class="indent">Also note that you don’t need to specify <span class="FontName">throws Throwable</span>. Error handling can be as generic or as specific as you want in Spring Integration.</p>
<p class="indent">In the example, you use the <span class="FontName">@ServiceActivator</span> to invoke the functionality where the integration ends. However, you can forward the response from the activation on to the next channel by returning a value from the method. The type of the return value is what will be used to determine the next message sent in the system. If you return a <span class="FontName">Message&lt;T&gt;</span>, that will be sent directly. If you return something other than <span class="FontName">Message&lt;T&gt;</span>, that value will be wrapped as a payload in a <span class="FontName">Message&lt;T&gt;</span> instance, and that will become the next Message that is ultimately sent to the next component in the processing pipeline. This <span class="FontName">Message&lt;T&gt;</span> will be sent on the output channel that’s configured on the <span class="FontName">service-activator</span>. There is no requirement to send a message on the output channel with the same type as the message that came on in the input channel; this is an effective way to <i class="calibre8">transform</i> the message type. A <span class="FontName">service-activator</span> is a very flexible component in which to put hooks to your system and to help mold the integration.</p>
<p class="indent">This solution is pretty straightforward, and in terms of configuration for one JMS queue, it’s not really a win over straight MDPs because there’s an extra level of indirection to overcome. The Spring Integration facilities make building complex integrations easier than Spring Core or EJB3 could because the configuration is centralized. You have a birds-eye view of the entire integration, with routing and processing centralized, so you can better reposition the components in your integration. However, as you’ll see, Spring Integration wasn’t meant to compete with EJB<a id="cXXX.1150" class="calibre5"></a> and Spring Core; it shines at solutions that couldn’t naturally be built using EJB3 or Spring Core.</p>
<p id="Sec12" class="Heading">16-3. Interrogating Spring Integration Messages for Context Information</p>
<p id="Sec13" class="Heading1">Problem</p>
<p class="noindent">You want more information about the message coming into the Spring Integration processing pipeline than the type of the message implicitly can give you.</p>
<p id="Sec14" class="Heading1">Solution</p>
<p class="noindent">Interrogate the Spring Integration <span class="FontName">Message&lt;T&gt;</span> for header information specific to the message. These values are enumerated as header values in a map (of type <span class="FontName">Map&lt;String,Object&gt;</span>).</p>
<p id="Sec15" class="Heading1">How It Works</p>
<p id="Sec16" class="Heading2">Using MessageHeaders for Fun and Profit</p>
<p class="noindent">The Spring Integration <span class="FontName">Message&lt;T&gt;</span> interface is a generic wrapper that contains a pointer to the actual payload of the message as well as to headers that provide contextual message metadata. You can manipulate or augment this metadata to enable/enhance the functionality of components that are downstream, too; for example, when sending a message through e-mail it’s useful to specify the <span class="FontName">TO</span>/<span class="FontName">FROM</span> headers.</p>
<p class="indent">Any time you expose a class to the framework to handle some requirement (such as the logic you provide for the <span class="FontName">service-activator</span><a id="cXXX.1151" class="calibre5"></a> component or a transformer component), there will be some chance to interact with the <span class="FontName">Message&lt;T&gt;</span> and with the message headers. Remember that Spring Integration pushes a <span class="FontName">Message&lt;T&gt;</span> through a processing pipeline. Each component that interfaces with the <span class="FontName">Message&lt;T&gt;</span> instance has to act on it, do something with it, or forward it on. One way of providing information to those components, and of getting information about what’s happened in the components up until that point, is to interrogate the <span class="FontName">MessageHeaders</span>.</p>
<p class="indent">There are several values that you should be aware of when working with Spring Integration (see <a id="_Tab1" href="part0026.html#Tab1" class="calibre5"><i class="calibre8">Tables 16-1</i></a> and <a id="_Tab2" href="part0026.html#Tab2" class="calibre5"><i class="calibre8">16-2</i></a>). These constants are exposed on the <span class="FontName">org.springframework.messaging.MessageHeaders</span> interface and <span class="FontName">org.springframework.integration. IntegrationMessageHeaderAccessor</span> .</p>
<div class="Table" id="Tab1">
<p class="TabCapt"><span class="calibre4"><a href="part0026.html#_Tab1" class="calibre5">Table 16-1</a>.</span> Common Headers Found in core Spring Messaging</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">Constant</p></th><th valign="top" class="calibre14">
<p class="tab-left">Description</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">ID</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">This is a unique value assigned to the message by the Spring Integration engine.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">TIMESTAMP</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">Timestamp assigned to the message.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">REPLY_CHANNEL</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The <span class="FontName">String</span> name of the channel to which the output of the current component should be sent. This can be overridden.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">ERROR_CHANNEL</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The <span class="FontName">String</span> name of the channel to which the output of the current component should be sent if an exception bubbles up into the runtime. This can be overridden.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">CONTENT_TYPE</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The content type (mimetype) of the message, mainly used for web sockets messages.</p></td></tr></tbody></table>
</div>
<div class="Table" id="Tab2">
<p class="TabCapt"><span class="calibre4"><a href="part0026.html#_Tab2" class="calibre5">Table 16-2</a>.</span> Common Headers Found in Spring Integration</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">Constant</p></th><th valign="top" class="calibre14">
<p class="tab-left">Description</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">CORRELATION_ID</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">This is optional. It is used by some components (such as aggregators) to group messages together in some sort of processing pipeline.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">EXPIRATION_DATE</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">Used by some components as a threshold for processing after which a component can wait no longer in processing.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">PRIORITY</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The priority of the message, higher numbers indicate a higher priority.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">SEQUENCE_NUMBER</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The order in which the message is to be sequenced; typically used with a sequencer.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">SEQUENCE_SIZE</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The size of the sequence so that an aggregator can know when to stop waiting for more messages and move forward. This is useful in implementing “join” functionality.</p></td></tr></tbody></table>
</div>
<p class="indent">Next to the headers defined by Spring Messaging there are also some commonly used headers in Spring Integration, these are defined in the <span class="FontName">org.springframework.integration.</span><span class="FontName">IntegrationMessageHeaderAccessor</span><a id="cXXX.1152" class="calibre5"></a> class (see <a href="part0026.html#Tab2" class="calibre5"><i class="calibre8">Table 16-2</i></a>).</p>
<p class="indent">Some header values are specific to the type of the source message’s payload; for example, payloads sourced from a file on the file system are different from those coming in from a JMS queue, which are different from messages coming from an e-mail system. These different components are typically packaged in their own JARs, and there’s usually some class that provides constants for accessing these headers. An example of component-specific headers are the constants defined for files on <span class="FontName">org.springframework.integration.file.FileHeaders</span>: <span class="FontName">FILENAME</span> and <span class="FontName">PREFIX</span>. Naturally, when in doubt, you can just enumerate the values manually because the headers are just a <span class="FontName">java.util.Map</span> instance.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.slf4j.Logger;</span><br class="calibre10"/><span class="FontName">import org.slf4j.LoggerFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.ServiceActivator;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.Message;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.MessageHeaders;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.io.File;</span><br class="calibre10"/><span class="FontName">import java.util.Map;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class InboundFileMessageServiceActivator {</span><br class="calibre10"/>    <span class="FontName">private final Logger logger = LoggerFactory.getLogger(InboundFileMessageServiceActivator.class);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@ServiceActivator</span><br class="calibre10"/>    <span class="FontName">public void interrogateMessage(Message&lt;File&gt; message) {</span><br class="calibre10"/>        <span class="FontName">MessageHeaders headers = message.getHeaders();</span><br class="calibre10"/>        <span class="FontName">for (Map.Entry&lt;String, Object&gt; header : headers.entrySet()) {</span><br class="calibre10"/>            <span class="FontName">logger.debug("{} : {}", header.getKey(), header.getValue() );</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">These headers let you interrogate the specific features of these messages without surfacing them as a concrete interface dependency if you don’t want them. They can also be used to help processing and allow you to specify custom metadata to downstream components. The act of providing extra data for the benefit of a downstream component is called <i class="calibre8">message enrichment</i><a id="cXXX.1153" class="calibre5"></a>. Message enrichment is when you take the headers of a given <span class="FontName">Message</span> and add to them, usually to the benefit of components in the processing pipeline downstream. You might imagine processing a message to add a customer to a customer relationship management (CRM<a id="cXXX.1154" class="calibre5"></a>) system that makes a call to a third-party web site to establish credit ratings. This credit is added to the headers so the component downstream is tasked with either adding the customer or rejecting it can make its decisions.</p>
<p class="indent">Another way to get access to header metadata is to simply have it passed<a id="cXXX.1155" class="calibre5"></a> as parameters to your component’s method. You simply annotate the parameter with the <span class="FontName">@Header</span> annotation, and Spring Integration will take care of the rest.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.slf4j.Logger;</span><br class="calibre10"/><span class="FontName">import org.slf4j.LoggerFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.Header;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.ServiceActivator;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.file.FileHeaders;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.MessageHeaders;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.io.File;</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class InboundFileMessageServiceActivator {</span><br class="calibre10"/>    <span class="FontName">private final Logger logger = LoggerFactory.getLogger(InboundFileMessageServiceActivator.class);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@ServiceActivator</span><br class="calibre10"/>    <span class="FontName">public void interrogateMessage(</span><br class="calibre10"/>            <span class="FontName">@Header(MessageHeaders.ID) String uuid,</span><br class="calibre10"/>            <span class="FontName">@Header(FileHeaders.FILENAME) String fileName, File file) {</span><br class="calibre10"/>        <span class="FontName">logger.debug("the id of the message is {}, and name of the file payload is {}", uuid, fileName);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You can also have Spring Integration simply pass the <span class="FontName">Map&lt;String,Object&gt;</span>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.slf4j.Logger;</span><br class="calibre10"/><span class="FontName">import org.slf4j.LoggerFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.Header;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.ServiceActivator;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.file.FileHeaders;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.MessageHeaders;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.io.File;</span><br class="calibre10"/><span class="FontName">import java.util.Map;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class InboundFileMessageServiceActivator {</span><br class="calibre10"/>    <span class="FontName">private final Logger logger = LoggerFactory.getLogger(InboundFileMessageServiceActivator.class);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@ServiceActivator</span><br class="calibre10"/>    <span class="FontName">public void interrogateMessage(</span><br class="calibre10"/>            <b class="calibre4">@Header(MessageHeaders.ID) Map&lt;String, Object&gt; headers</b><span class="FontName">, File file) {</span><br class="calibre10"/>        <span class="FontName">logger.debug("the id of the message is {}, and name of the file payload is {}",</span><br class="calibre10"/>                <span class="FontName">headers.get(MessageHeaders.ID), headers.get(FileHeaders.FILENAME));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec17" class="Heading">16-4. Integrating Two Systems Using a File System</p>
<p id="Sec18" class="Heading1">Problem</p>
<p class="noindent">You want to build a solution that takes files on a well-known, shared file system and uses them as the conduit for integration with another system. An example might be that your application produces a comma-separated value (CSV) dump of all the customers added to a system every hour. The company’s third-party financial system is updated with these sales by a process that checks a shared folder, mounted over a network file system, and processes the CSV records. What’s required is a way to treat the presence of a new file as an event on the bus.</p>
<p id="Sec19" class="Heading1">Solution</p>
<p class="noindent">You have an idea of how this could be built by using standard techniques, but you want something more elegant. Let Spring Integration isolate you from the event-driven nature of the file system and from the file input/output requirements and instead let’s use it to focus on writing the code that deals with the <span class="FontName">java.io.File</span> payload itself. With this approach, you can write unit-testable code that accepts an input and responds by adding the customers to the financial system. When the functionality is finished, you configure it in the Spring Integration pipeline and let Spring Integration invoke your functionality whenever a new file is recognized on the file system. This is an example of an event-driven architecture (EDA). EDAs<a id="cXXX.1156" class="calibre5"></a> let you ignore how an event was generated and focus instead on reacting to them, in much the same way that event-driven GUIs let you change the focus of your code from controlling how a user triggers an action to actually reacting to the invocation itself. Spring Integration makes it a natural approach for loosely coupled solutions. In fact, this code should look very similar to the solution you built for the JMS queue because it’s just another class that takes a parameter (a Spring Integration <span class="FontName">Message&lt;T&gt;</span>, and a parameter of the same type as the payload of the message, and so on).</p>
<p id="Sec20" class="Heading1">How It Works</p>
<p id="Sec21" class="Heading2">Concerns in Dealing with a File System</p>
<p class="noindent">Building a solution to talk to JMS is old hat. Instead, let’s consider what building a solution using a shared file system might look like. Imagine how to build it without an ESB solution. You need some mechanism by which to poll the file system periodically and detect new files. Perhaps Quartz and some sort of cache? You need something to read in these files quickly and then pass the payload to your processing logic efficiently. Finally, your system needs to work with that payload.</p>
<p class="indent">Spring Integration frees you from all that infrastructure code; all you need to do is configure it. There are some issues with dealing with file-system–based processing<a id="cXXX.1157" class="calibre5"></a>, however, that are up to you to resolve. Behind the scenes, Spring Integration is still dealing with polling the file system and detecting new files. It can’t possibly have a semantically correct idea for your application of when a file is “completely” written, and thus providing a way around that is up to you.</p>
<p class="indent">Several approaches exist. You might write out a file and then write another zero-byte file. The presence of that file would mean it’s safe to assume that the real payload is present. Configure Spring Integration to look for that file. If it finds it, it knows that there’s another file (perhaps with the same name and a different file extension?) and that it can start reading it/working with it. Another solution along the same line is to have the client (“producer”) write the file to the directory using a name that the glob pattern Spring Integration is using to poll the directory won’t detect. Then, when it’s finished writing, issue an <span class="FontName">mv</span> command if you trust your file system to do the right thing there.</p>
<p class="indent">Let’s revisit the first solution, but this time with a file-based adapter. The configuration looks conceptually the same as before, except the configuration for the adapter has changed, and with that has gone a lot of the configuration for the JMS adapter, like the connection factory. Instead, you tell Spring Integration about a different source from whence messages will come: the file system.</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:beans xmlns:beans="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>            <span class="FontName"> xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration" class="calibre5">http://www.springframework.org/schema/integration</a></span><span class="FontName">"</span><br class="calibre10"/>              <span class="FontName">xmlns:context="</span><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xmlns:file="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration/file" class="calibre5">http://www.springframework.org/schema/integration/file</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans.xsd</a></span> <span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/context/spring-context.xsd" class="calibre5">http://www.springframework.org/schema/context/spring-context.xsd</a></span> <span class="FontName"><a href="http://www.springframework.org/schema/integration" class="calibre5">http://www.springframework.org/schema/integration</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/spring-integration.xsd" class="calibre5">http://www.springframework.org/schema/integration/spring-integration.xsd</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/file" class="calibre5">http://www.springframework.org/schema/integration/file</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/file/spring-integration-file.xsd" class="calibre5">http://www.springframework.org/schema/integration/file/spring-integration-file.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>  <span class="FontName">&lt;context:annotation-config/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="inboundHelloWorldFileMessageProcessor"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.springintegration.InboundHelloWorldFileMessageProcessor"/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;channel id="inboundFileChannel"/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">&lt;file:inbound-channel-adapter directory="${user.home}/inboundFiles/new/"</b><br class="calibre10"/>                  <b class="calibre4">channel="inboundFileChannel"</b><br class="calibre10"/>                  <b class="calibre4">filename-pattern="^new.*csv"&gt;</b><br class="calibre10"/>                  <b class="calibre4">&lt;poller default="true" fixed-rate="10" time-unit="SECONDS" /&gt;</b><br class="calibre10"/>    <b class="calibre4">&lt;/file:inbound-channel-adapter&gt;</b><br class="calibre10"/>    <b class="calibre4">&lt;service-activator input-channel="inboundFileChannel"</b><span class="FontName"><img src="../images/00053.jpeg" alt="image" class="calibre3"/></span><br class="calibre10"/><span class="FontName">ref="inboundHelloWorldFileMessageProcessor"/&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;/beans:beans&gt;</span></pre>
<p class="indent">This is nothing you haven’t already seen, really. The code for <span class="FontName">file:</span><span class="FontName">inbound-channel-adapter</span><a id="cXXX.1158" class="calibre5"></a> is the only new element, and it comes with its own schema, which is in the prologue for the XML itself.</p>
<p class="indent">The code for the <span class="FontName">service-activator</span> has changed to reflect the fact that you’re expecting a message containing a message of type <span class="FontName">Message&lt;java.io.File&gt;</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.slf4j.Logger;</span><br class="calibre10"/><span class="FontName">import org.slf4j.LoggerFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.ServiceActivator;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.Message;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.io.File;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class InboundHelloWorldFileMessageProcessor {</span><br class="calibre10"/>    <span class="FontName">private final Logger logger = LoggerFactory.getLogger(InboundHelloWorldFileMessageProcessor.class);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@ServiceActivator</span><br class="calibre10"/>    <span class="FontName">public void handleIncomingFileMessage(Message&lt;File&gt; inboundJmsMessage)</span><br class="calibre10"/>        <span class="FontName">throws Throwable {</span><br class="calibre10"/>        <span class="FontName">File filePayload = inboundJmsMessage.getPayload();</span><br class="calibre10"/>        <span class="FontName">logger.debug("absolute path: {}, size: {}", filePayload.getAbsolutePath(), filePayload.length());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec22" class="Heading">16-5. Transforming a Message from One Type to Another</p>
<p id="Sec23" class="Heading1">Problem</p>
<p class="noindent">You want to send a message into the bus and transform it before working with it further. Usually, this is done to adapt the message to the requirements of a component downstream. You might also want to transform a message by enriching it—adding extra headers or augmenting the payload so that components downstream in the processing pipeline can benefit from it.</p>
<p id="Sec24" class="Heading1">Solution</p>
<p class="noindent">Use a <span class="FontName">transformer</span> component to take a <span class="FontName">Message&lt;T&gt;</span> of a payload and send the <span class="FontName">Message&lt;T&gt;</span> out with a payload of a different type. You can also use the transformer to add extra headers or update the values of headers for the benefit of components downstream in the processing pipeline.</p>
<p id="Sec25" class="Heading1">How It Works</p>
<p class="noindent">Spring Integration provides a <span class="FontName">transformer</span> message endpoint to permit the augmentation of the message headers or the transformation of the message itself. In Spring Integration, components are chained together, and output from one component is returned by way of the method invoked for that component. The return value of the method is passed out on the “reply channel” for the component to the next component, which receives it as an input parameter.</p>
<p class="indent">A <span class="FontName">transformer</span> component<a id="cXXX.1159" class="calibre5"></a> lets you change the type of the object being returned or add extra headers and that updated object is what is passed to the next component in the chain.</p>
<p id="Sec26" class="Heading2">Modifying a Message’s Payload</p>
<p class="noindent">The configuration of a transformer component is very much in keeping with everything you’ve seen so far:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.Transformer;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.Message;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.Map;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class InboundJMSMessageToCustomerTransformer {</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Transformer</b><br class="calibre10"/>    <span class="FontName">public Customer transformJMSMapToCustomer(        Message&lt;Map&lt;String, Object&gt;&gt;inboundSprignIntegrationMessage) {</span><br class="calibre10"/>        <span class="FontName">Map&lt;String, Object&gt; jmsMessagePayload = inboundSprignIntegrationMessage.getPayload();</span><br class="calibre10"/>        <span class="FontName">Customer customer = new Customer();</span><br class="calibre10"/>        <span class="FontName">customer.setFirstName((String) jmsMessagePayload.get("firstName"));</span><br class="calibre10"/>        <span class="FontName">customer.setLastName((String) jmsMessagePayload.get("lastName"));</span><br class="calibre10"/>        <span class="FontName">customer.setId((Long) jmsMessagePayload.get("id"));</span><br class="calibre10"/>        <span class="FontName">return customer;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Nothing terribly complex is happening here: a <span class="FontName">Message&lt;T&gt;</span> of type <span class="FontName">Map&lt;String,Object&gt;</span> is passed in. The values are manually extracted and used to build an object of type <span class="FontName">Customer</span>. The <span class="FontName">Customer</span> object<a id="cXXX.1160" class="calibre5"></a> is returned, which has the effect of passing it out on the reply channel for this component. The next component in the configuration will receive this object as its input <span class="FontName">Message&lt;T&gt;</span>.</p>
<p class="indent">The solution is mostly the same as you’ve seen, but there is a new <span class="FontName">transformer</span> element:</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:beans xmlns:beans="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/> <span class="FontName">...</span><br class="calibre10"/><span class="FontName">&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;context:annotation-config/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="connectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:property name="targetConnectionFactory"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;beans:bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;beans:property name="brokerURL" value="tcp://localhost:61616"/&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/beans:bean&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/beans:property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:property name="sessionCacheSize" value="10"/&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:property name="cacheProducers" value="false"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/beans:bean&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:property name="connectionFactory" ref="connectionFactory"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/beans:bean&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:bean id="inboundJMSMessageToCustomerTransformer"             class="com.apress.springrecipes.springintegration.InboundJMSMessageToCustomerTransformer"/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="inboundCustomerServiceActivator"<img src="../images/00053.jpeg" alt="image" class="calibre3"/></span><br class="calibre10"/><span class="FontName">class="com.apress.springrecipes.springintegration.InboundCustomerServiceActivator"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;channel id="inboundHelloJMSMessageChannel"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;channel id="inboundCustomerChannel"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;jms:message-driven-channel-adapter channel="inboundHelloJMSMessageChannel"</span><br class="calibre10"/><span class="FontName">extract-payload="true"  connection-factory="connectionFactory" destination-name="solution015"/&gt;</span><br class="calibre10"/><b class="calibre4">&lt;transformer input-channel="inboundHelloJMSMessageChannel"</b><br class="calibre10"/><b class="calibre4">ref="inboundJMSMessageToCustomerTransformer"</b><br class="calibre10"/><b class="calibre4">output-channel="inboundCustomerChannel"/&gt;</b><br class="calibre10"/>    <span class="FontName">&lt;service-activator input-channel="inboundCustomerChannel" ref="inboundCustomerServiceActivator" /&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;/beans:beans&gt;</span></pre>
<p class="indent">Here, you’re also specifying an <span class="FontName">output-channel</span> attribute<a id="cXXX.1161" class="calibre5"></a> on the component, which tells a component on what channel to send the component’s response output, in this case, the <span class="FontName">Customer</span>.</p>
<p class="indent">The code in the next component can now declare a dependency on the <span class="FontName">Customer</span> interface with impunity. You can, with transformers, receive messages from any number of sources and transform into a <span class="FontName">Customer</span> so that you can reuse the <span class="FontName">InboundCustomerServiceActivator</span>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.slf4j.Logger;</span><br class="calibre10"/><span class="FontName">import org.slf4j.LoggerFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.ServiceActivator;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.Message;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class InboundCustomerServiceActivator {</span><br class="calibre10"/>    <span class="FontName">private static final Logger logger = LoggerFactory.getLogger(InboundCustomerServiceActivator.class);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@ServiceActivator</span><br class="calibre10"/>    <span class="FontName">public void doSomethingWithCustomer(Message&lt;Customer&gt; customerMessage) {</span><br class="calibre10"/>        <span class="FontName">Customer customer = customerMessage.getPayload();</span><br class="calibre10"/>        <span class="FontName">logger.debug("id={}, firstName: {}, lastName: {}",             customer.getId(), customer.getFirstName(), customer.getLastName());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec27" class="Heading2">Modifying a Message’s Headers</p>
<p class="noindent">Sometimes changing a message’s payload isn’t enough. Sometimes you want to update the payload as well as the headers. Doing this is slightly more interesting because it involves using the <span class="FontName">MessageBuilder&lt;T&gt;</span> class<a id="cXXX.1162" class="calibre5"></a>, which allows you to create new <span class="FontName">Message&lt;T&gt;</span> objects with any specified payload and any specified header data. The XML configuration is identical in this case.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.Transformer;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.core.Message;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.message.MessageBuilder;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.Map;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class InboundJMSMessageToCustomerTransformer {</span><br class="calibre10"/>    <b class="calibre4">@Transformer</b><br class="calibre10"/>    <span class="FontName">public Message&lt;Customer&gt; transformJMSMapToCustomer(</span><br class="calibre10"/>        <span class="FontName">Message&lt;Map&lt;String, Object&gt;&gt;inboundSpringIntegrationMessage) {</span><br class="calibre10"/>        <span class="FontName">Map&lt;String, Object&gt; jmsMessagePayload =</span><br class="calibre10"/>               <span class="FontName">inboundSpringIntegrationMessage.getPayload();</span><br class="calibre10"/>        <span class="FontName">Customer customer = new Customer();</span><br class="calibre10"/>        <span class="FontName">customer.setFirstName((String) jmsMessagePayload.get("firstName"));</span><br class="calibre10"/>        <span class="FontName">customer.setLastName((String) jmsMessagePayload.get("lastName"));</span><br class="calibre10"/>        <span class="FontName">customer.setId((Long) jmsMessagePayload.get("id"));</span><br class="calibre10"/>        <b class="calibre4">return MessageBuilder.withPayload(customer)</b><br class="calibre10"/>        <b class="calibre4">.copyHeadersIfAbsent( inboundSpringIntegrationMessage.getHeaders())</b><br class="calibre10"/>        <b class="calibre4">.setHeaderIfAbsent("randomlySelectedForSurvey", Math.random() &gt; .5)</b><br class="calibre10"/>        <b class="calibre4">.build();</b><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">As before, this code is simply a method with an input and an output. The output is constructed dynamically using <span class="FontName">MessageBuilder&lt;T&gt;</span> to create a message that has the same payload as the input message as well as copy the existing headers and adds an extra header: <span class="FontName">randomlySelectedForSurvey</span>.</p>
<p id="Sec28" class="Heading">16-6. Error Handling Using Spring Integration</p>
<p id="Sec29" class="Heading1">Problem</p>
<p class="noindent">Spring Integration brings together systems distributed across different nodes; computers; and services, protocol, and language stacks. Indeed, a Spring Integration solution might not even finish in remotely the same time period as when it started. Exception handling, then, can never be as simple as a language-level try/catch block in a single thread for any component with asynchronous behavior. This implies that many of the kinds of solutions you’re likely to build, with channels and queues of any kind, need a way of signaling an error that is distributed and natural to the component that created the error. Thus, an error might get sent over a JMS queue on a different continent, or in process, on a queue in a different thread.</p>
<p id="Sec30" class="Heading1">Solution</p>
<p class="noindent">Use Spring Integration’s support for an error channel, both implicit and explicitly via code.</p>
<p id="Sec31" class="Heading1">How It Works</p>
<p class="noindent">Spring Integration provides the ability to catch exceptions and send them to an error channel of your choosing. By default, it’s a global channel called <span class="FontName">errorChannel</span>. By default Spring Integration registers a <span class="FontName">LoggingHandler</span><a id="cXXX.1163" class="calibre5"></a> to this channel, which does nothing more than log the exception and stacktrace. To make this work we have to tell the message-driven-channel-adapter that we want the error to be sent to the <span class="FontName">errorChannel</span>, we can do this by configuring the <span class="FontName">error-channel</span> attribute<a id="cXXX.1164" class="calibre5"></a>.</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:beans xmlns:beans="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/> <span class="FontName">...</span><br class="calibre10"/><span class="FontName">&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;context:annotation-config/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;jms:message-driven-channel-adapter channel="inboundHelloJMSMessageChannel"</span><br class="calibre10"/>                                        <span class="FontName">extract-payload="true" connection-factory="connectionFactory"</span><br class="calibre10"/>                                        <span class="FontName">destination-name="solution015"</span> <b class="calibre4">error-channel="errorChannel"</b> <span class="FontName">/&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;/beans:beans&gt;</span></pre>
<p id="Sec32" class="Heading2">Custom Handler to handle Exception</p>
<p class="noindent">Of course you can also have components subscribe to messages from this channel to override the exception handling behavior. You can create a class that will be invoked whenever a message comes in on the <span class="FontName">errorChannel</span> channel:</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:beans xmlns:beans="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/> <span class="FontName">...</span><br class="calibre10"/><span class="FontName">&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;context:annotation-config/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="defaultErrorHandlingServiceActivator"<img src="../images/00053.jpeg" alt="image" class="calibre3"/></span><br class="calibre10"/> <span class="FontName">class="com.apress.springrecipes.springintegration.DefaultErrorHandlingServiceActivator"/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;service-activator input-channel="errorChannel" ref="defaultErrorHandlingServiceActivator"/&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;/beans:beans&gt;</span></pre>
<p class="indent">The Java code is exactly as you’d expect it to be. Of course, the component that receives the error message from the <span class="FontName">errorChannel</span> doesn’t need to be a <span class="FontName">service-activator</span>. We just use it for convenience here. The code for the following <span class="FontName">service-activator</span> depicts some of the machinations you might go through to build a handler for the <span class="FontName">errorChannel</span>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.slf4j.Logger;</span><br class="calibre10"/><span class="FontName">import org.slf4j.LoggerFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.ServiceActivator;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.Message;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.MessagingException;</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class DefaultErrorHandlingServiceActivator {</span><br class="calibre10"/>    <span class="FontName">private static final Logger logger = LoggerFactory.getLogger(DefaultErrorHandlingServiceActivator.class);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@ServiceActivator</span><br class="calibre10"/>    <span class="FontName">public void handleThrowable(Message&lt;Throwable&gt; errorMessage)</span><br class="calibre10"/>        <span class="FontName">throws Throwable {</span><br class="calibre10"/>        <span class="FontName">Throwable throwable = errorMessage.getPayload();</span><br class="calibre10"/>        <span class="FontName">logger.debug("Message: {}", throwable.getMessage(), throwable);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">if (throwable instanceof MessagingException) {</span><br class="calibre10"/>            <span class="FontName">Message&lt;?&gt; failedMessage = ((MessagingException) throwable).getFailedMessage();</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">if (failedMessage != null) {</span><br class="calibre10"/>                <span class="FontName">// do something with the original message</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">} else {</span><br class="calibre10"/>            <span class="FontName">// it's something that was thrown in the execution of code in some component you created</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">All errors thrown from Spring Integration components will be a subclass of <span class="FontName">MessagingException</span>. <span class="FontName">MessagingException</span><a id="cXXX.1165" class="calibre5"></a> carries a pointer to the original <span class="FontName">Message</span> that caused an error, which you can dissect for more context information. In the example, you’re doing a nasty <span class="FontName">instanceof</span>. Clearly, being able to delegate to custom exception handlers based on the type of exception would be useful.</p>
<p id="Sec33" class="Heading2">Routing to Custom Handlers Based on the Type of Exception</p>
<p class="noindent">Sometimes, more specific error handling is required. One way to discriminate by <span class="FontName">Exception</span> type is to use the <span class="FontName">org.springframework.integration.router.ErrorMessageExceptionTypeRouter</span> class. In the following code, this router is configured as an <span class="FontName">exception-type-router</span><a id="cXXX.1166" class="calibre5"></a>, which in turn listens to <span class="FontName">errorChannel</span>. It then splinters off, using the type of the exception as the predicate in determining which channel should get the results.</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:beans xmlns:beans="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/> <span class="FontName">...</span><br class="calibre10"/><span class="FontName">&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;context:annotation-config/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;channel id="customErrorChannelForMyCustomException"/&gt;</span><br class="calibre10"/>    <b class="calibre4">&lt;exception-type-router input-channel="errorChannel"&gt;</b><br class="calibre10"/>        <b class="calibre4">&lt;mapping exception-type="com.apress.springrecipes.springintegration.MyCustomException"</b><br class="calibre10"/>                         <b class="calibre4">channel="customErrorChannelForMyCustomException"/&gt;</b><br class="calibre10"/>    <b class="calibre4">&lt;/exception-type-router&gt;</b><br class="calibre10"/> <span class="FontName">&lt;/beans:beans&gt;</span></pre>
<p id="Sec34" class="Heading2">Building a Solution with Multiple Error Channels</p>
<p class="noindent">The preceding example might work fine for simple cases, but often different integrations require different error-handling approaches, which implies that sending all the errors to the same channel can eventually lead to a large <span class="FontName">switch</span>-laden class<a id="cXXX.1167" class="calibre5"></a> that’s too complex to maintain. Instead, it’s better to selectively route error messages to the error channel most appropriate to each integration. This avoids centralizing all error handling. One way to do that is to explicitly specify on what channel errors for a given integration should go. The following example shows a component (<span class="FontName">service-activator</span>) that upon receiving a message, adds a header indicating the name of the error channel. Spring Integration will use that header and forward errors encountered in the processing of this message to that channel.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.apache.log4j.Logger;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.ServiceActivator;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.core.Message;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.core.MessageHeaders;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.message.MessageBuilder;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class ServiceActivatorThatSpecifiesErrorChannel {</span><br class="calibre10"/>    <span class="FontName">private static final Logger logger = Logger.getLogger(</span><br class="calibre10"/>        <span class="FontName">ServiceActivatorThatSpecifiesErrorChannel.class);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@ServiceActivator</span><br class="calibre10"/>    <span class="FontName">public Message&lt;?&gt; startIntegrationFlow(Message&lt;?&gt; firstMessage)</span><br class="calibre10"/>        <span class="FontName">throws Throwable {</span><br class="calibre10"/>        <span class="FontName">return MessageBuilder.fromMessage(firstMessage).</span><br class="calibre10"/>        <b class="calibre4">setHeaderIfAbsent( MessageHeaders.ERROR_CHANNEL,</b><br class="calibre10"/>        <b class="calibre4">"errorChannelForMySolution").build();</b><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Thus, all errors that come from the integration in which this component is used will be directed to <span class="FontName">customErrorChannel</span><a id="cXXX.1168" class="calibre5"></a>, to which you can subscribe any component you like.</p>
<p id="Sec35" class="Heading">16-7. Forking Integration Control: Splitters and Aggregators</p>
<p id="Sec36" class="Heading1">Problem</p>
<p class="noindent">You want to fork the process flow from one component to many, either all at once or to a single one based on a predicate condition.</p>
<p id="Sec37" class="Heading1">Solution</p>
<p class="noindent">You can use a <span class="FontName">splitter</span> component<a id="cXXX.1169" class="calibre5"></a> (and maybe its cohort, the <span class="FontName">aggregator</span> component) to fork and join (respectively) control of processing.</p>
<p id="Sec38" class="Heading1">How It Works</p>
<p class="noindent">One of the fundamental cornerstones of an ESB is routing. You’ve seen how components can be chained together to create sequences in which progression is mostly linear. Some solutions require the capability to split a message into many constituent parts. One reason this might be is that some problems are parallel in nature and don’t depend on each other in order to complete. You should strive to achieve the efficiencies of parallelism wherever possible.</p>
<p id="Sec39" class="Heading2">Using a Splitter</p>
<p class="noindent">It’s often useful to divide large payloads into separate messages with separate processing flows. In Spring Integration, this is accomplished by using a <span class="FontName">splitter</span> component. A <span class="FontName">splitter</span> takes an input message and asks you, the user of the component, on what basis it should split the <span class="FontName">Message&lt;T&gt;</span>: you’re responsible for providing the split functionality. Once you’ve told Spring Integration how to split a <span class="FontName">Message&lt;T&gt;</span>, it forwards each result out on the <span class="FontName">output-channel</span> of the <span class="FontName">splitter</span> component. In a few cases, Spring Integration ships with useful splitters that require no customization. One example is the splitter provided to partition an XML payload along an XPath query, <span class="FontName">XPathMessageSplitter</span><a id="cXXX.1170" class="calibre5"></a>.</p>
<p class="indent">One example of a useful application of a splitter might be a text file with rows of data, each of which must be processed. Your goal is to be able to submit each row to a service that will handle the processing. What’s required is a way to extract each row and forward each row as a new <span class="FontName">Message&lt;T&gt;</span>.</p>
<p class="indent">The configuration for such a solution looks like this:</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:beans xmlns:beans="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>            <span class="FontName"> xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration" class="calibre5">http://www.springframework.org/schema/integration</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xmlns:context="</span><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xmlns:jms="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration/jms" class="calibre5">http://www.springframework.org/schema/integration/jms</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xmlns:file="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration/file" class="calibre5">http://www.springframework.org/schema/integration/file</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans.xsd</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/context/spring-context.xsd" class="calibre5">http://www.springframework.org/schema/context/spring-context.xsd</a></span> <span class="FontName"><a href="http://www.springframework.org/schema/integration" class="calibre5">http://www.springframework.org/schema/integration</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/spring-integration.xsd" class="calibre5">http://www.springframework.org/schema/integration/spring-integration.xsd</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/file" class="calibre5">http://www.springframework.org/schema/integration/file</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/file/spring-integration-file.xsd" class="calibre5">http://www.springframework.org/schema/integration/file/spring-integration-file.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;context:annotation-config/&gt;</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">&lt;poller id="poller" default="true"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;interval-trigger interval="1000"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/poller&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="fileSplitter"</span><br class="calibre10"/>                <span class="FontName">class="com.apress.springrecipes.springintegration.CustomerBatchFileSplitter"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="customerDeletionServiceActivator"</span><br class="calibre10"/>           <span class="FontName">class="com.apress.springrecipes.springintegration.CustomerDeletionServiceActivator"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;channel id="customerBatchChannel"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;channel id="customerIdChannel"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;file:inbound-channel-adapter</span><br class="calibre10"/>        <span class="FontName">directory="file:${user.home}/customerstoremove/new/"</span><br class="calibre10"/>        <span class="FontName">channel="customerBatchChannel"  filename-pattern="customerstoremove-*.txt"/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">&lt;splitter input-channel="customerBatchChannel"</b><br class="calibre10"/>              <b class="calibre4">ref="fileSplitter" output-channel="customerIdChannel" /&gt;</b><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;service-activator input-channel="customerIdChannel"</span><br class="calibre10"/>                       <span class="FontName">ref="customerDeletionServiceActivator"/&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;/beans:beans&gt;</span></pre>
<p class="indent">The configuration for this is not terribly different from the previous solutions. The Java code is just about the same as well, except that the return type of the method annotated by the <span class="FontName">@Splitter</span> annotation is of type <span class="FontName">java.util.Collection</span><a id="cXXX.1171" class="calibre5"></a>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.apache.commons.io.IOUtils;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.Splitter;</span><br class="calibre10"/><span class="FontName">import java.io.File;</span><br class="calibre10"/><span class="FontName">import java.io.FileReader;</span><br class="calibre10"/><span class="FontName">import java.io.Reader;</span><br class="calibre10"/><span class="FontName">import java.util.Collection;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class CustomerBatchFileSplitter {</span><br class="calibre10"/>    <span class="FontName">@Splitter</span><br class="calibre10"/>    <b class="calibre4">public Collection&lt;String&gt; splitAFile(File file) throws Throwable {</b><br class="calibre10"/>        <span class="FontName">Reader reader = new FileReader(file);</span><br class="calibre10"/>        <span class="FontName">Collection&lt;String&gt; lines = IOUtils.readLines(reader);</span><br class="calibre10"/>        <span class="FontName">IOUtils.closeQuietly(reader);</span><br class="calibre10"/>        <span class="FontName">return lines;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">A message payload is passed in as a <span class="FontName">java.io.File</span> and the contents are read. The result (a collection or array value; in this case, a <span class="FontName">Collection&lt;String&gt;</span>) is returned. Spring Integration executes a kind of for each on the results, sending each value in the collection out on the <span class="FontName">output-channel</span> configured for the splitter. Often, you split messages so that the individual pieces can be forwarded to processing that’s more focused. Because the message is more manageable, the processing requirements are dampened. This is true in many different architectures: in map/reduce solutions tasks are split and then processed in parallel, and the fork/join constructs in a BPM system let control flow proceed in parallel so that the total work product can be achieved quicker.</p>
<p id="Sec40" class="Heading2">Using Aggregators</p>
<p class="noindent">At some point you’ll need to do the reverse: combine many messages into one, and create a single result that can be returned on the <span class="FontName">output-channel</span>. An <span class="FontName">@Aggregator</span> collects a series of messages (based on some correlation that you help Spring Integration make between the messages) and publishes a single message to the components downstream. Suppose that you know that you’re expecting 22 different messages from 22 actors in the system, but you don’t know when. This is similar to a company that auctions off a contract and collects all the bids from different vendors before choosing the ultimate vendor. The company can’t accept a bid until all bids have been received from all companies. Otherwise, there’s the risk of prematurely signing a contract that would not be in the best interest of the company. An <span class="FontName">aggregator</span> is perfect for building this type of logic.</p>
<p class="indent">There are many ways for Spring Integration to correlate incoming messages. To determine how many messages to read until it can stop, it uses the class <span class="FontName">SequenceSizeCompletionStrategy</span><a id="cXXX.1172" class="calibre5"></a>, which reads a well-known header value (aggregators are often used after a <span class="FontName">splitter</span>. Thus, the default header value is provided by the <span class="FontName">splitter</span>, though there’s nothing stopping you from creating the header parameters yourself) to calculate how many it should look for and to note the index of the message relative to the expected total count (e.g., 3/22).</p>
<p class="indent">For correlation when you might not have a size but know that you’re expecting messages that share a common header value within a known time, Spring Integration provides the <span class="FontName">HeaderAttributeCorrelationStrategy</span><a id="cXXX.1173" class="calibre5"></a>. In this way, it knows that all messages with that value are from the same group, in the same way that your last name identifies you as being part of a larger group.</p>
<p class="indent">Let’s revisit the last example. Suppose that the file was split (by lines, each belonging to a new customer) and subsequently processed. You now want to reunite the customers and do some cleanup with everyone at the same time. In this example, you use the default <span class="FontName">completion-strategy</span> and <span class="FontName">correlation-strategy</span>. The only custom logic is a POJO with an <span class="FontName">@Aggregator</span> annotation on a method expecting a collection of <span class="FontName">Message&lt;T&gt;</span> objects. It could, of course, be a collection of <span class="FontName">Customer</span> objects, because they are what you’re expecting as output from the previous <span class="FontName">splitter</span>. You return on the reply channel a <span class="FontName">Message&lt;T&gt;</span> that has the entire collection as its payload:</p>
<pre class="calibre11">     <span class="FontName">&lt;beans:bean id="customAggregator" class="com.apress.springrecipes.<img src="../images/00053.jpeg" alt="image" class="calibre3"/></span><br class="calibre10"/><span class="FontName">springintegration.MessagePayloadAggregator"/&gt;</span><br class="calibre10"/> <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;channel id="deletedCustomerChannel"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;channel id="summaryChannel"/&gt;</span><br class="calibre10"/>  <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;aggregator input-channel="deletedCustomerChannel"</span><br class="calibre10"/>                <span class="FontName">ref="customAggregator"</span><br class="calibre10"/>                <span class="FontName">output-channel="summaryChannel" /&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;service-activator input-channel=" summaryChannel "</span><br class="calibre10"/>                   <span class="FontName">ref="summaryServiceActivator"/&gt;</span></pre>
<p class="indent">The Java code is quite simple:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.Aggregator;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.support.MessageBuilder;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.Message;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.ArrayList;</span><br class="calibre10"/><span class="FontName">import java.util.List;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class MessagePayloadAggregator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Aggregator</span><br class="calibre10"/>    <span class="FontName">public Message&lt;?&gt; joinMessages(List&lt;Message&lt;Customer&gt;&gt;customers) {</span><br class="calibre10"/>        <span class="FontName">if (customers.size() &gt; 0) {</span><br class="calibre10"/>            <span class="FontName">List&lt;Customer&gt; payload = new ArrayList&lt;&gt;(customers.size());</span><br class="calibre10"/>            <span class="FontName">for(Message&lt;Customer&gt; customer : customers) {</span><br class="calibre10"/>                <span class="FontName">payload.add(customer.getPayload());</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>            <span class="FontName">return MessageBuilder.withPayload(payload).copyHeadersIfAbsent(customers.get(0).getHeaders()).build();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">return null;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec41" class="Heading">16-8. Conditional Routing with Routers<a id="cXXX.1174" class="calibre6"></a></p>
<p id="Sec42" class="Heading1">Problem</p>
<p class="noindent">You want to conditionally move a message through different processes based on some criteria. This is the EAI equivalent to an if/else branch.</p>
<p id="Sec43" class="Heading1">Solution</p>
<p class="noindent">You can use a <span class="FontName">router</span> component to alter the processing flow based on some predicate. You can also use a router to multicast a message to many subscribers (as you did with the <span class="FontName">splitter</span>).</p>
<p id="Sec44" class="Heading1">How It Works</p>
<p class="noindent">With a router you can specify a known list of channels on which the incoming <span class="FontName">Message</span> should be passed. This has some powerful implications. It means you can change the flow of a process conditionally, and it also means that you can forward a <span class="FontName">Message</span> to as many (or as few) channels as you want. There are some convenient default routers available to fill common needs, such as payload-type–based routing (<span class="FontName">PayloadTypeRouter</span>) and routing to a group or list of channels (<span class="FontName">RecipientListRouter</span>).</p>
<p class="indent">Imagine, for example, a processing pipeline that routes customers with high credit scores to one service and customers with lower credit scores to another process in which the information is queued up for a human audit and verification cycle. The configuration is, as usual, very straightforward. In the following example, you show the configuration. One <span class="FontName">router</span> element, which in turn delegates the routing logic to a class, is <span class="FontName">CustomerCreditScoreRouter</span>.</p>
<pre class="calibre11"><span class="FontName">&lt;beans:bean id="customerCreditScoreRouter"<img src="../images/00053.jpeg" alt="image" class="calibre3"/></span><br class="calibre10"/>  <span class="FontName">class="com.apress.springrecipes.springintegration.CustomerCreditScoreRouter"/&gt;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">&lt;channel id="safeCustomerChannel"/&gt;</span><br class="calibre10"/><span class="FontName">&lt;channel id="riskyCustomerChannel"/&gt;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">&lt;router input-channel="customerIdChannel" ref="customerCreditScoreRouter"/&gt;</span></pre>
<p class="indent">The Java code is similarly approachable. It feels a lot like a workflow engine’s conditional element, or even a JSF backing-bean method, in that it extricates the routing logic into the XML configuration, away from code, delaying the decision until runtime. In the example, the <span class="FontName">String</span>s returned are the names of the channels on which the <span class="FontName">Message</span> should pass.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.Router;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class CustomerCreditScoreRouter {</span><br class="calibre10"/>    <b class="calibre4">@Router</b><br class="calibre10"/>    <span class="FontName">public String routeByCustomerCreditScore(Customer customer) {</span><br class="calibre10"/>        <span class="FontName">if (customer.getCreditScore() &gt; 770) {</span><br class="calibre10"/>            <b class="calibre4">return "safeCustomerChannel";</b><br class="calibre10"/>        <span class="FontName">} else {</span><br class="calibre10"/>            <b class="calibre4">return "riskyCustomerChannel";</b><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you decide that you’d rather not let the <span class="FontName">Message&lt;T&gt;</span> pass and want to arrest processing, you can return <span class="FontName">null</span> instead of a <span class="FontName">String</span>.</p>
<p id="Sec45" class="Heading">16-9. Staging Events Using Spring Batch</p>
<p id="Sec46" class="Heading1">Problem</p>
<p class="noindent">You have a file with a million records in it. This file’s too big to handle as one event; it’s far more natural to react to each row as an event.</p>
<p id="Sec47" class="Heading1">Solution</p>
<p class="noindent">Spring Batch works very well with these types of solutions. It allows you to take an input file or a payload and reliably, and systematically, decompose it into events that an ESB can work with.</p>
<p id="Sec48" class="Heading1">How It Works</p>
<p class="noindent">Spring Integration<a id="cXXX.2203" class="calibre5"></a> does support reading files into the bus, and Spring Batch does support providing custom, unique endpoints for data. However, just like Mom always says, “just because you can, it doesn’t mean you <i class="calibre8">should</i>.”</p>
<p class="indent">Although it seems as if there’s a lot of overlap here, it turns out that there is a distinction (albeit a fine one). While both systems will work with files and message queues, or anything else you could conceivably write code to talk to, Spring Integration doesn’t do well with large payloads because it’s hard to deal with something as large as a file with a million rows that might require hours of work as an <i class="calibre8">event</i>. That’s simply too big a burden for an ESB. At that point, the term <i class="calibre8">event</i> has no meaning. A million records in a CSV file isn’t an event on a bus, it’s a file with a million records, each of which might in turn <i class="calibre8">be</i> events. It’s a subtle distinction.</p>
<p class="indent">A file with a million rows needs to be decomposed into smaller events. Spring Batch can help here: it allows you to systematically read through, apply validations, and optionally skip and retry invalid records. The processing can begin on an ESB such as Spring Integration. Spring Batch and Spring Integration can be used together to build truly scalable decoupled systems.</p>
<p class="indent"><i class="calibre8">Staged event-driven architecture (</i><i class="calibre8">SEDA</i><a id="cXXX.1175" class="calibre5"></a><i class="calibre8">)</i> is an architecture style that deals with this sort of processing situation. In SEDA<a id="cXXX.1176" class="calibre5"></a>, you dampen the load on components of the architecture by staging it in queues, and let advance only what the components downstream can handle. Put another way, imagine video processing. If you ran a site with a million users uploading video that in turn needed to be transcoded and you only had ten servers, your system would fail if your system attempted to process each video as soon as it received the uploaded video. Transcoding can take hours and pegs a CPU (or multiple CPUs!) while it works. The most sensible thing to do would be to store the file and then, as capacity permits, process each one. In this way, the load on the nodes that handle transcoding is managed. There’s always only enough work to keep the machine humming, but not overrun.</p>
<p class="indent">Similarly, no processing system (such as an ESB) can deal with a million records at once efficiently. Strive to decompose bigger events and messages into smaller ones. Let’s imagine a hypothetical solution designed to accommodate a drop of batch files representing hourly sales destined for fulfillment. The batch files are dropped onto a mount that Spring Integration is monitoring. Spring Integration kicks off processing as soon as it sees a new file. Spring Integration tells Spring Batch about the file and launches a Spring Batch job asynchronously.</p>
<p class="indent">Spring Batch reads the file, transforms the records into objects, and writes the output to a JMS topic with a key correlating the original batch to the JMS message. Naturally, this takes half a day to get done, but it does get done. Spring Integration, completely unaware that the job it started half a day ago is now finished, begins popping messages off the topic, one by one. Processing to fulfill the records would begin. Simple processing involving multiple components might begin on the ESB.</p>
<p class="indent">If fulfillment is a long-lived process with a long-lived, conversational state involving many actors, perhaps the fulfillment for each record could be farmed to a BPM engine. The BPM engine<a id="cXXX.1177" class="calibre5"></a> would thread together the different actors and work lists, allow work to continue over the course of days instead of the small millisecond timeframes Spring Integration is more geared to. In this example, we talked about using Spring Batch as a springboard to dampen the load for components downstream. In this case, the component downstream was again a Spring Integration process that took the work and set it up to be funneled into a BPM engine where final processing could begin.</p>
<p class="indent">Spring Integration could use directory polling as a trigger to start a batch job and for the start supply the name of the file to process. To launch a job from Spring Integration, Spring Batch provides the <span class="FontName">JobLaunchingMessageHandler</span><a id="cXXX.1178" class="calibre5"></a> (this is part of the <span class="FontName">spring-batch-integration</span> module). This class takes a <span class="FontName">JobLaunchRequest</span> to determine which job with which parameters to start. You have to create a transformer to change the incoming <span class="FontName">Message&lt;File&gt;</span> to a <span class="FontName">JobLaunchRequest</span>.</p>
<p class="indent">The transformer could look like the following</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.Job;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.JobParametersBuilder;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.integration.launch.JobLaunchRequest;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.Transformer;</span><br class="calibre10"/><span class="FontName">import org.springframework.messaging.Message;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.io.File;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class FileToJobLaunchRequestTransformer {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private final Job job;</span><br class="calibre10"/>    <span class="FontName">private final String fileParameterName;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public FileToJobLaunchRequestTransformer(Job job, String fileParameterName) {</span><br class="calibre10"/>        <span class="FontName">this.job=job;</span><br class="calibre10"/>        <span class="FontName">this.fileParameterName=fileParameterName;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transformer</span><br class="calibre10"/>    <span class="FontName">public JobLaunchRequest transform(Message&lt;File&gt; message) throws Exception {</span><br class="calibre10"/>        <span class="FontName">JobParametersBuilder builder = new JobParametersBuilder();</span><br class="calibre10"/>        <span class="FontName">builder.addString(fileParameterName, message.getPayload().getAbsolutePath());</span><br class="calibre10"/>        <span class="FontName">return new JobLaunchRequest(job, builder.toJobParameters());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The transformer needs a <span class="FontName">Job</span> and a filename parameter to be constructed, this parameter is used in the Spring Batch job to determine which file needs to be loaded. The incoming message in transformed in a <span class="FontName">JobLaunchRequest</span> using the full name of the file as a parameter value. This request can be used to launch a batch job.</p>
<p class="indent">To wire everything together the following configuration could be used (note the Spring Batch setup is missing here see <a href="part0023.html" class="calibre5">chapter 13</a> for information on setting up Spring Batch).</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><span class="FontName">&lt;beans:beans xmlns:beans="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>            <span class="FontName"> xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration" class="calibre5">http://www.springframework.org/schema/integration</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xmlns:file="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration/file" class="calibre5">http://www.springframework.org/schema/integration/file</a></span><span class="FontName">"</span><br class="calibre10"/>             <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>                <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans.xsd</a></span><br class="calibre10"/>                <span class="FontName"><a href="http://www.springframework.org/schema/integration" class="calibre5">http://www.springframework.org/schema/integration</a></span><br class="calibre10"/>                <span class="FontName"><a href="http://www.springframework.org/schema/integration/spring-integration.xsd" class="calibre5">http://www.springframework.org/schema/integration/spring-integration.xsd</a></span><br class="calibre10"/>                <span class="FontName"><a href="http://www.springframework.org/schema/integration/file" class="calibre5">http://www.springframework.org/schema/integration/file</a></span><br class="calibre10"/>                <span class="FontName"><a href="http://www.springframework.org/schema/integration/file/spring-integration-file.xsd" class="calibre5">http://www.springframework.org/schema/integration/file/spring-integration-file.xsd</a>"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;channel id="customerBatchChannel"/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;file:inbound-channel-adapter</span><br class="calibre10"/>            <span class="FontName">directory="file:${user.home}/customerstoremove/new/"</span><br class="calibre10"/>            <span class="FontName">channel="customerBatchChannel"  filename-pattern="newCustomers-*.txt"/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="transformer" class="com.apress.springrecipes.springintegration.FileToJobLaunchRequestTransformer"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:constructor-arg index="0" value="importCustomersJob" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:constructor-arg index="1" value="filename" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/beans:bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="jobLaunchingMessageHandler" class="org.springframework.batch.integration.launch.JobLaunchingMessageHandler"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:constructor-arg ref="jobLauncher" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/beans:bean&gt;</span><br class="calibre10"/><br class="calibre10"/>     <span class="FontName">&lt;chain input-channel="customerBatchChannel"&gt;</span><br class="calibre10"/>         <span class="FontName">&lt;transformer ref="transformer" /&gt;</span><br class="calibre10"/>         <span class="FontName">&lt;service-activator ref="jobLaunchingMessageHandler" /&gt;</span><br class="calibre10"/>     <span class="FontName">&lt;/chain&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans:beans&gt;</span></pre>
<p class="indent">The <span class="FontName">FileToJobLaunchRequestTransformer</span> is configured as well as the <span class="FontName">JobLaunchingMessageHandler</span>. A <span class="FontName">file-inbound-channel-adapter</span> is used to poll for files, when a file is detected a message is placed on the <span class="FontName">customerBatchChannel</span><a id="cXXX.1179" class="calibre5"></a>. A chain is configured to listen to the <span class="FontName">customerBatchChannel</span> when a message is received it is first transformed and next passed on to the <span class="FontName">JobLaunchingMessageHandler</span>.</p>
<p class="indent">Now a batch job will be launched to process the file. A typical job would probably use a FlatFileItemReader to actually read the file, JmsItemWriter could be used to write messages per read row on a topic. In Spring integration a jms-inbound-channel-adapter could be used to receive to messages and process them.</p>
<p id="Sec49" class="Heading">16-10. Using Gateways<a id="cXXX.1180" class="calibre6"></a></p>
<p id="Sec50" class="Heading1">Problem</p>
<p class="noindent">You want to expose an interface to clients of your service, without betraying the fact that your service is implemented in terms of messaging middleware.</p>
<p id="Sec51" class="Heading1">Solution</p>
<p class="noindent">Use a gateway—a pattern from the classic book <i class="calibre8">Enterprise Integration Patterns</i> by Gregor Hohpe and Bobby Woolf (Addison-Wesley, 2004) that enjoys rich support in Spring Integration.</p>
<p id="Sec52" class="Heading1">How It Works</p>
<p class="noindent">A <i class="calibre8">gateway</i> is a distinct animal, similar to a lot of other patterns but ultimately different enough to warrant its own consideration. You used adapters in previous examples to enable two systems to speak in terms of foreign, loosely coupled, middleware components. This foreign component can be anything: the file system, JMS queues/topics, Twitter, and so on.</p>
<p class="indent">You also know what a <i class="calibre8">façade</i> is, serving to abstract away the functionality of other components in an abbreviated interface to provide courser functionality. You might use a façade to build an interface oriented around vacation planning that in turn abstracts away the minutiae of using a car rental, hotel reservation, and airline reservation system.</p>
<p class="indent">You build a gateway, on the other hand, to provide an interface for your system that insulates clients from the middleware or messaging in your system, so that they’re not dependent on JMS or Spring Integration APIs, for example. A gateway allows you to express compile time constraints on the inputs and outputs of your system.</p>
<p class="indent">There are several reasons why you might want to do this. First, it’s cleaner. If you have the latitude to insist that clients comply with an interface, this is a good way to provide that interface. Your use of middleware can be an implementation detail. Perhaps your architectures messaging middleware<a id="cXXX.1181" class="calibre5"></a> can be to exploit the performance increases had by leveraging asynchronous messaging, but you didn’t intend for those performance gains to come at the cost of a precise, explicit external facing interface.</p>
<p class="indent">This feature—the capability to hide messaging behind a POJO interface<a id="cXXX.1182" class="calibre5"></a>—is very interesting and has been the focus of several other projects. Lingo, a project from Codehaus.org that is no longer under active development, had such a feature that was specific to JMS and the Java EE Connector Architecture (JCA—it was originally used to talk about the Java Cryptography Architecture, but is more commonly used for The Java EE Connector Architecture now). Since then, the developers have moved on to work on Apache Camel.</p>
<p class="indent">In this recipe, you’ll explore Spring Integration’s core support for messaging gateways and explore its support for message exchange patterns. Then, you’ll see how to completely remove implementation details from the client-facing interface.</p>
<p id="Sec53" class="Heading2">SimpleMessagingGateway</p>
<p class="noindent">The most fundamental support for gateways comes from the Spring Integration class <span class="FontName">SimpleMessagingGateway</span><a id="cXXX.1183" class="calibre5"></a>. The class provides the ability to specify a channel on which requests should be sent and a channel on which responses are expected. Finally, the channel on which replies are sent can be specified. This gives you the ability to express in-out and in-only patterns on top of your existing messaging systems. This class supports working in terms of payloads, isolating you from the gory details of the messages being sent and received. This is already one level of abstraction. You could, conceivably, use the <span class="FontName">SimpleMessagingGateway</span> and Spring Integration’s concept of channels to interface with file systems, JMS, e-mail, or any other system and deal simply with payloads and channels. There are implementations already provided for you to support some of these common endpoints such as web services and JMS.</p>
<p class="indent">Let’s look at using a generic messaging gateway. In this example, you’ll send messages to a <span class="FontName">service-activator</span> and then receive the response. You manually interface with the <span class="FontName">SimpleMessageGateway</span> so that you can see how convenient it is.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.core.MessageChannel;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.gateway.SimpleMessagingGateway;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SimpleMessagingGatewayExample {</span><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ClassPathXmlApplicationContext ctx =</span><br class="calibre10"/>                        <span class="FontName">new ClassPathXmlApplicationContext("solution042.xml");</span><br class="calibre10"/>        <b class="calibre4">MessageChannel request = (MessageChannel) ctx.getBean("request");</b><br class="calibre10"/>        <b class="calibre4">MessageChannel response = (MessageChannel) ctx.getBean("response");</b><br class="calibre10"/>        <b class="calibre4">SimpleMessagingGateway msgGateway = new SimpleMessagingGateway();</b><br class="calibre10"/>        <b class="calibre4">msgGateway.setRequestChannel(request);</b><br class="calibre10"/>        <b class="calibre4">msgGateway.setReplyChannel(response);</b><br class="calibre10"/>        <b class="calibre4">Number result = (Number) msgGateway.sendAndReceive(new Operands(22, 4));</b><br class="calibre10"/>        <span class="FontName">System.out.println("Result: " + result.floatValue());</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The interface is very straightforward. The <span class="FontName">SimpleMessagingGateway</span> needs a request and a response channel, and it coordinates the rest. In this case, you’re doing nothing but forwarding the request to a <span class="FontName">service-activator</span>, which in turn adds the operands and sends them out on the reply channel. The configuration XML is sparse because most of the work is done in those five lines of Java code.</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><span class="FontName">&lt;beans:beans ... &gt;</span><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="additionService" class="com.apress.springrecipes.springintegration.AdditionService" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;channel id="request" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;channel id="response" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;service-activator  ref="additionService"</span><br class="calibre10"/>        <span class="FontName">method="add"</span><br class="calibre10"/>        <span class="FontName">input-channel="request"</span><br class="calibre10"/>        <span class="FontName">output-channel="response" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans:beans&gt;</span></pre>
<p id="Sec54" class="Heading2">Breaking the Interface Dependency</p>
<p class="noindent">The previous example demonstrates what’s happening behind the scenes. You’re dealing only with Spring Integration interfaces and are isolated from the nuances of the endpoints. However, there are still plenty of inferred constraints that a client might easily fail to comply with. The simplest solution is to hide the messaging behind an interface. Let’s look at building a fictional hotel reservation search engine. Searching for a hotel might take a long time, and ideally processing should be offloaded to a separate server. An ideal solution is JMS because you could implement the aggressive consumer pattern and scale simply by adding more consumers. The client would still block waiting for the result, in this example, but the server(s) would not be overloaded or in a blocking state.</p>
<p class="indent">You’ll build two Spring Integration solutions. One for the client (which will in turn contain the gateway) and one for the service itself, which, presumably, is on a separate host connected to the client only by way of well-known message queues.</p>
<p class="indent">Let’s look at the client configuration first. The first thing that the client configuration does is import a shared application context (to save typing if nothing else) that declares a JMS connection factory that you reference in the client and service application contexts. (We won’t repeat all of that here because it’s not relevant or noteworthy.)</p>
<p class="indent">Then, you declare two channels, imaginatively named <span class="FontName">requests</span> and <span class="FontName">responses</span>. Messages sent on the <span class="FontName">requests</span> channel are forwarded to the <span class="FontName">jms:outbound-</span><span class="FontName">gateway</span><a id="cXXX.1184" class="calibre5"></a> that you’ve declared. The <span class="FontName">jms:outbound-gateway</span> is the component that does most of the work. It takes the message you created and sends it to the request JMS destination, setting up the reply headers and so on. Finally, you declare a generic gateway <span class="FontName">element</span>, which does most of the magic. The gateway <span class="FontName">element</span> simply exists to identify the component and the interface, to which the proxy is cast and made available to clients.</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><span class="FontName">&lt;beans:beans</span><br class="calibre10"/>    <span class="FontName">xmlns:beans="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>   <span class="FontName"> xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration" class="calibre5">http://www.springframework.org/schema/integration</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:context="</span><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:jms="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration/jms" class="calibre5">http://www.springframework.org/schema/integration/jms</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans.xsd</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/context/spring-context.xsd" class="calibre5">http://www.springframework.org/schema/context/spring-context.xsd</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration" class="calibre5">http://www.springframework.org/schema/integration</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/spring-integration.xsd" class="calibre5">http://www.springframework.org/schema/integration/spring-integration.xsd</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/jms" class="calibre5">http://www.springframework.org/schema/integration/jms</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/jms/spring-integration-jms.xsd" class="calibre5">http://www.springframework.org/schema/integration/jms/spring-integration-jms.xsd</a></span><br class="calibre10"/>             <span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;beans:import resource="shared-context.xml" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;context:annotation-config /&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;channel id="requests" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;channel id="responses" /&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;jms:outbound-gateway</span><br class="calibre10"/>        <span class="FontName">request-destination-name="inboundHotelReservationSearchDestination"</span><br class="calibre10"/>        <span class="FontName">request-channel="requests"</span><br class="calibre10"/>        <span class="FontName">reply-destination-name="outboundHotelReservationSearchResultsDestination"</span><br class="calibre10"/>        <span class="FontName">reply-channel="responses"</span><br class="calibre10"/>        <span class="FontName">connection-factory="connectionFactory" /&gt;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">&lt;gateway id="vacationService"</b><br class="calibre10"/>             <b class="calibre4">service-interface="com.apress.springrecipes.springintegration.myholiday.VacationService" /&gt;</b><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;/beans:beans&gt;</span></pre>
<p class="indent">One thing that’s conspicuously absent is any mention of an output or input channel from and to the gateway <span class="FontName">element</span>. While it is possible to declare default request/reply message queues in the configuration for the gateway, realistically, most methods on an interface will require their own request/reply queues. So, you configure the channels on the interface itself.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration.myholiday;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.List;</span><br class="calibre10"/><span class="FontName">import org.springframework.integration.annotation.Gateway;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface VacationService {</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Gateway(requestChannel = "requests", replyChannel = "responses")</b><br class="calibre10"/>    <span class="FontName">List&lt;HotelReservation&gt; findHotels(HotelReservationSearch hotelReservationSearch);</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">This is the client-facing interface<a id="cXXX.1185" class="calibre5"></a>. There is no coupling between the client-facing interface exposed via the gateway component and the interface of the service that ultimately handles the messages. We use the interface for the service and the client to simplify the names needed to understand everything that’s going on. This is not like traditional, synchronous remoting in which the service interface and the client interface match.</p>
<p class="indent">In this example, you’re using two very simple objects for demonstration: <span class="FontName">HotelReservationSearch</span> and <span class="FontName">HotelReservation</span>. There is nothing interesting about these objects in the slightest; they are simple POJOs that implement <span class="FontName">Serializable</span> and contain a few accessor/mutators<a id="cXXX.1186" class="calibre5"></a> to flesh out the example domain.</p>
<p class="indent">The client Java code demonstrates how all of this comes together:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.springintegration.myholiday.HotelReservation;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.springintegration.myholiday.HotelReservationSearch;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.springintegration.myholiday.VacationService;</span><br class="calibre10"/><span class="FontName">import org.apache.commons.lang3.time.DateUtils;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.Date;</span><br class="calibre10"/><span class="FontName">import java.util.List;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) throws Throwable {</span><br class="calibre10"/>        <span class="FontName">// Start server</span><br class="calibre10"/>        <span class="FontName">ApplicationContext ctx = new ClassPathXmlApplicationContext("server-integration-context.xml");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">// Start client and do a search</span><br class="calibre10"/>        <span class="FontName">ApplicationContext clientCtx =             new ClassPathXmlApplicationContext("client-integration-context.xml");</span><br class="calibre10"/>        <span class="FontName">VacationService vacationService = clientCtx.getBean(VacationService.class);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Date now = new Date();</span><br class="calibre10"/>        <span class="FontName">HotelReservationSearch hotelReservationSearch =             new HotelReservationSearch(200f, 2, DateUtils.addDays(now, 1), DateUtils.addDays(now, 8));</span><br class="calibre10"/>        <span class="FontName">List&lt;HotelReservation&gt; results = vacationService.findHotels(hotelReservationSearch);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">System.out.printf("Found %s results.", results.size());</span><br class="calibre10"/>        <span class="FontName">System.out.println();</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">for (HotelReservation reservation : results) {</span><br class="calibre10"/>            <span class="FontName">System.out.printf("\t%s", reservation.toString());</span><br class="calibre10"/>            <span class="FontName">System.out.println();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">It just doesn’t get any cleaner than that! No Spring Integration<a id="cXXX.2037" class="calibre5"></a> interfaces whatsoever. You make a request, searching is done, and you get the result back when the processing is done.</p>
<p class="indent">The service implementation for this setup is interesting, not because of what you’ve added, but because of what’s not there:</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><span class="FontName">&lt;beans:beans</span><br class="calibre10"/>    <span class="FontName">xmlns:beans="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>   <span class="FontName"> xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration" class="calibre5">http://www.springframework.org/schema/integration</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:context="</span><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:jms="</span><span class="FontName"><a href="http://www.springframework.org/schema/integration/jms" class="calibre5">http://www.springframework.org/schema/integration/jms</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans.xsd</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/context/spring-context.xsd" class="calibre5">http://www.springframework.org/schema/context/spring-context.xsd</a></span><span class="FontName"></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration" class="calibre5">http://www.springframework.org/schema/integration</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/spring-integration.xsd" class="calibre5">http://www.springframework.org/schema/integration/spring-integration.xsd</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/jms" class="calibre5">http://www.springframework.org/schema/integration/jms</a></span><br class="calibre10"/><span class="FontName"><a href="http://www.springframework.org/schema/integration/jms/spring-integration-jms.xsd" class="calibre5">http://www.springframework.org/schema/integration/jms/spring-integration-jms.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;beans:import  resource="shared-context.xml" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;context:annotation-config /&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;channel id="inboundHotelReservationSearchChannel" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;channel id="outboundHotelReservationSearchResultsChannel" /&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="vacationServiceImpl"</span><br class="calibre10"/>                <span class="FontName">class="com.apress.springrecipes.springintegration.myholiday.VacationServiceImpl" /&gt;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">&lt;jms:inbound-gateway</b><br class="calibre10"/>        <b class="calibre4">request-channel="inboundHotelReservationSearchChannel"</b><br class="calibre10"/>        <b class="calibre4">request-destination-name="inboundHotelReservationSearchDestination"</b><br class="calibre10"/>        <b class="calibre4">connection-factory="connectionFactory" /&gt;</b><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">&lt;service-activator</b><br class="calibre10"/>        <b class="calibre4">input-channel="inboundHotelReservationSearchChannel"</b><br class="calibre10"/>        <b class="calibre4">ref="vacationServiceImpl"</b><br class="calibre10"/>        <b class="calibre4">method="findHotels" /&gt;</b><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;/beans:beans&gt;</span></pre>
<p class="indent">Here, you’ve defined an inbound JMS gateway <span class="FontName">element</span>. The messages from the inbound JMS gateway are put on a channel, <span class="FontName">inboundHotelReservationSearchChannel</span><a id="cXXX.1187" class="calibre5"></a>, whose messages are forwarded to a <span class="FontName">service-activator</span>, as you would expect. The <span class="FontName">service-activator</span> is what handles actual processing. What’s interesting here is that there’s no mention of a response channel, for either the <span class="FontName">service-activator</span>, or for the inbound JMS gateway. The <span class="FontName">service-activator</span><a id="cXXX.1188" class="calibre5"></a> looks, and fails to find, a reply channel and so uses the reply channel created by the inbound JMS gateway component, which in turn has created the reply channel based on the header metadata in the inbound JMS message. Thus, everything just works without specification.</p>
<p class="indent">The implementation is a simple useless implementation of the interface:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springintegration.myholiday;</span><br class="calibre10"/><span class="FontName">import java.util.Arrays;</span><br class="calibre10"/><span class="FontName">import java.util.List;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.InitializingBean;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class VacationServiceImpl implements VacationService, InitializingBean {</span><br class="calibre10"/>    <span class="FontName">private List&lt;HotelReservation&gt; hotelReservations;</span><br class="calibre10"/>    <span class="FontName">public void afterPropertiesSet() throws Exception {</span><br class="calibre10"/>        <span class="FontName">hotelReservations = Arrays.asList(</span><br class="calibre10"/>    <span class="FontName">new HotelReservation("Bilton", 243.200F),</span><br class="calibre10"/>    <span class="FontName">new HotelReservation("West Western", 75.0F),</span><br class="calibre10"/>    <span class="FontName">new HotelReservation("Theirfield Inn", 70F),</span><br class="calibre10"/>    <span class="FontName">new HotelReservation("Park Inn", 200.00F));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public List&lt;HotelReservation&gt; findHotels(HotelReservationSearch searchMsg) {</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">Thread.sleep(1000);</span><br class="calibre10"/>        <span class="FontName">} catch (Throwable th) {</span><br class="calibre10"/>          <span class="FontName">// eat the exception</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return hotelReservations;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec55" class="Heading">Summary</p>
<p class="noindent">This chapter discussed building an integration solution using Spring Integration, an ESB-like framework built on top of the Spring framework. You were introduced to the core concepts of enterprise application integration (EAI). You learned how to handle a few integration scenarios, including JMS and file polling.</p>
<p class="indent">In the next chapter, you will explore the capabilities of Spring in the field of testing.</p></div>
</body></html>
