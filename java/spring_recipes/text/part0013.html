<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Chapter 3 Spring Annotation Driven Core Tasks</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div class="calibre10">
<pre class="calibre11">
<span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class MaxCalculatorImpl implements MaxCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double max(double a, double b) {</span><br class="calibre10"/>        <span class="FontName">double result = (a &gt;=b) ? a : b;</span><br class="calibre10"/>        <span class="FontName">System.out.println("max(" + a + ", " + b + ") = " + result);</span><br class="calibre10"/>        <span class="FontName">return result;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class MinCalculatorImpl implements MinCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double min(double a, double b) {</span><br class="calibre10"/>        <span class="FontName">double result = (a &lt;= b) ? a : b;</span><br class="calibre10"/>        <span class="FontName">System.out.println("min(" + a + ", " + b + ") = " + result);</span><br class="calibre10"/>        <span class="FontName">return result;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Now, suppose you would like <span class="FontName">ArithmeticCalculatorImpl</span> to perform the <span class="FontName">max()</span> and <span class="FontName">min()</span> calculation also. As the Java language supports single inheritance only, it is not possible for the <span class="FontName">ArithmeticCalculatorImpl</span> class to extend both the <span class="FontName">MaxCalculatorImpl</span> and <span class="FontName">MinCalculatorImpl</span> classes at the same time. The only possible way is to extend either class (e.g., <span class="FontName">MaxCalculatorImpl</span>) and implement another interface (e.g., <span class="FontName">MinCalculator</span>), either by copying the implementation code or delegating the handling to the actual implementation class. In either case, you have to repeat the method declarations.</p>
<p class="indent">With an introduction, you can make <span class="FontName">ArithmeticCalculatorImpl</span> dynamically implement both the <span class="FontName">MaxCalculator</span> and <span class="FontName">MinCalculator</span> interfaces by using the implementation classes <span class="FontName">MaxCalculatorImpl</span> and <span class="FontName">MinCalculatorImpl</span>. It has the same effect as multiple inheritance<a id="cXXX.304" class="calibre5"></a> from <span class="FontName">MaxCalculatorImpl</span> and <span class="FontName">MinCalculatorImpl</span>. The idea behind an introduction is that you needn’t modify the <span class="FontName">ArithmeticCalculatorImpl</span> class to introduce new methods. That means you can introduce methods to your existing classes even without source code available.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Tip</b>  You may wonder how an introduction can do that in Spring AOP. The answer is a dynamic proxy. As you may recall, you can specify a group of interfaces for a dynamic proxy to implement. Introduction works by adding an interface (e.g., MaxCalculator) to the dynamic proxy. When the methods declared in this interface are called on the proxy object, the proxy will delegate the calls to the backend implementation class (e.g., MaxCalculatorImpl).</p></div>
<p class="indent">Introductions, like advices, must be declared within an aspect. You may create a new aspect or reuse an existing aspect for this purpose. In this aspect, you can declare an introduction by annotating an arbitrary field with the <span class="FontName">@DeclareParents</span> annotation<a id="cXXX.305" class="calibre5"></a>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.DeclareParents;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class CalculatorIntroduction {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@DeclareParents(</span><br class="calibre10"/>        <span class="FontName">value = "com.apress.springrecipes.calculator.ArithmeticCalculatorImpl",</span><br class="calibre10"/>        <span class="FontName">defaultImpl = MaxCalculatorImpl.class)</span><br class="calibre10"/>    <span class="FontName">public MaxCalculator maxCalculator;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@DeclareParents(</span><br class="calibre10"/>        <span class="FontName">value = "com.apress.springrecipes.calculator.ArithmeticCalculatorImpl",</span><br class="calibre10"/>        <span class="FontName">defaultImpl = MinCalculatorImpl.class)</span><br class="calibre10"/>    <span class="FontName">public MinCalculator minCalculator;</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The value attribute of the <span class="FontName">@DeclareParents</span> annotation type indicates which classes are the targets for this introduction. The interface to introduce is determined by the type of the annotated field. Finally, the implementation class used for this new interface is specified in the defaultImpl attribute.</p>
<p class="indent">Through these two introductions, you can dynamically introduce a couple of interfaces to the <span class="FontName">ArithmeticCalculatorImpl</span> class. Actually, you can specify an AspectJ type-matching expression in the value attribute of the <span class="FontName">@DeclareParents</span> annotation to introduce an interface to multiple classes.</p>
<p class="indent">As you have introduced both the <span class="FontName">MaxCalculator</span> and <span class="FontName">MinCalculator</span> interfaces to your arithmetic calculator, you can cast it to the corresponding interface to perform the <span class="FontName">max()</span> and <span class="FontName">min()</span> calculations.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">ArithmeticCalculator arithmeticCalculator =</span><br class="calibre10"/>            <span class="FontName">(ArithmeticCalculator) context.getBean("arithmeticCalculator");</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">MaxCalculator maxCalculator = (MaxCalculator) arithmeticCalculator;</span><br class="calibre10"/>        <span class="FontName">maxCalculator.max(1, 2);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">MinCalculator minCalculator = (MinCalculator) arithmeticCalculator;</span><br class="calibre10"/>        <span class="FontName">minCalculator.min(1, 2);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec113" class="Heading">3-18. Introduce states to your POJOs with AOP</p>
<p id="Sec114" class="Heading1">Problem</p>
<p class="noindent">Sometimes, you may want to add new states to a group of existing objects to keep track of their usage, such as the calling count, the last modified date, and so on. It should not be a problem if all the objects have the same base class. However, it’s difficult to add such states to different classes if they are not in the same class hierarchy.</p>
<p id="Sec115" class="Heading1">Solution</p>
<p class="noindent">You can introduce a new interface to your objects with an implementation class that holds the state field. Then, you can write another advice to change the state according to a particular condition.</p>
<p id="Sec116" class="Heading1">How It Works</p>
<p class="noindent">Suppose<a id="cXXX.306" class="calibre5"></a> you would like to keep track of the calling count of each calculator object. Since there is no field for storing the counter value in the original calculator classes, you need to introduce one with Spring AOP. First, let’s create an interface for the operations of a counter.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface Counter {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void increase();</span><br class="calibre10"/>    <span class="FontName">public int getCount();</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Next, just write a simple implementation class for this interface. This class has a count field for storing the counter value.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class CounterImpl implements Counter {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private int count;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void increase() {</span><br class="calibre10"/>        <span class="FontName">count++;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public int getCount() {</span><br class="calibre10"/>        <span class="FontName">return count;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">To introduce the <span class="FontName">Counter</span> interface to all your calculator objects with <span class="FontName">CounterImpl</span> as the implementation, you can write the following introduction with a type-matching expression that matches all the calculator implementations:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.DeclareParents;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class CalculatorIntroduction {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@DeclareParents(</span><br class="calibre10"/>        <span class="FontName">value = "com.apress.springrecipes.calculator.*CalculatorImpl",</span><br class="calibre10"/>        <span class="FontName">defaultImpl = CounterImpl.class)</span><br class="calibre10"/>    <span class="FontName">public Counter counter;</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">This introduction introduces <span class="FontName">CounterImpl</span> to each of your calculator objects. However, it’s still not enough to keep track of the calling count. You have to increase the counter value each time a calculator method is called. You can write an after advice for this purpose. Note that you must get this object but not the target object, as only the proxy object implements the <span class="FontName">Counter</span> interface.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.After;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class CalculatorIntroduction {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@After("execution(* com.apress.springrecipes.calculator.*Calculator.*(..))"</span><br class="calibre10"/>            <span class="FontName">+ " &amp;&amp; this(counter)")</span><br class="calibre10"/>    <span class="FontName">public void increaseCount(Counter counter) {</span><br class="calibre10"/>        <span class="FontName">counter.increase();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In the <span class="FontName">Main</span> class, you can output the counter value for each of the calculator objects by casting them into the Counter type.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">ArithmeticCalculator arithmeticCalculator =</span><br class="calibre10"/>            <span class="FontName">(ArithmeticCalculator) context.getBean("arithmeticCalculator");</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">UnitCalculator unitCalculator =</span><br class="calibre10"/>            <span class="FontName">(UnitCalculator) context.getBean("unitCalculator");</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Counter arithmeticCounter = (Counter) arithmeticCalculator;</span><br class="calibre10"/>        <span class="FontName">System.out.println(arithmeticCounter.getCount());</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Counter unitCounter = (Counter) unitCalculator;</span><br class="calibre10"/>        <span class="FontName">System.out.println(unitCounter.getCount());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec117" class="Heading">3-19. <a id="cXXX.307" class="calibre6"></a>Load-Time Weaving AspectJ Aspects in Spring<a id="cXXX.2099" class="calibre6"></a></p>
<p id="Sec118" class="Heading1">Problem</p>
<p class="noindent">The<a id="cXXX.308" class="calibre5"></a> Spring AOP framework supports only limited types of AspectJ pointcuts and allows aspects to apply to beans declared in the IoC container. If you want to use additional pointcut types or apply your aspects to objects created outside the Spring IoC container, you have to use the AspectJ framework in your Spring application.</p>
<p id="Sec119" class="Heading1">Solution</p>
<p class="noindent">Weaving is the process of applying aspects to your target objects. With Spring AOP, weaving happens at runtime through dynamic proxies. In contrast, the AspectJ framework supports both compile-time and load-time weaving.</p>
<p class="indent">AspectJ compile-time weaving is done through a special AspectJ compiler<a id="cXXX.309" class="calibre5"></a> called ajc. It can weave aspects into your Java source files and output woven binary class files. It can also weave aspects into your compiled class files or JAR files. This process is known as post-compile-time weaving<a id="cXXX.310" class="calibre5"></a>. You can perform compile-time and post-compile-time weaving for your classes before declaring them in the Spring IoC container. Spring is not involved in the weaving process at all. For more information on compile-time and post-compile-time weaving, please refer to the AspectJ documentation.</p>
<p class="indent">AspectJ load-time weaving (also known as LTW) happens when the target classes are loaded into JVM<a id="cXXX.311" class="calibre5"></a> by a class loader. For a class to be woven, a special class loader is required to enhance the bytecode of the target class. Both AspectJ and Spring provide load-time weavers to add load-time weaving capability to the class loader. You need only simple configurations to enable these load-time weavers.</p>
<p id="Sec120" class="Heading1">How It Works</p>
<p class="noindent">To understand the AspectJ load-time weaving process in a Spring application, let’s consider a calculator for complex numbers. First, you create the <span class="FontName">Complex</span> class to represent complex numbers. You define the <span class="FontName">toString()</span> method<a id="cXXX.312" class="calibre5"></a> for this class to convert a complex number into the string representation (a + bi).</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Complex {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private int real;</span><br class="calibre10"/>    <span class="FontName">private int imaginary;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Complex(int real, int imaginary) {</span><br class="calibre10"/>        <span class="FontName">this.real = real;</span><br class="calibre10"/>        <span class="FontName">this.imaginary = imaginary;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Getters and Setters</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public String toString() {</span><br class="calibre10"/>        <span class="FontName">return "(" + real + " + " + imaginary + "i)";</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Next, you define an interface<a id="cXXX.313" class="calibre5"></a> for the operations on complex numbers. For simplicity’s sake, only <span class="FontName">add()</span> and <span class="FontName">sub()</span> are supported.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface ComplexCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Complex add(Complex a, Complex b);</span><br class="calibre10"/>    <span class="FontName">public Complex sub(Complex a, Complex b);</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The implementation code for this interface is as follows. Each time, you return a new complex object as the result.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Component("complexCalculator")</span><br class="calibre10"/><span class="FontName">public class ComplexCalculatorImpl implements ComplexCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Complex add(Complex a, Complex b) {</span><br class="calibre10"/>        <span class="FontName">Complex result = new Complex(a.getReal() + b.getReal(),</span><br class="calibre10"/>                <span class="FontName">a.getImaginary() + b.getImaginary());</span><br class="calibre10"/>        <span class="FontName">System.out.println(a + " + " + b + " = " + result);</span><br class="calibre10"/>        <span class="FontName">return result;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Complex sub(Complex a, Complex b) {</span><br class="calibre10"/>        <span class="FontName">Complex result = new Complex(a.getReal() - b.getReal(),</span><br class="calibre10"/>                <span class="FontName">a.getImaginary() - b.getImaginary());</span><br class="calibre10"/>        <span class="FontName">System.out.println(a + " - " + b + " = " + result);</span><br class="calibre10"/>        <span class="FontName">return result;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Now, you can test this complex number calculator with the following code in the Main class:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">ComplexCalculator complexCalculator =</span><br class="calibre10"/>        <span class="FontName">(ComplexCalculator) context.getBean("complexCalculator");</span><br class="calibre10"/>        <span class="FontName">complexCalculator.add(new Complex(1, 2), new Complex(2, 3));</span><br class="calibre10"/>        <span class="FontName">complexCalculator.sub(new Complex(5, 8), new Complex(2, 3));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">So far, the complex calculator is working fine. However, you may want to improve the performance of the calculator by caching complex number objects. As caching<a id="cXXX.314" class="calibre5"></a> is a well-known crosscutting concern, you can modularize it with an aspect.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.Collections;</span><br class="calibre10"/><span class="FontName">import java.util.HashMap;</span><br class="calibre10"/><span class="FontName">import java.util.Map;</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.aspectj.lang.ProceedingJoinPoint;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Around;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class ComplexCachingAspect {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Map&lt;String, Complex&gt; cache;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public ComplexCachingAspect() {</span><br class="calibre10"/>        <span class="FontName">cache = Collections.synchronizedMap(new HashMap&lt;String, Complex&gt;());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Around("call(public Complex.new(int, int)) &amp;&amp; args(a,b)")</span><br class="calibre10"/>    <span class="FontName">public Object cacheAround(ProceedingJoinPoint joinPoint, int a, int b)</span><br class="calibre10"/>            <span class="FontName">throws Throwable {</span><br class="calibre10"/>        <span class="FontName">String key = a + "," + b;</span><br class="calibre10"/>        <span class="FontName">Complex complex = cache.get(key);</span><br class="calibre10"/>        <span class="FontName">if (complex == null) {</span><br class="calibre10"/>            <span class="FontName">System.out.println("Cache MISS for (" + key + ")");</span><br class="calibre10"/>            <span class="FontName">complex = (Complex) joinPoint.proceed();</span><br class="calibre10"/>            <span class="FontName">cache.put(key, complex);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">else {</span><br class="calibre10"/>            <span class="FontName">System.out.println("Cache HIT for (" + key + ")");</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return complex;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In this aspect, you cache the complex objects in a map with their real and imaginary values as keys. For this map to be thread-safe, you should wrap it with a synchronized map. Then, the most suitable time to look up the cache is when a complex object is created by invoking the constructor. You use the AspectJ pointcut expression call to capture the join points of calling the <span class="FontName">Complex(int, int)</span> constructor<a id="cXXX.315" class="calibre5"></a>.</p>
<p class="indent">Next, you need an around advice to alter the return value. If a complex object of the same value is found in the cache, you return it to the caller directly. Otherwise, you proceed with the original constructor invocation to create a new complex object. Before you return it to the caller, you cache it in the map for subsequent usages.</p>
<p class="indent">The <span class="FontName">call</span> pointcut is not supported by Spring AOP, so if you attempt to let Spring scan the pointcut annotation you’ll get the error ‘unsupported pointcut primitive call’.</p>
<p class="indent">Because this type of pointcut is not supported by Spring AOP, you have to use the AspectJ framework to apply this aspect. The configuration of the AspectJ framework is done through a file named <span class="FontName">aop.xml</span> in the <span class="FontName">META-INF</span> directory in the classpath root.</p>
<pre class="calibre11"><span class="FontName">&lt;!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN"</span><br class="calibre10"/>    <span class="FontName">"</span><span class="FontName"><a href="http://www.eclipse.org/aspectj/dtd/aspectj.dtd" class="calibre5">http://www.eclipse.org/aspectj/dtd/aspectj.dtd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;aspectj&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;weaver&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;include within="com.apress.springrecipes.calculator.*" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/weaver&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;aspects&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;aspect</span><br class="calibre10"/>            <span class="FontName">name="com.apress.springrecipes.calculator.ComplexCachingAspect" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/aspects&gt;</span><br class="calibre10"/><span class="FontName">&lt;/aspectj&gt;</span></pre><p class="indent">In this AspectJ configuration file, you have to specify the aspects and which classes you want your aspects to weave in. Here, you specify weaving <span class="FontName">ComplexCachingAspect</span> into all the classes in the <span class="FontName">com.apress.springrecipes.calculator</span> package.</p>
<p class="indent">Finally, to make this load-time weaving you need to run the application in one of two ways as described in the next sections.</p>
<p id="Sec121" class="Heading2">Load-Time Weaving by the AspectJ Weaver<a id="cXXX.316" class="calibre6"></a></p>
<p class="noindent">AspectJ provides a load-time weaving agent to enable load-time weaving. You need only to add a VM argument to the command that runs your application. Then your classes will get woven when they are loaded into the JVM.</p>
<pre class="calibre11"><span class="FontName">java -javaagent:lib/aspectjweaver-1.7.2.jar -jar Recipe_3_19_ii-1.0.jar</span></pre><p class="indent">If you run your application with the preceding argument, you will get the following output and cache status. The AspectJ agent advises all calls to the <span class="FontName">Complex(int, int)</span> constructor.</p>
<pre class="calibre11"><span class="FontName">Cache MISS for (1,2)</span><br class="calibre10"/><span class="FontName">Cache MISS for (2,3)</span><br class="calibre10"/><span class="FontName">Cache MISS for (3,5)</span><br class="calibre10"/><span class="FontName">(1 + 2i) + (2 + 3i) = (3 + 5i)</span><br class="calibre10"/><span class="FontName">Cache MISS for (5,8)</span><br class="calibre10"/><span class="FontName">Cache HIT for (2,3)</span><br class="calibre10"/><span class="FontName">Cache HIT for (3,5)</span><br class="calibre10"/><span class="FontName">(5 + 8i) - (2 + 3i) = (3 + 5i)</span></pre><p id="Sec122" class="Heading2">Load-Time Weaving by Spring Load-Time Weaver<a id="cXXX.317" class="calibre6"></a></p>
<p class="noindent">Spring has several load-time weavers for different runtime environments. To turn on a suitable load-time weaver for your Spring application, you need only to declare the empty XML element <span class="FontName">&lt;context:load-time-weaver&gt;</span>. This element is defined in the context schema.</p>
<pre class="calibre11"><span class="FontName">&lt;beans   xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:aop="</span><span class="FontName"><a href="http://www.springframework.org/schema/aop" class="calibre5">http://www.springframework.org/schema/aop</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:context="</span><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/aop" class="calibre5">http://www.springframework.org/schema/aop</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/aop/spring-aop-3.2.xsd" class="calibre5">http://www.springframework.org/schema/aop/spring-aop-3.2.xsd</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/context/spring-context-3.2.xsd" class="calibre5">http://www.springframework.org/schema/context/spring-context-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;context:load-time-weaver /&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">Spring will be able to detect the most suitable load-time weaver for your runtime environment. Some Java EE application servers have class loaders that support the Spring load-time weaver mechanism, so there’s no need to specify a Java agent in their startup commands.</p>
<p class="indent">However, for a simple Java application, you still require a weaving agent provided by Spring to enable load-time weaving. You have to specify the Spring agent in the VM argument of the startup command.</p>
<pre class="calibre11"><span class="FontName">java -javaagent:c:lib/spring-instrument-3.2.0.jar -jar Recipe_3_19_iii-1.0.jar</span></pre><p class="indent">However, if you run your application, you will get the following output and cache status.</p>
<pre class="calibre11"><span class="FontName">Cache MISS for (3,5)</span><br class="calibre10"/><span class="FontName">(1 + 2i) + (2 + 3i) = (3 + 5i)</span><br class="calibre10"/><span class="FontName">Cache HIT for (3,5)</span><br class="calibre10"/><span class="FontName">(5 + 8i) - (2 + 3i) = (3 + 5i)</span></pre><p class="indent">This is because the Spring agent advises only the <span class="FontName">Complex(int, int)</span> constructor calls made by beans declared in the Spring IoC container. As the complex operands are created in the <span class="FontName">Main</span> class, the Spring agent will not advise their constructor calls.</p>
<p id="Sec123" class="Heading">3-20. Configuring<a id="cXXX.318" class="calibre6"></a> AspectJ Aspects in Spring<a id="cXXX.319" class="calibre6"></a></p>
<p id="Sec124" class="Heading1">Problem</p>
<p class="noindent">Aspects used in the AspectJ framework<a id="cXXX.2004" class="calibre5"></a> are instantiated by the AspectJ framework itself. Therefore you have to retrieve the aspect instances from the AspectJ framework to configure them.</p>
<p id="Sec125" class="Heading1">Solution</p>
<p class="noindent">Each AspectJ aspect provides a static factory method called <span class="FontName">aspectOf()</span><a id="cXXX.320" class="calibre5"></a>, which allows you to access the current aspect instance. In the Spring IoC container, you can declare a bean created by a factory method by specifying the factory-method attribute.</p>
<p id="Sec126" class="Heading1">How It Works</p>
<p class="noindent">For instance, you can allow the cache map of <span class="FontName">ComplexCachingAspect</span> to be configured via a setter method and delete its instantiation from the constructor.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import java.util.Collections;</span><br class="calibre10"/><span class="FontName">import java.util.Map;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class ComplexCachingAspect {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Map&lt;String, Complex&gt; cache;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setCache(Map&lt;String, Complex&gt; cache) {</span><br class="calibre10"/>        <span class="FontName">this.cache = Collections.synchronizedMap(cache);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">To configure this property in the Spring IoC container you need to use XML configuration because there’s no explicit factory annotation to call a factory method — other than creating a Java config class to setup the factory. So let’s declare a bean in XML created by the factory method <span class="FontName">aspectOf()</span>.</p>
<pre class="calibre11"><span class="FontName">&lt;bean class="com.apress.springrecipes.calculator.ComplexCachingAspect"</span><br class="calibre10"/>    <span class="FontName">factory-method="aspectOf"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="cache"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;map&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;entry key="2,3"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;bean class="com.apress.springrecipes.calculator.Complex"&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;constructor-arg value="2" /&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;constructor-arg value="3" /&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/entry&gt;</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">&lt;entry key="3,5"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;bean class="com.apress.springrecipes.calculator.Complex"&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;constructor-arg value="3"could /&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;constructor-arg value="5" /&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/entry&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/map&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean</span><span class="FontName">&gt;</span></pre><div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Tip</b>  You may wonder why your ComplexCachingAspect has a static factory method aspectOf() that you have not declared. This method is woven by AspectJ at load time to allow you to access the current aspect instance. So, if you are using Spring IDE, it may give you a warning because it cannot find this method in your class.</p></div>
<p class="indent">Finally, because the mechanism used by the static factory method <span class="FontName">aspectOf()</span> is provided by AspectJ, to run the application you use AspectJ’s weaver:</p>
<pre class="calibre11"><span class="FontName">java -javaagent:lib/aspectjweaver-1.7.2.jar -jar Recipe_3_20-1.0.jar</span></pre><p id="Sec127" class="Heading">3-21. Inject POJOs into Domain Objects<a id="cXXX.2029" class="calibre6"></a><a id="cXXX.321" class="calibre6"></a> with AOP</p>
<p id="Sec128" class="Heading1">Problem</p>
<p class="noindent">Beans declared in the Spring IoC container can wire themselves to one another through Spring’s dependency injection capability. However, objects created outside the Spring IoC container cannot wire themselves to Spring beans via configuration. You have to perform the wiring manually with programming code.</p>
<p id="Sec129" class="Heading1">Solution</p>
<p class="noindent">Objects created outside the Spring IoC container are usually domain objects. They are often created using the new operator or from the results of database queries.</p>
<p class="indent">To inject a Spring bean into domain objects created outside Spring, you need the help of AOP. Actually, the injection of Spring beans is also a kind of crosscutting concern. As the domain objects are not created by Spring, you cannot use Spring AOP for injection. Spring supplies an AspectJ aspect specialized for this purpose. You can enable this aspect in the AspectJ framework.<a id="cXXX.322" class="calibre5"></a></p>
<p id="Sec130" class="Heading1">How It Works</p>
<p class="noindent">Suppose you have a global formatter to format complex numbers. This formatter accepts a pattern for formatting and uses the standard <span class="FontName">@Component</span> and <span class="FontName">@Value</span> annotations to instantiate a POJO.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class ComplexFormatter {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Value("(a + bi)")</span><br class="calibre10"/>    <span class="FontName">private String pattern;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setPattern(String pattern) {</span><br class="calibre10"/>        <span class="FontName">this.pattern = pattern;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public String format(Complex complex) {</span><br class="calibre10"/>        <span class="FontName">return pattern.replaceAll("a", Integer.toString(complex.getReal()))</span><br class="calibre10"/>                <span class="FontName">.replaceAll("b", Integer.toString(complex.getImaginary()));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In the <span class="FontName">Complex</span> class, you want to use this formatter in the <span class="FontName">toString()</span> method to convert a complex number into a string. It exposes a setter method for <span class="FontName">ComplexFormatter</span><a id="cXXX.323" class="calibre5"></a>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Complex {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private int real;</span><br class="calibre10"/>    <span class="FontName">private int imaginary;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">private ComplexFormatter formatter;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setFormatter(ComplexFormatter formatter) {</span><br class="calibre10"/>        <span class="FontName">this.formatter = formatter;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public String toString() {</span><br class="calibre10"/>        <span class="FontName">return formatter.format(this);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">However, because <span class="FontName">Complex</span> objects are not instantiated by the Spring IoC container, they cannot be configured for dependency injection in the regular manner. Spring includes <span class="FontName">AnnotationBeanConfigurerAspect</span> in its aspect library to configure the dependencies of any objects, even if they were not created by the Spring IoC container.</p>
<p class="indent">First of all, you have to annotate your object type with the <span class="FontName">@Configurable</span> annotation<a id="cXXX.324" class="calibre5"></a> to declare that this type of object is configurable.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Configurable;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Configurable;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Scope;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configurable</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">@Scope("prototype")</span><br class="calibre10"/><span class="FontName">public class Complex {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">public void setFormatter(ComplexFormatter formatter) {</span><br class="calibre10"/>        <span class="FontName">this.formatter = formatter;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In addition to the <span class="FontName">@Configurable</span> annotation, you decorate the POJO with the standard <span class="FontName">@Component</span>, <span class="FontName">@Scope</span> and <span class="FontName">@Autowired</span> annotations so the bean gets its standard Spring behaviors. However, the <span class="FontName">@Configurable</span> annotation is the most important configuration piece and for it Spring defines a convenient XML element, <span class="FontName">&lt;context:spring-configured&gt;</span>, for you to enable the mentioned aspect.</p>
<pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;context:load-time-weaver /&gt;</span>  <br class="calibre10"/>    <span class="FontName">&lt;context:spring-configured /&gt;</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">&lt;context:component-scan</span><br class="calibre10"/>          <span class="FontName">base-package="com.apress.springrecipes.calculator"/&gt;</span>  <br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">When a class with the <span class="FontName">@Configurable</span> annotation is instantiated, the aspect will look for a prototype-scoped bean definition whose type is the same as this class. Then, it will configure the new instances according to this bean definition. If there are properties declared in the bean definition, the new instances will also have the same properties set by the aspect.</p>
<p class="indent">Finally, to run the application you weave the Aspect it into your classes at load time with the Spring agent.</p>
<pre class="calibre11"><span class="FontName">java -javaagent:c:lib/spring-instrument-3.2.0.jar -jar Recipe_3_21-1.0.jar</span></pre><p id="Sec131" class="Heading">3-22. Concurrency<a id="cXXX.325" class="calibre6"></a><a id="cXXX.326" class="calibre6"></a> with Spring and TaskExecutors</p>
<p id="Sec132" class="Heading1">Problem</p>
<p class="noindent">You<a id="cXXX.327" class="calibre5"></a> want to build a threaded, concurrent program with Spring but don’t know what approach to use, since there’s no standard approach.</p>
<p id="Sec133" class="Heading1">Solution</p>
<p class="noindent">Use Spring’s <span class="FontName">TaskExecutor</span> abstraction<a id="cXXX.328" class="calibre5"></a>. This abstraction provides numerous implementations for many environments, including basic Java SE Executor implementations, the CommonJ WorkManager implementations, and custom implementations. In Spring all the implementations are unified and can be cast to Java SE’s Executor interface, too.</p>
<p id="Sec134" class="Heading1">How It Works</p>
<p class="noindent">Threading is a difficult issue which can be particularly tedious to implement using standard threading in the Java SE environment. Concurrency is another important aspect of server-side components but has little to no standardization in the enterprise Java space. In fact some parts of the Java Enterprise Edition specifications forbid the explicit creation and manipulation of threads.</p>
<p class="indent">In the Java SE landscape, many options have been introduced over the years to deal with threading and concurrency. First, there was the standard <span class="FontName">java.lang.Thread</span> support present since day one and Java Development Kit (JDK) 1.0. Java 1.3 saw the introduction of <span class="FontName">java.util.TimerTask</span> to support doing some sort of work periodically. Java 5 debuted the <span class="FontName">java.util.Concurrent</span> package, as well as a reworked hierarchy for building thread pools, oriented around the <span class="FontName">java.util.concurrent.Executor</span>.</p>
<p class="indent">The application programming interface (API)<a id="cXXX.329" class="calibre5"></a> for <span class="FontName">Executor</span> is simple:</p>
<pre class="calibre11"><span class="FontName">package java.util.concurrent;</span><br class="calibre10"/><span class="FontName">public interface Executor {</span><br class="calibre10"/>    <span class="FontName">void execute(Runnable command);</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent"><span class="FontName">ExecutorService</span>, a subinterface, provides more functionality for managing threads and provides support to raise events to threads, such as <span class="FontName">shutdown()</span>. There are several implementations that have shipped with the JDK since Java SE 5.0. Many of them are available via static factory methods in the <span class="FontName">java.util.concurrent</span> package. What follows are several examples using Java SE classes.</p>
<p class="indent">The <span class="FontName">ExecutorService</span> class provides a <span class="FontName">submit()</span> method, which returns a <span class="FontName">Future&lt;T&gt;</span> object. An instance of <span class="FontName">Future&lt;T&gt;</span> can be used to track the progress of a thread, that’s usually executing asynchronously. You can call <span class="FontName">Future.isDone()</span>or <span class="FontName">Future.isCancelled()</span> to determine whether the job is finished or cancelled, respectively. When you use the <span class="FontName">ExecutorService</span> and <span class="FontName">submit()</span> inside a <span class="FontName">Runnable</span> instance whose <span class="FontName">run</span> method has no return type, calling <span class="FontName">get()</span> on the returned <span class="FontName">Future</span> returns null, or the value specified on submission:</p>
<pre class="calibre11"><span class="FontName">Runnable task = new Runnable(){</span><br class="calibre10"/>  <span class="FontName">public void run(){</span><br class="calibre10"/>    <span class="FontName">try{</span><br class="calibre10"/>        <span class="FontName">Thread.sleep( 1000 * 60 ) ;</span><br class="calibre10"/>        <span class="FontName">System.out.println("Done sleeping for a minute, returning! " );</span><br class="calibre10"/>    <span class="FontName">} catch (Exception ex) { /* ... */ }</span><br class="calibre10"/>  <span class="FontName">}</span><br class="calibre10"/><span class="FontName">};</span><br class="calibre10"/><span class="FontName">ExecutorService executorService  = Executors.newCachedThreadPool() ;</span><br class="calibre10"/><span class="FontName">if(executorService.submit(task, Boolean.TRUE).get().equals( Boolean.TRUE ))</span><br class="calibre10"/>     <span class="FontName">System.out.println( "Job has finished!");</span></pre><p class="indent">With this background information, we can explore some of the characteristics of the various implementations. For example, the following is a class designed to mark the passage of time using <span class="FontName">Runnable</span>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.spring3.executors;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.Date;</span><br class="calibre10"/><span class="FontName">import org.apache.commons.lang.exception.ExceptionUtils;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class DemonstrationRunnable implements Runnable {</span><br class="calibre10"/>  <span class="FontName">public void run() {</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>          <span class="FontName">Thread.sleep(1000);</span><br class="calibre10"/>        <span class="FontName">} catch (InterruptedException e) {</span><br class="calibre10"/>          <span class="FontName">System.out.println(</span><br class="calibre10"/>                <span class="FontName">ExceptionUtils.getFullStackTrace(e));</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">System.out.println(Thread.currentThread().getName());</span><br class="calibre10"/>        <span class="FontName">System.out.printf("Hello at %s \n", new Date());</span><br class="calibre10"/>  <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">You’ll use the same instance when you explore Java SE Executors and Spring’s<a id="cXXX.330" class="calibre5"></a> <span class="FontName">TaskExecutor</span> support:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.spring3.executors;</span><br class="calibre10"/><span class="FontName">import java.util.Date;</span><br class="calibre10"/><span class="FontName">import java.util.concurrent.ExecutorService;</span><br class="calibre10"/><span class="FontName">import java.util.concurrent.Executors;</span><br class="calibre10"/><span class="FontName">import java.util.concurrent.ScheduledExecutorService;</span><br class="calibre10"/><span class="FontName">import java.util.concurrent.TimeUnit;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class ExecutorsDemo {</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">public static void main(String[] args) throws Throwable {</span><br class="calibre10"/>      <span class="FontName">Runnable task = new DemonstrationRunnable();</span><br class="calibre10"/><br class="calibre10"/>      <span class="FontName">// will create a pool of threads and attempt to</span><br class="calibre10"/>      <span class="FontName">// reuse previously created ones if possible</span><br class="calibre10"/>      <span class="FontName">ExecutorService cachedThreadPoolExecutorService = Executors</span><br class="calibre10"/>            <span class="FontName">.newCachedThreadPool();</span><br class="calibre10"/>      <span class="FontName">if (cachedThreadPoolExecutorService.submit(task).get() == null)</span><br class="calibre10"/>         <span class="FontName">System.out.printf("The cachedThreadPoolExecutorService "</span><br class="calibre10"/>               <span class="FontName">+ "has succeeded at %s \n", new Date());</span><br class="calibre10"/><br class="calibre10"/>      <span class="FontName">// limits how many new threads are created, queuing the rest</span><br class="calibre10"/>      <span class="FontName">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(100);</span><br class="calibre10"/>      <span class="FontName">if (fixedThreadPool.submit(task).get() == null)</span><br class="calibre10"/>         <span class="FontName">System.out.printf("The fixedThreadPool has " +</span><br class="calibre10"/>               <span class="FontName">"succeeded at %s \n",</span><br class="calibre10"/>               <span class="FontName">new Date());</span><br class="calibre10"/><br class="calibre10"/>      <span class="FontName">// doesn't use more than one thread at a time</span><br class="calibre10"/>      <span class="FontName">ExecutorService singleThreadExecutorService = Executors</span><br class="calibre10"/>            <span class="FontName">.newSingleThreadExecutor();</span><br class="calibre10"/>      <span class="FontName">if (singleThreadExecutorService.submit(task).get() == null)</span><br class="calibre10"/>         <span class="FontName">System.out.printf("The singleThreadExecutorService "</span><br class="calibre10"/>               <span class="FontName">+ "has succeeded at %s \n", new Date());</span><br class="calibre10"/><br class="calibre10"/>      <span class="FontName">// support sending a job with a known result</span><br class="calibre10"/>      <span class="FontName">ExecutorService es = Executors.newCachedThreadPool();</span><br class="calibre10"/>      <span class="FontName">if (es.submit(task, Boolean.TRUE).get().equals(Boolean.TRUE))</span><br class="calibre10"/>         <span class="FontName">System.out.println("Job has finished!");</span><br class="calibre10"/><br class="calibre10"/>      <span class="FontName">// mimic TimerTask</span><br class="calibre10"/>      <span class="FontName">ScheduledExecutorService scheduledThreadExecutorService = Executors</span><br class="calibre10"/>            <span class="FontName">.newScheduledThreadPool(10);</span><br class="calibre10"/>      <span class="FontName">if (scheduledThreadExecutorService.schedule(</span><br class="calibre10"/>            <span class="FontName">task, 30, TimeUnit.SECONDS).get() == null)</span><br class="calibre10"/>         <span class="FontName">System.out.printf("The scheduledThreadExecutorService "</span><br class="calibre10"/>               <span class="FontName">+ "has succeeded at %s \n", new Date());</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/>      <span class="FontName">// this doesn't stop until it encounters</span><br class="calibre10"/>      <span class="FontName">// an exception or its cancel()ed</span><br class="calibre10"/>      <span class="FontName">scheduledThreadExecutorService.scheduleAtFixedRate(task, 0, 5,</span><br class="calibre10"/>            <span class="FontName">TimeUnit.SECONDS);</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">If you use the <span class="FontName">submit()</span> method version of the <span class="FontName">ExecutorService</span> that accepts <span class="FontName">Callable&lt;T&gt;</span>, then <span class="FontName">submit()</span>returns whatever was returned from the main <span class="FontName">call()</span> method in Callable. The interface for <span class="FontName">Callable</span> is the following:</p>
<pre class="calibre11"><span class="FontName">package java.util.concurrent;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface Callable&lt;V&gt; {</span><br class="calibre10"/>     <span class="FontName">V call() throws Exception;</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In the Java EE landscape, different approaches for solving these sorts of problems have been created, since Java EE by design restricts the handling of threads.</p>
<p class="indent">Quartz<a id="cXXX.331" class="calibre5"></a><a id="cXXX.332" class="calibre5"></a> (a job scheduling framework) was among the first solutions to fill this thread feature gap with a solution that provided scheduling and concurrency. JCA 1.5 (or the J2EE Connector Architecture) is another specification that provides a primitive type of gateway for integration functionality supports ad-hoc concurrency. With JCA components<a id="cXXX.333" class="calibre5"></a> are notified about incoming messages and respond concurrently. JCA 1.5 provides primitive, limited enterprise service bus—similar to integration features, without nearly as much of the finesse of something like SpringSource’s Spring Integration framework.</p>
<p class="indent">The requirement for concurrency wasn’t lost on application server vendors, though. Many other initiatives came to the forefront. For example, in 2003, IBM and BEA jointly created the Timer and WorkManager APIs, which eventually became JSR-237 and was then merged with JSR-236 to focus on how to implement concurrency in a managed environment. The Service Data Object (SDO)<a id="cXXX.334" class="calibre5"></a> Specification, JSR-235, also had a similar solution. In addition, open source implementations of the CommonJ API have sprung up in recent years to achieve the same solution.</p>
<p class="indent">The issue is that there’s no portable, standard, simple way of controlling threads and providing concurrency for components in a managed environment, similar to the case of Java SE solutions.</p>
<p class="indent">Spring provides a unified solution via the <span class="FontName">org.springframeworks.core.task.TaskExecutor</span> interface. The <span class="FontName">TaskExecutor</span> abstraction extends <span class="FontName">java.util.concurrent.Executor</span> which is part of Java 1.5.</p>
<p class="indent">In fact, the <span class="FontName">TaskExecutor</span> interface<a id="cXXX.335" class="calibre5"></a> is used quite a bit internally in the Spring framework. For example, for Spring Quartz integration (which supports threading) and the message-driven POJO container support there’s wide use of <span class="FontName">TaskExecutor</span>:</p>
<pre class="calibre11"><span class="FontName">// the Spring abstraction</span><br class="calibre10"/><span class="FontName">package org.springframework.core.task;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.concurrent.Executor;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface TaskExecutor extends Executor {</span><br class="calibre10"/>  <span class="FontName">void execute(Runnable task);</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In some places, the various solutions mirror the functionality provided by the core JDK options. In others, they’re quite unique and provide integrations with other frameworks such as with CommonJ WorkManager. These integrations usually take the form of a class that can exist in the target framework but that you can manipulate just like any other <span class="FontName">TaskExecutor</span> abstraction.</p>
<p class="indent">Although there’s support for adapting an existing Java SE Executor or ExecutorService as a <span class="FontName">TaskExecutor</span>, this isn’t so important in Spring because the base class for <span class="FontName">TaskExecutor</span> is an <span class="FontName">Executor</span>, anyway. In this way, the <span class="FontName">TaskExecutor</span> in Spring bridges the gap between various solutions on Java EE and Java SE<a id="cXXX.336" class="calibre5"></a>.</p>
<p class="indent">Next, let’s see a simple example of the <span class="FontName">TaskExecutor</span>, using the same <span class="FontName">Runnable</span> defined previously. The client for the code is a simple Spring POJO, into which you’ve injected various instances of <span class="FontName">TaskExecutor</span> with the sole aim of submitting <span class="FontName">Runnable</span><a id="cXXX.337" class="calibre5"></a>:</p>
<pre class="calibre11"><span class="FontName">package</span> <span class="FontName">com.apress.springrecipes.executors;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.core.task.SimpleAsyncTaskExecutor;</span><br class="calibre10"/><span class="FontName">import org.springframework.core.task.SyncTaskExecutor;</span><br class="calibre10"/><span class="FontName">import org.springframework.core.task.support.TaskExecutorAdapter;</span><br class="calibre10"/><span class="FontName">import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br class="calibre10"/><span class="FontName">import org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SpringExecutorsDemo {</span><br class="calibre10"/>           <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>              <span class="FontName">ApplicationContext context =</span><br class="calibre10"/>                   <span class="FontName">new GenericXmlApplicationContext("appContext.xml");</span><br class="calibre10"/>                <span class="FontName">SpringExecutorsDemo demo = context.getBean(</span><br class="calibre10"/>                     <span class="FontName">"springExecutorsDemo", SpringExecutorsDemo.class);</span><br class="calibre10"/>                <span class="FontName">demo.submitJobs();</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>           <span class="FontName">@Autowired</span><br class="calibre10"/>           <span class="FontName">private SimpleAsyncTaskExecutor asyncTaskExecutor;</span><br class="calibre10"/><br class="calibre10"/>           <span class="FontName">@Autowired</span><br class="calibre10"/>           <span class="FontName">private SyncTaskExecutor syncTaskExecutor;</span><br class="calibre10"/><br class="calibre10"/>           <span class="FontName">@Autowired</span><br class="calibre10"/>           <span class="FontName">private TaskExecutorAdapter taskExecutorAdapter;</span><br class="calibre10"/><br class="calibre10"/>          <span class="FontName">/*  No need, since the scheduling and submission</span><br class="calibre10"/>             <span class="FontName">is already configured, and done in the application context</span><br class="calibre10"/>             <span class="FontName">via Factory bean</span><br class="calibre10"/>           <span class="FontName">@Autowired</span><br class="calibre10"/>             <span class="FontName">private ScheduledExecutorFactoryBean concurrentTaskScheduler;</span><br class="calibre10"/>            <span class="FontName">*/</span><br class="calibre10"/><br class="calibre10"/>           <span class="FontName">@Autowired</span><br class="calibre10"/>           <span class="FontName">private ThreadPoolTaskExecutor threadPoolTaskExecutor;</span><br class="calibre10"/><br class="calibre10"/>           <span class="FontName">@Autowired</span><br class="calibre10"/>           <span class="FontName">private DemonstrationRunnable task;</span><br class="calibre10"/><br class="calibre10"/>           <span class="FontName">public void submitJobs() {</span><br class="calibre10"/>                    <span class="FontName">syncTaskExecutor.execute(task);</span><br class="calibre10"/>                    <span class="FontName">taskExecutorAdapter.submit(task);</span><br class="calibre10"/>                    <span class="FontName">asyncTaskExecutor.submit(task);</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/>                      <span class="FontName">/* will do 100 at a time,</span><br class="calibre10"/>                             <span class="FontName">then queue the rest, ie,</span><br class="calibre10"/>                             <span class="FontName">should take round 5 seconds total</span><br class="calibre10"/>                         <span class="FontName">*/</span><br class="calibre10"/>                    <span class="FontName">for (int i = 0; i &lt; 500; i++)</span><br class="calibre10"/>                      <span class="FontName">threadPoolTaskExecutor.submit(task);</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The application context demonstrates the creation of these various <span class="FontName">TaskExecutor</span> implementations. Most are so simple that you could create them manually. Only in one case do you delegate to a factory bean to automatically trigger the execution:</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><span class="FontName">&lt;beans</span><br class="calibre10"/> <span class="FontName">  xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/> <span class="FontName">xmlns:p="</span><span class="FontName"><a href="http://www.springframework.org/schema/p" class="calibre5">http://www.springframework.org/schema/p</a></span><span class="FontName">"</span><br class="calibre10"/> <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/> <span class="FontName">xmlns:util="</span><span class="FontName"><a href="http://www.springframework.org/schema/util" class="calibre5">http://www.springframework.org/schema/util</a></span><span class="FontName">"</span><br class="calibre10"/> <span class="FontName">xmlns:context="</span><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><span class="FontName">"</span><br class="calibre10"/> <span class="FontName">xsi:schemaLocation="</span><br class="calibre10"/>  <span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><br class="calibre10"/>  <span class="FontName"><a href="http://www.springframework.org/schema/context/spring-context-3.2.xsd" class="calibre5">http://www.springframework.org/schema/context/spring-context-3.2.xsd</a></span><br class="calibre10"/>  <span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>  <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><br class="calibre10"/>  <span class="FontName"><a href="http://www.springframework.org/schema/util" class="calibre5">http://www.springframework.org/schema/util</a></span><br class="calibre10"/>  <span class="FontName"><a href="http://www.springframework.org/schema/util/spring-util-3.2.xsd" class="calibre5">http://www.springframework.org/schema/util/spring-util-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/> <span class="FontName">&lt;context:annotation-config /&gt;</span>  <br class="calibre10"/> <span class="FontName">&lt;!—  sample Runnable —&gt;</span><br class="calibre10"/> <span class="FontName">&lt;bean</span><br class="calibre10"/>  <span class="FontName">id="task"  class="com.apress.springrecipes.</span><br class="calibre10"/>                        <span class="FontName">executors.DemonstrationRunnable" /&gt;</span>  <br class="calibre10"/> <span class="FontName">&lt;!—  TaskExecutors  —&gt;</span><br class="calibre10"/> <span class="FontName">&lt;bean</span><br class="calibre10"/>  <span class="FontName">class="org.springframework.core.task.support.TaskExecutorAdapter"&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;constructor-arg&gt;</span><br class="calibre10"/>   <span class="FontName">&lt;bean</span><br class="calibre10"/>    <span class="FontName">class="java.util.concurrent.Executors"</span><br class="calibre10"/>    <span class="FontName">factory-method="newCachedThreadPool" /&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;/constructor-arg&gt;</span><br class="calibre10"/> <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/> <span class="FontName">&lt;bean</span><br class="calibre10"/>  <span class="FontName">class="org.springframework.core.task.SimpleAsyncTaskExecutor"</span><br class="calibre10"/>  <span class="FontName">p:daemon="false" /&gt;</span>  <br class="calibre10"/> <span class="FontName">&lt;bean</span><br class="calibre10"/>  <span class="FontName">class="org.springframework.core.task.SyncTaskExecutor" /&gt;</span>  <br class="calibre10"/><span class="FontName">&lt;bean class="org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean" id="concurrentTaskScheduler"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="scheduledExecutorTasks"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;list&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;bean class="org.springframework.scheduling.concurrent.ScheduledExecutorTask"</span><br class="calibre10"/>                 <span class="FontName">p:period="1000"</span><br class="calibre10"/>                 <span class="FontName">p:runnable-ref="task"/&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/list&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;bean</span><br class="calibre10"/>  <span class="FontName">class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span><br class="calibre10"/>  <span class="FontName">p:corePoolSize="50"</span><br class="calibre10"/>  <span class="FontName">p:daemon="false"</span><br class="calibre10"/>  <span class="FontName">p:waitForTasksToCompleteOnShutdown="true"</span><br class="calibre10"/>  <span class="FontName">p:maxPoolSize="100"</span><br class="calibre10"/>  <span class="FontName">p:allowCoreThreadTimeOut="true" /&gt;</span>  <br class="calibre10"/> <span class="FontName">&lt;!—  client bean  —&gt;</span><br class="calibre10"/> <span class="FontName">&lt;bean</span><br class="calibre10"/>  <span class="FontName">id="springExecutorsDemo"</span><br class="calibre10"/>  <span class="FontName">class="com.apress.springrecipes.</span><br class="calibre10"/>        <span class="FontName">executors.SpringExecutorsDemo" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">The previous code shows different implementations of the <span class="FontName">TaskExecutor</span> interface. The first bean, the <span class="FontName">TaskExecutorAdapter</span><a id="cXXX.338" class="calibre5"></a> instance, is a simple wrapper around a <span class="FontName">java.util.concurrence.Executors</span> instance so you can deal with it in terms of the Spring <span class="FontName">TaskExecutor</span> interface. You use Spring here to configure an instance of an <span class="FontName">Executor</span> and pass it in as the constructor argument.</p>
<p class="indent"><span class="FontName">SimpleAsyncTaskExecutor</span><a id="cXXX.339" class="calibre5"></a> provides a new Thread for each submitted job. It does no thread pooling or reuse. Each job submitted runs asynchronously in a thread.</p>
<p class="indent"><span class="FontName">SyncTaskExecutor</span><a id="cXXX.340" class="calibre5"></a> is the simplest of the implementations of <span class="FontName">TaskExecutor</span>. Submission of a job is synchronous and tantamount to launching a Thread, running it, and then using <span class="FontName">join()</span> to connect it immediately. It’s effectively the same as manually invoking the <span class="FontName">run()</span> method in the calling thread, skipping threading all together.</p>
<p class="indent"><span class="FontName">ScheduledExecutorFactoryBean</span><a id="cXXX.341" class="calibre5"></a> automatically triggers jobs defined as <span class="FontName">ScheduledExecutorTask</span> beans. You can specify a list of <span class="FontName">ScheduledExecutorTask</span> instances to trigger multiple jobs simultaneously. A <span class="FontName">ScheduledExecutorTask</span> instance can accept a period to space out the execution of tasks.</p>
<p class="indent">The last example is <span class="FontName">ThreadPoolTaskExecutor</span>, which is a full-on thread pool implementation built on <span class="FontName">java.util.concurrent.ThreadPoolExecutor</span>.</p>
<p class="indent">If you want to build applications using the CommonJ WorkManager/TimerManager support available in application servers like IBM WebSphere, you can use <span class="FontName">org.springframework.scheduling.commonj.WorkManagerTaskExecutor</span>. This class delegates to a reference to the CommonJ Work Manager available inside of WebSphere. Usually, you’ll provide it with a JNDI reference to the appropriate resource. This works well enough (such as with Geronimo), but extra effort is required with JBoss or GlassFish. Spring provides classes that delegate to the JCA support provided on those servers: for GlassFish, use <span class="FontName">org.springframework.jca.work.glassfish.GlassFishWorkManagerTaskExecutor</span>; for JBoss, use <span class="FontName">org.springframework.jca.work.jboss.JBossWorkManagerTaskExecutor</span>.</p>
<p class="indent">The <span class="FontName">TaskExecutor</span> support provides a powerful way to access scheduling services on an application server via a unified interface. If you’re looking for more robust (albeit much more heavyweight) support that can be deployed on any app server (e.g., Tomcat and Jetty), you might consider Spring’s Quartz support.</p>
<p id="Sec135" class="Heading">Summary</p>
<p class="noindent">In this chapter, you learned about Spring’s core tasks associated with annotations. Instead of using the classical Spring XML POJO instantiation process, you learned how Spring supports the <span class="FontName">@Configuration</span> and <span class="FontName">@Bean</span> annotations to instantiate POJO via a Java config class. You also learned how to use the <span class="FontName">@Component</span> annotation to administer POJOs with Spring. In addition, you learned about the <span class="FontName">@Repository</span>, <span class="FontName">@Service</span>, and <span class="FontName">@Controller</span> annotations which provide more specific behavior than the <span class="FontName">@Component</span> annotation.</p>
<p class="indent">You also learned how to reference POJOs from other POJOs, as well as how to use the <span class="FontName">@Autowired</span> annotation which can automatically associate POJOs by either type or name. In addition, you also explored how the standard <span class="FontName">@Resource</span> and <span class="FontName">@Inject</span> annotations work to reference POJOs via autowiring, instead of using the Spring specific <span class="FontName">@Autowired</span> annotation.</p>
<p class="indent">You then learned how to set a Spring POJOs scope with the <span class="FontName">@Scope</span> annotation. You also learned how Spring can read external resources<a id="cXXX.2211" class="calibre5"></a> and use this data in the context of POJO configuration and creation using the <span class="FontName">@PropertySource</span> and <span class="FontName">@Value</span> annotations. In addition, you learned how Spring supports different languages in POJOs through the use of i18n resource bundles.</p>
<p class="indent">Next, you learned how to customize the initialization and destruction of POJOs with the <span class="FontName">initmethod</span> and <span class="FontName">destroyMethod</span> attributes of a <span class="FontName">@Bean</span> annotation, as well as the <span class="FontName">@PostConstruct</span> and <span class="FontName">@PreDestroy</span> annotations. In addition, you learned how to do lazy initialization with the <span class="FontName">@PreDestroy</span> annotation and define initialization dependencies with the <span class="FontName">@DependsOn</span> annotation.</p>
<p class="indent">You then learned about Spring post processors to validate and modify POJO values, including how to use the <span class="FontName">@Required</span> annotation. Next, you explored how to work with Spring environments and profiles to load different sets of POJOs, including how to use the <span class="FontName">@Profile</span> annotation.</p>
<p class="indent">Next, you explored aspect oriented programming in the context of Spring and learned how to create aspects, pointcuts, and advices. This included the use of the <span class="FontName">@Aspect</span> annotation, as well as the <span class="FontName">@Before</span>, <span class="FontName">@After</span>, <span class="FontName">@AfterReturning</span>, <span class="FontName">@AfterThrowing</span>, and <span class="FontName">@Around</span> annotations.</p>
<p class="indent">Next, you learned how to access AOP join point information and apply it to different program execution points. And then you learned how specify aspect precedence with the <span class="FontName">@Order</span> annotations, followed by how to reuse aspect pointcut definition.</p>
<p class="indent">In this chapter, you also learned how to write AspectJ pointcut expressions, as well as how to apply the concept of AOP ’introductions’ so a POJO can inherit behaviors from multiple implementation classes at the same time. You also learned how to introduce states to POJOs with AOP, as well as how to apply the technique of load-time weaving.</p>
<p class="indent">Finally, you learned how to configure AspectJ aspects in Spring, how to inject POJOs into domain objects, as well as how to deal with concurrency with Spring and TaskExecutors.</p></div>
</body></html>
