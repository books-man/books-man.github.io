<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Chapter 3 Spring Annotation Driven Core Tasks</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre"><p class="ChapterNumber"><a id="b9781430259084_3" class="calibre6"></a>CHAPTER 3</p>
<p class="Chapimage"><img src="../images/00008.jpeg" alt="image" class="calibre3"/></p>
<p class="ChapterTitle">Spring Annotation Driven Core Tasks<a id="cXXX.2210" class="calibre6"></a></p>
<div class="calibre10"><p class="noindent">In this chapter, you’ll learn about Spring’s annotation driven tasks<a id="cXXX.198" class="calibre5"></a>. Both annotation driven tasks and regular tasks — like the ones in the previous chapter — can achieve the same end results. The only difference between these types of tasks is how you setup an application and its POJOs (Plain Old Java Objects<a id="cXXX.2130" class="calibre5"></a>).</p>
<p class="indent">Annotations are declarations added to Java source code to associate configurations with a class or method. The general syntax for Java annotations is the <span class="FontName">@</span> symbol, followed by the annotation name and optional parameters inside parenthesis (e.g., <span class="FontName">@Component("sequenceGenerator")</span>).</p>
<p class="indent">This means that if you use an annotation driven task, setting up and configuring a POJO in Spring is as simple as decorating a POJO class or method with an annotation. Whereas if you use a regular task — like the ones described in <a href="part0010.html" class="calibre5">chapter 2</a> — setting up and configuring a POJO in Spring requires a separate XML configuration file, that’s also more verbose versus an annotation.</p>
<p class="indent">Spring annotation driven tasks have gained popularity because they’re simpler to use. However, this doesn’t mean the Spring regular tasks presented in the previous chapter are deprecated or irrelevant. Both types of tasks are supported in the latest Spring 3.2 version.</p>
<p class="indent">The first twelve recipes of this chapter represent equivalent solutions to the first twelve recipes in <a href="part0010.html" class="calibre5">Chapter 2</a>. This way you can compare both approaches and use the one you’re most comfortable with, since what can be a ‘simple’ and ‘less verbose’ approach for some can be ‘complex’ and ‘cryptic’ approach for others.</p>
<p class="indent">For the remaining recipes, such as when an annotation driven approach is an order of magnitude simpler to use than a regular approach (e.g., AOP) only a recipe in this chapter is presented. Similarly, when an annotation driven approach is not available or requires a custom annotation (e.g., Scripting beans), only <a href="part0010.html" class="calibre5">Chapter 2</a> contains the relevant recipe.</p>
<p class="indent">Therefore the recipes in <a href="part0010.html" class="calibre5">Chapter 2</a> and this chapter are complementary to one another.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Tip</b>  The source code download is organized to use <span class="FontName">gradle</span><a id="cXXX.199" class="calibre5"></a> to build the different Recipe applications. Gradle takes care of loading all the necessary Java classes, dependencies and creating an executable. <a href="part0009.html" class="calibre5">Chapter 1</a> describes how to setup the Gradle tool. Furthermore, if a Recipe illustrates more than one approach, the source code is classified with various examples with roman letters (e.g., <span class="FontName">Recipe_3_1_i</span>, <span class="FontName">Recipe_3_1_ii</span>, <span class="FontName">Recipe_3_1_iii</span>,etc).</p>
<p class="paraaftertitle">To build each application, go inside the Recipe directory (e.g., <span class="FontName">Ch3/Recipe_3_1_i/</span>) and execute the ./<span class="FontName">gradlew</span> command to compile the source code. Once the source code is compiled, a <span class="FontName">build/libs</span> sub-directory is created with the application executable. You can then run the application JAR from the command line (e.g., <span class="FontName">java -jar Recipe_3_1_i-1.0.SNAPSHOT.jar).</span></p></div>
<p id="Sec1" class="Heading">3-1. Using Java Config to configure POJOs</p>
<p id="Sec2" class="Heading1">Problem</p>
<p class="noindent">You <a id="cXXX.200" class="calibre5"></a>want to manage POJOs with annotations with Spring’s IoC container<a id="cXXX.2076" class="calibre5"></a><a id="cXXX.201" class="calibre5"></a>.</p>
<p id="Sec3" class="Heading1">Solution</p>
<p class="noindent">Design a POJO class. Next, create a Java Config class with a <span class="FontName">@Configuration</span> and <span class="FontName">@Bean</span> annotations to configure POJO instance values or setup Java components with <span class="FontName">@Component,@Repository,@Service</span> or <span class="FontName">@Controller</span> annotations to later create POJO instance values. Next, instantiate the Spring IoC container to scan for Java classes with annotations. The POJO instances or bean instances then become accessible to put together as part of an application.</p>
<p id="Sec4" class="Heading1">How It Works</p>
<p class="noindent">Suppose you’re going to develop an application to generate sequence numbers. And that you are also going to need many series of sequence numbers for different purposes. Each sequence will have its own prefix, suffix, and initial value. So you have to create and maintain multiple generator instances for the application.</p>
<p id="Sec5" class="Heading2">Create POJO Class to create beans with Java Config</p>
<p class="noindent">In accordance with the requirements, you create a <span class="FontName">SequenceGenerator</span><a id="cXXX.202" class="calibre5"></a> class that has three properties — <span class="FontName">prefix, suffix</span>, and <span class="FontName">initial</span>. You also create a private field <span class="FontName">counter</span> to store the numeric value of each generator. Each time you call the <span class="FontName">getSequence()</span> method on a generator instance, you get the last sequence number with the prefix and suffix joined. You declare this last method as synchronized to make it thread-safe.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">private String prefix;</span><br class="calibre10"/>    <span class="FontName">private String suffix;</span><br class="calibre10"/>    <span class="FontName">private int initial;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Constructors, Getters, and Setters</span><br class="calibre10"/>    <span class="FontName">// See Recipe 2-1 or book's source code</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Note this last <span class="FontName">SequenceGenerator</span> class can be instantiated by setter methods or by a standard Java constructor.</p>
<p id="Sec6" class="Heading2">Create Java Config with @Configuration and @Bean to creates POJOs</p>
<p class="noindent">To<a id="cXXX.203" class="calibre5"></a> define<a id="cXXX.204" class="calibre5"></a> instances of a POJO class in the Spring IoC container, you can create a Java Config class with instantiation values. A Java Config class with a POJO or bean definition<a id="cXXX.205" class="calibre5"></a> would look like this:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.sequence.SequenceGenerator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class SequenceGeneratorConfiguration {</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public SequenceGenerator sequenceGenerator() {</span><br class="calibre10"/>                      <span class="FontName">SequenceGenerator seqgen = new SequenceGenerator();</span><br class="calibre10"/>                      <span class="FontName">seqgen.setPrefix("30");</span><br class="calibre10"/>                      <span class="FontName">seqgen.setSuffix("A");</span><br class="calibre10"/>                      <span class="FontName">seqgen.setInitial("100000");</span><br class="calibre10"/>                      <span class="FontName">return seqgen;</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">This is equivalent to an XML configuration<a id="cXXX.206" class="calibre5"></a> with the following definition:</p>
<pre class="calibre11"><span class="FontName">&lt;bean name="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="prefix"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;30&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffix"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;A&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="initial"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;100000&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">Notice the Java Config class is decorated with the <span class="FontName">@Configuration</span> annotation, this tells Spring it’s a configuration class. When Spring encounters a class with the <span class="FontName">@Configuration</span> annotation it looks for bean instance definitions in the class, which are Java methods decorated with the <span class="FontName">@Bean</span> annotation. The Java methods create and return a bean instance.</p>
<p class="indent">Any method definitions decorated with the <span class="FontName">@Bean</span> annotation generate a bean name based on the method name. Alternatively, you can explicitly specify the bean name in the <span class="FontName">@Bean</span> annotation with the <span class="FontName">name</span> attribute (e.g., <span class="FontName">@Bean(name="mys1")</span>, makes the bean available as <span class="FontName">mys1</span>; NOTE: if you explicitly specify the bean name, the method name is ignored for purposes of bean creation).</p>
<p id="Sec7" class="Heading2">Instantiate the Spring IoC container<a id="cXXX.2069" class="calibre6"></a> to scan for annotations</p>
<p class="noindent">You have to instantiate the Spring IoC container<a id="cXXX.207" class="calibre5"></a> to scan for Java classes that contain annotations. In doing so, Spring detects <span class="FontName">@Configuration</span> and <span class="FontName">@Bean</span> annotations so you can later get bean instances from the IoC container itself.</p>
<p class="indent">Spring provides two types of IoC container implementations. The basic one is called bean factory<a id="cXXX.208" class="calibre5"></a>. The more advanced one is called application context<a id="cXXX.209" class="calibre5"></a>, which is compatible with the bean factory. Note the configuration files for these two types of IoC containers are identical.</p>
<p class="indent">The application context provides more advanced features than the bean factory while keeping the basic features compatible. Therefore, we strongly recommend using the application context for every application unless the resources of an application are restricted (e.g., such as when running Spring for an applet or a mobile device).</p>
<p class="indent">The interfaces for the bean factory and the application context are <span class="FontName">BeanFactory</span> and <span class="FontName">ApplicationContext</span>, respectively. The <span class="FontName">ApplicationContext</span> interface is a subinterface of <span class="FontName">BeanFactory</span> for maintaining compatibility.</p>
<p class="indent">Since <span class="FontName">ApplicationContext</span> is an interface, you have to instantiate an implementation of it. Spring has several application context implementations, we recommend you use <span class="FontName">GenericXmlApplicationContext</span> which is the newest and most flexible implementation. With this class you can load the XML configuration file from the classpath.</p>
<pre class="calibre11"><span class="FontName">ApplicationContext context = new GenericXmlApplicationContext ("appContext.xml");</span></pre><p class="indent">In this case, because a Java Config class is used to define bean instances, the XML configuration file <span class="FontName">appContext.xml</span> is different from the XML configuration files to create application contexts in the previous chapter — which contained bean instance<a id="cXXX.210" class="calibre5"></a> definitions. The <span class="FontName">appContext.xml</span> file just needs to specify which Java packages to scan for annotations:</p>
<pre class="calibre11"><span class="FontName">&lt;beans   xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:context="</span><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/context/spring-context-3.2.xsd" class="calibre5">http://www.springframework.org/schema/context/spring-context-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;context:component-scan base-package="com.apress.springrecipes.sequence.config" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Tip</b>  The use of <span class="FontName">&lt;context:component-scan&gt;</span> implicitly enables the functionality of <span class="FontName">&lt;context:annotation-config&gt;</span>. There is no need to include the <span class="FontName">&lt;context:annotation-config&gt;</span> element when using <span class="FontName">&lt;context:component-scan&gt;</span>.</p></div>
<p class="indent">Once the application context is instantiated, the object reference — in this case <span class="FontName">context</span> — provides an entry point to access the POJO instances or beans.</p>
<p id="Sec8" class="Heading2">Get POJO instances or beans from the IoC Container</p>
<p class="noindent">You can access beans from a Spring application context just like you did in the previous chapter:</p>
<pre class="calibre11"><span class="FontName">ApplicationContext context =  ... ;</span><br class="calibre10"/><span class="FontName">SequenceGenerator generator = context.getBean("sequenceGenerator",SequenceGenerator.class);</span></pre><p class="indent">A Main class to run the sequence generator application<a id="cXXX.211" class="calibre5"></a> would be the following:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span><br class="calibre10"/>            <span class="FontName">new GenericXmlApplicationContext("appContext.xml");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">SequenceGenerator generator = context.getBean("sequenceGenerator", SequenceGenerator.class);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">System.out.println(generator.getSequence());</span><br class="calibre10"/>        <span class="FontName">System.out.println(generator.getSequence());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">If everything is available in the Java classpath (the <span class="FontName">appContext.xml</span> file, SequenceGenerator POJO class and the Spring JAR dependencies), you should see the following output, along with some logging messages:</p>
<pre class="calibre11"><span class="FontName">30100000A</span><br class="calibre10"/><span class="FontName">30100001A</span></pre><p id="Sec9" class="Heading2">Create POJO Class with @Component<a id="cXXX.212" class="calibre6"></a> annotation to create beans with DAO</p>
<p class="noindent">Up<a id="cXXX.213" class="calibre5"></a> to this point, the Spring bean instantiations have been done hardcoding the values in either an XML configuration file (e.g., examples in <a href="part0010.html" class="calibre5">Chapter 2</a>) or a Java Config class (e.g., the previous example in this recipe). This was the preferred approach to simplify the Spring examples.</p>
<p class="indent">However, the POJO instantiation process for most applications is done from either a database or user input. So now it’s time to move forward and use a more real-world scenario. For this section, we’ll use a Domain class and a Data Access Object (DAO) class<a id="cXXX.214" class="calibre5"></a> to create POJOs. You still won’t need to setup a database — we’ll actually hardcode values in the DAO class — but familiarizing yourself with this type of application structure is important since it’s the basis for most real-world applications and future recipes.</p>
<p class="indent">Suppose you are asked to develop a sequence generator application like the one you did in the last section. We’ll need to modify the class structure slightly to accommodate a Domain class and DAO pattern. First, create a domain class <span class="FontName">Sequence</span> containing the <span class="FontName">id</span>, <span class="FontName">prefix</span>, and <span class="FontName">suffix</span> properties.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Sequence {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private String id;</span><br class="calibre10"/>    <span class="FontName">private String prefix;</span><br class="calibre10"/>    <span class="FontName">private String suffix;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Constructors, Getters, and Setters</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Then, you create an interface for the Data Access Object (DAO), which is responsible for accessing data from the database. The <span class="FontName">getSequence()</span> method loads a POJO or <span class="FontName">Sequence</span> object from a database table by its ID, while the <span class="FontName">getSequence()</span> method retrieves the next value of a particular database sequence.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface SequenceDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Sequence getSequence(String sequenceId);</span><br class="calibre10"/>    <span class="FontName">public int getNextValue(String sequenceId);</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In a production application, you would implement this DAO interface to use a data-access technology. But to simplify this example, we’ll implement a DAO with hardcode values in a <span class="FontName">Map</span> to store the sequence instances and values.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><span class="FontName">import java.util.Map;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Component("sequenceDao")</span><br class="calibre10"/><span class="FontName">public class SequenceDaoImpl implements SequenceDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Map&lt;String, Sequence&gt; sequences;</span><br class="calibre10"/>    <span class="FontName">private Map&lt;String, Integer&gt; values;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public SequenceDaoImpl() {</span><br class="calibre10"/>        <span class="FontName">sequences = new HashMap&lt;String, Sequence&gt;();</span><br class="calibre10"/>        <span class="FontName">sequences.put("IT", new Sequence("IT", "30", "A"));</span><br class="calibre10"/>        <span class="FontName">values = new HashMap&lt;String, Integer&gt;();</span><br class="calibre10"/>        <span class="FontName">values.put("IT", 100000);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Sequence getSequence(String sequenceId) {</span><br class="calibre10"/>        <span class="FontName">return sequences.get(sequenceId);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public synchronized int getNextValue(String sequenceId) {</span><br class="calibre10"/>        <span class="FontName">int value = values.get(sequenceId);</span><br class="calibre10"/>        <span class="FontName">values.put(sequenceId, value + 1);</span><br class="calibre10"/>        <span class="FontName">return value;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Observe how the <span class="FontName">SequenceDaoImpl</span> class is decorated with the <span class="FontName">@Component("sequenceDao")</span> annotation. This marks the class so Spring can create POJOs from it. The value inside the <span class="FontName">@Component</span> annotation defines the bean instance id, in this case <span class="FontName">sequenceDao</span>. If no bean value name is provided in the <span class="FontName">@Component</span> annotation, by the default bean name is assigned as the uncapitalized non-qualified class name. (e.g., For the <span class="FontName">SequenceDaoImpl</span> class the default bean name would be <span class="FontName">sequenceDaoImpl</span>).</p>
<p class="indent">A call to the <span class="FontName">getSequence</span> method returns the value of the given <span class="FontName">sequenceID</span>. And a call to the <span class="FontName">getNextValue</span> method creates a new value based on the value of the given <span class="FontName">sequenceID</span> and returns the new value.</p>
<div class="Singlethin">
<p class="Heading4a"><b class="calibre1">@COMPONENT, @REPOSITORY, @SERVICE OR @CONTROLLER ?</b></p>
<p class="box-left">POJOs are classified in application layers. In Spring these layers are three: persistence, service and presentation. @Component is a general purpose annotation to decorate POJOs for Spring detection. Whereas @Repository, @Service, and @Controller are specializations of @Component for more specific cases of POJOs associated with the persistence, service, and presentation layers.</p>
<p class="box-left">If you’re unsure about a POJOs purpose you can decorate it with the @Component annotation. However, it’s better to use the specialization annotations where possible, because these provide extra facilities based on a POJOs purpose (e.g., @Repository causes exceptions to be wrapped up as DataAccessExceptions which makes debugging easier).</p></div>
<p id="Sec10" class="Heading2">Instantiate the Spring IoC container with filters to scan for annotations</p>
<p class="noindent">By default, Spring detects all classes decorated with <span class="FontName">@Configuration</span>, <span class="FontName">@Bean</span>, <span class="FontName">@Component</span>, <span class="FontName">@Repository</span>, <span class="FontName">@Service</span>, and <span class="FontName">@Controller</span> annotations, among others. You can customize the scan process to include one or more include/exclude filters. This is helpful when a Java package has dozens or hundreds of classes. For certain Spring application contexts, it can be necessary to exclude or include POJOs with certain annotations. In addition, scanning every package class can slow down the process unnecessarily.</p>
<p class="indent">Spring supports four types of filter expressions<a id="cXXX.215" class="calibre5"></a>. The <span class="FontName">annotation</span> and <span class="FontName">assignable</span> types are to specify an annotation type and a class/interface for filtering. The <span class="FontName">regex</span> and <span class="FontName">aspectj</span> types allow you to specify a regular expression and an AspectJ pointcut expression for matching the classes. You can also disable the default filters with the <span class="FontName">use-default-filters</span> attribute.</p>
<p class="indent">For example, the following component scan includes all classes in the <span class="FontName">com.apress.springrecipes.sequence</span> whose name contains the word <span class="FontName">Dao</span> or <span class="FontName">Service</span>, and excludes the classes with the <span class="FontName">@Controller</span> annotation:</p>
<pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;context:component-scan base-package="com.apress.springrecipes.sequence"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;context:include-filter type="regex"</span><br class="calibre10"/>            <span class="FontName">expression="com\.apress\.springrecipes\.sequence\..*Dao.*" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;context:include-filter type="regex"</span><br class="calibre10"/>            <span class="FontName">expression="com\.apress\.springrecipes\.sequence\..*Service.*" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;context:exclude-filter type="annotation"</span><br class="calibre10"/>            <span class="FontName">expression="org.springframework.stereotype.Controller" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/context:component-scan&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans</span><span class="FontName">&gt;</span></pre><p class="indent">When applying <span class="FontName">include</span> filters to detect all classes whose name contains the word <span class="FontName">Dao</span> or <span class="FontName">Service</span>, even classes that don’t have annotations are auto-detected.</p>
<p id="Sec11" class="Heading2">Get POJO instances or beans<a id="cXXX.216" class="calibre6"></a> from the IoC Container</p>
<p class="noindent">Then, you can test the preceding components with the following Main class:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span><br class="calibre10"/>            <span class="FontName">new GenericXmlApplicationContext("appContext.xml");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">SequenceDao sequenceDao =</span><br class="calibre10"/>            <span class="FontName">(SequenceDao) context.getBean("sequenceDao");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">System.out.println(sequenceDao.getNextValue("IT"));</span><br class="calibre10"/>        <span class="FontName">System.out.println(sequenceDao.getNextValue("IT"));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec12" class="Heading2">Remove all XML type configuration files and use annotations<a id="cXXX.217" class="calibre6"></a> all around</p>
<p class="noindent">Up to this point, you still have an XML configuration file<a id="cXXX.218" class="calibre5"></a> that defines which packages to scan so Spring can detect annotations and create the necessary POJOs. But Spring can actually forgo the use XML configuration entirely, by specifying which packages to scan in the application context.</p>
<p class="indent">In addition to the <span class="FontName">GenericXMLApplicationContext</span> class used up to this point, Spring also has the <span class="FontName">AnnotationConfigApplicationContext</span> class which can be configured to scan packages for annotations and create the declared POJOs. The following Main class illustrated the use of <span class="FontName">AnnotationConfigApplicationContext</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();</span><br class="calibre10"/>        <span class="FontName">context.scan("com.apress.springrecipes.sequence");</span><br class="calibre10"/>        <span class="FontName">SequenceDao sequenceDao =</span><br class="calibre10"/>            <span class="FontName">(SequenceDao) context.getBean("sequenceDao");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">System.out.println(sequenceDao.getNextValue("IT"));</span><br class="calibre10"/>        <span class="FontName">System.out.println(sequenceDao.getNextValue("IT"));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Notice that after an instance of the <span class="FontName">AnnotationConfigApplicationContext</span> class is created, a call is made to the <span class="FontName">scan("com.apress.springrecipes.sequence")</span> method. This tells Spring to scan classes in the <span class="FontName">com.apress.springrecipes.sequence</span> package for annotations and create the declared POJOs. In addition to the <span class="FontName">scan()</span> method which inspects complete packages, you can also use the <span class="FontName">register()</span> method to inspect individual classes for annotations.</p>
<pre class="calibre11"><span class="FontName">context.register(SequenceDaoImpl.class,SequenceConfiguration.class)</span></pre><div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Tip</b>  You can use a mix of annotations and XML configuration files to configure Spring applications. You don’t necessarily need to use annotations or XML exclusively. Depending on personal preferences and the type of application, it can be easier to setup certain tasks with annotations and others with XML configuration files. Go with the approach that feels easiest and most readable to you. The source code for future chapters uses a mixed configuration approach to illustrate this concept.</p></div>
<p id="Sec13" class="Heading">3-2. Create POJOs by Invoking a Constructor</p>
<p id="Sec14" class="Heading1">Problem</p>
<p class="noindent">You would like to create a POJO instance or bean in the Spring IoC container<a id="cXXX.2204" class="calibre5"></a> by invoking its constructor<a id="cXXX.219" class="calibre5"></a>, which is the most common and direct way of creating beans. It is equivalent to using the <span class="FontName">new</span> operator to create objects in Java.</p>
<p id="Sec15" class="Heading1">Solution</p>
<p class="noindent">Define a POJO class with a constructor or constructors. Next, create a Java Config class to configure POJO instance values with constructors for the Spring IoC container. Next, instantiate the Spring IoC container to scan for Java classes with annotations. The POJO instances or bean instances become accessible to put together as part of an application.</p>
<p id="Sec16" class="Heading1">How It Works</p>
<p class="noindent">Suppose you’re going to develop a shop application to sell products online. First of all, you create the <span class="FontName">Product</span> POJO class, which has several properties, such as the product name and price. As there are many types of products in your shop, you make the <span class="FontName">Product</span> class<a id="cXXX.220" class="calibre5"></a> abstract to extend it for different product subclasses.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public abstract class Product {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private String name;</span><br class="calibre10"/>    <span class="FontName">private double price;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Product() {}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Product(String name, double price) {</span><br class="calibre10"/>        <span class="FontName">this.name = name;</span><br class="calibre10"/>        <span class="FontName">this.price = price;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Getters and Setters</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public</span> <span class="FontName">String toString() {</span><br class="calibre10"/>        <span class="FontName">return name + " " + price;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec17" class="Heading2">Create the POJO Classes with Constructors</p>
<p class="noindent">Then you create two product subclasses, <span class="FontName">Battery</span> and <span class="FontName">Disc</span><a id="cXXX.221" class="calibre5"></a>. Each of them has its own properties.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Battery extends Product {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private boolean rechargeable;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Battery() {</span><br class="calibre10"/>        <span class="FontName">super();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Battery(String name, double price) {</span><br class="calibre10"/>        <span class="FontName">super(name, price);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Getters and Setters</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Disc extends Product {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private int capacity;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Disc() {</span><br class="calibre10"/>        <span class="FontName">super();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Disc(String name, double price) {</span><br class="calibre10"/>        <span class="FontName">super(name, price);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Getters and Setters</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec18" class="Heading2">Create Java Config for your POJO</p>
<p class="noindent">To define instances of a POJO class in the Spring IoC container, you have to create a Java Config class<a id="cXXX.222" class="calibre5"></a> with instantiation values. A Java Config class with POJO or bean definition made by invoking constructors would look like this:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.shop.Product;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.shop.Disc;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.shop.Battery;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class ShopConfiguration {</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Product aaa() {</span><br class="calibre10"/>           <span class="FontName">Battery p1 = new Battery();</span><br class="calibre10"/>           <span class="FontName">p1.setName("AAA");</span><br class="calibre10"/>           <span class="FontName">p1.setPrice(2.5);</span><br class="calibre10"/>           <span class="FontName">p1.setRechargeable(true);</span><br class="calibre10"/>           <span class="FontName">return p1;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">Public Product cdrw() {</span><br class="calibre10"/>           <span class="FontName">Disc p2 = new Disc("CD-RW",1.5);</span><br class="calibre10"/>           <span class="FontName">p2.setCapacity(700);</span><br class="calibre10"/>           <span class="FontName">return p2;</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">To create the beans you’ll have to create an XML file to tell Spring to scan the <span class="FontName">com.apress.springrecipes.shop.config</span> package.</p>
<pre class="calibre11"><span class="FontName">&lt;beans   xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:context="</span><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/context/spring-context-3.2.xsd" class="calibre5">http://www.springframework.org/schema/context/spring-context-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;context:component-scan base-package="com.apress.springrecipes.shop.config" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">Next<a id="cXXX.223" class="calibre5"></a>, you can write the following <span class="FontName">Main</span> class to test your products by retrieving them from the Spring IoC container:</p>
<pre class="calibre11"><span class="FontName">package</span> <span class="FontName">com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) throws Exception {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span><br class="calibre10"/>            <span class="FontName">new GenericXmlApplicationContext("appContext.xml");</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Product aaa = context.getBean("aaa",Product.class);</span><br class="calibre10"/>        <span class="FontName">Product cdrw = context.getBean("cdrw",Product.class);</span><br class="calibre10"/>        <span class="FontName">System.out.println(aaa);</span><br class="calibre10"/>        <span class="FontName">System.out.println(cdrw);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec19" class="Heading">3-3. Use POJO References and Auto-Wiring to Interact with other POJOs</p>
<p id="Sec20" class="Heading1">Problem</p>
<p class="noindent">The POJO instances or beans that make up an application often need to collaborate with each other to complete the application’s functions. You want to use annotations to use POJO references and auto-wiring.</p>
<p id="Sec21" class="Heading1">Solution</p>
<p class="noindent">For POJO instances defined in a Java config class you can use standard Java code to create references between beans. To auto-wire POJO references you can mark a field, a setter method, a constructor, or even an arbitrary method with the <span class="FontName">@Autowired</span> annotation.</p>
<p id="Sec22" class="Heading1">How It Works</p>
<p id="Sec23" class="Heading2">Reference<a id="cXXX.224" class="calibre6"></a> POJOs<a id="cXXX.225" class="calibre6"></a> in a Java config class<a id="cXXX.226" class="calibre6"></a></p>
<p class="noindent">When POJO instances are defined in a Java config class — as illustrated in Recipe 3-1 and Recipe 3-2 — POJO references are straightforward to use because everything is Java code. Take for example, when a bean property references another bean.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class SequenceConfiguration {</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public DatePrefixGenerator datePrefixGenerator() {</span><br class="calibre10"/>           <span class="FontName">DatePrefixGenerator dpg = new DatePrefixGenerator();</span><br class="calibre10"/>           <span class="FontName">dpg.setPattern("yyyyMMdd");</span><br class="calibre10"/>           <span class="FontName">return dpg;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public SequenceGenerator sequenceGenerator() {</span><br class="calibre10"/>           <span class="FontName">SequenceGenerator sequence= new SequenceGenerator();</span><br class="calibre10"/>           <span class="FontName">sequence.setInitial(100000);</span><br class="calibre10"/>           <span class="FontName">sequence.setSuffix("A");</span><br class="calibre10"/>           <span class="FontName">sequence.setPrefixGenerator(datePrefixGenerator());</span><br class="calibre10"/>           <span class="FontName">return sequence;</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The <span class="FontName">prefixGenerator</span> property of the <span class="FontName">SequenceGenerator</span> class is an instance of a <span class="FontName">DatePrefixGenerator</span> bean. The first bean declaration creates a <span class="FontName">DatePrefixGenerator</span> POJO. By convention, the bean becomes accessible with the bean name <span class="FontName">datePrefixGenerator</span> (i.e., the method name). But since the bean instantiation logic is also a standard Java method, the bean is also accessible making a standard Java call. When the <span class="FontName">prefixGenerator</span> property is set — in the second bean, via a setter — a standard Java call is made to the method <span class="FontName">datePrefixGenerator()</span> to reference the bean.</p>
<p id="Sec24" class="Heading2">Auto-wire POJO fields<a id="cXXX.227" class="calibre6"></a> with the @Autowired annotation<a id="cXXX.228" class="calibre6"></a><a id="cXXX.229" class="calibre6"></a></p>
<p class="noindent">Next, let’s use auto-wiring on the <span class="FontName">SequenceDao</span> field of the DAO <span class="FontName">SequenceDaoImpl</span> class introduced in the second part of Recipe 3-1. We’ll add a service class to the application to illustrate auto-wiring with the DAO class.</p>
<p class="indent">A service class to generate service objects is another real world application best practice, which acts as a façade to access DAO objects — instead of accessing DAO objects directly. Internally, the service object interacts with the DAO to handle the sequence generation requests.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class SequenceService {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private SequenceDao sequenceDao;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setSequenceDao(SequenceDao sequenceDao) {</span><br class="calibre10"/>        <span class="FontName">this.sequenceDao = sequenceDao;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public String generate(String sequenceId) {</span><br class="calibre10"/>        <span class="FontName">Sequence sequence = sequenceDao.getSequence(sequenceId);</span><br class="calibre10"/>        <span class="FontName">int value = sequenceDao.getNextValue(sequenceId);</span><br class="calibre10"/>        <span class="FontName">return sequence.getPrefix() + value + sequence.getSuffix();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The <span class="FontName">SequenceService</span> class is decorated with the <span class="FontName">@Component</span> annotation. This allows Spring to detect the POJO. Because the <span class="FontName">@Component</span> annotation has no name, the default bean name is <span class="FontName">sequenceService</span> which is based on the class name.</p>
<p class="indent">The <span class="FontName">sequenceDao</span> property of the <span class="FontName">SequenceService</span> class is decorated with the <span class="FontName">@Autowired</span> annotation. This allows Spring to auto-wire the property with the <span class="FontName">sequenceDao</span> bean (i.e., the <span class="FontName">SequenceDaoImpl</span> class)</p>
<p class="indent">Once the POJO classes are annotated with the previous annotations, an XML configuration file has to be setup to tell Spring which packages to scan for annotations — this process is identical to the previous recipes. Then, you can test the components with a Main class like the one used in previous recipes.</p>
<p class="indent">The <span class="FontName">@Autowired</span> annotation can also be applied to a property of an array type to have Spring auto-wire all the matching beans. For example, you can annotate a <span class="FontName">PrefixGenerator[]</span> property with <span class="FontName">@Autowired</span>. Then, Spring will auto-wire all the beans whose type is compatible with <span class="FontName">PrefixGenerator</span> at one time.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private PrefixGenerator[] prefixGenerators;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">If you have multiple beans whose type is compatible with the <span class="FontName">PrefixGenerator</span> defined in the IoC container, they will be added to the prefixGenerators array automatically.</p>
<p class="indent">In a similar way, you can apply the <span class="FontName">@Autowired</span> annotation to a type-safe collection. Spring can read the type information of this collection and auto-wire all the beans whose type is compatible.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private List&lt;PrefixGenerator&gt; prefixGenerators;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">If Spring notices that the <span class="FontName">@Autowired</span> annotation is applied to a type-safe <span class="FontName">java.util.Map</span> with strings as the keys, it will add all the beans of the compatible type, with the bean names as the keys, to this map.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private Map&lt;String, PrefixGenerator&gt; prefixGenerators;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec25" class="Heading2">Auto-wire POJO methods and constructors<a id="cXXX.230" class="calibre6"></a> with the @Autowired annotation and make auto-wiring optional<a id="cXXX.231" class="calibre6"></a></p>
<p class="noindent">The <span class="FontName">@Autowired</span> annotation can also be applied directly to the setter method of a POJO. As an example, you can annotate the setter method of the <span class="FontName">prefixGenerator</span> property with <span class="FontName">@Autowired</span>. Then, Spring attempts to wire a bean whose type is compatible with <span class="FontName">prefixGenerator</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">public void setPrefixGenerator(PrefixGenerator prefixGenerator) {</span><br class="calibre10"/>        <span class="FontName">this.prefixGenerator = prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">By default, all the properties with <span class="FontName">@Autowired</span> are required. When Spring can’t find a matching bean to wire, it will throw an exception. If you want a certain property to be optional, set the required attribute of <span class="FontName">@Autowired</span> to <span class="FontName">false</span>. Then, when Spring can’t find a matching bean, it will leave this property unset.</p>
<pre class="calibre11"><span class="FontName">package</span> <span class="FontName">com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Autowired(required=false)</span><br class="calibre10"/>    <span class="FontName">public void setPrefixGenerator(PrefixGenerator prefixGenerator) {</span><br class="calibre10"/>        <span class="FontName">this.prefixGenerator = prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">You may also apply the <span class="FontName">@Autowired</span> annotation to a method with an arbitrary name and an arbitrary number of arguments, and, in that case, Spring attempts to wire a bean with the compatible type for each of the method arguments.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">public void myOwnCustomInjectionName(PrefixGenerator prefixGenerator) {</span><br class="calibre10"/>        <span class="FontName">this.prefixGenerator = prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec26" class="Heading2">Resolve auto-wire ambiguity<a id="cXXX.2165" class="calibre6"></a><a id="cXXX.232" class="calibre6"></a> with the @Qualifier annotation</p>
<p class="noindent">By<a id="cXXX.233" class="calibre5"></a><a id="cXXX.234" class="calibre5"></a> default, auto-wiring by type will not work when there is more than one bean with the compatible type in the IoC container and the property isn’t a group type (e.g., array, list, map), as illustrated previously. However, there are two workarounds to auto-wiring by type if there’s more than one bean of the same type, the @Primary annotation and the @Qualifier annotation.</p>
<p id="Sec27" class="Heading2">Resolve auto-wire ambiguity with the @Primary annotation</p>
<p class="noindent">Spring<a id="cXXX.235" class="calibre5"></a><a id="cXXX.236" class="calibre5"></a> allows you to specify a candidate bean by type decorating the candidate with the <span class="FontName">@Primary</span> annotation. The <span class="FontName">@Primary</span> annotation gives preference to a bean when multiple candidates are qualified to autowire a single-valued dependency.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Primary;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">@Primary</span><br class="calibre10"/><span class="FontName">public class DatePrefixGenerator implements PrefixGenerator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public String getPrefix() {</span><br class="calibre10"/>        <span class="FontName">DateFormat formatter = new SimpleDateFormat("yyyyMMdd");</span><br class="calibre10"/>        <span class="FontName">return formatter.format(new Date());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Notice the previous POJO implements the <span class="FontName">PrefixGenerator</span> interface and is decorated with the <span class="FontName">@Primary</span> annotation. If you attempted to autowire a bean with a <span class="FontName">PrefixGenerator</span> type, even if Spring had more than one bean instance with the same <span class="FontName">PrefixGenerator</span> type, Spring would autowire the <span class="FontName">DatePrefixGenerator</span> because it’s marked with the <span class="FontName">@Primary</span> annotation.</p>
<p id="Sec28" class="Heading2">Resolve auto-wire ambiguity with the @Qualifier annotation</p>
<p class="noindent">Spring also allows you to specify a candidate bean by type providing its name in the <span class="FontName">@Qualifier</span> annotation.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Qualifier;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">@Qualifier("datePrefixGenerator")</span><br class="calibre10"/>    <span class="FontName">private PrefixGenerator prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Once you’ve done this, Spring attempts to find a bean with that name in the IoC container and wire it into the property.</p>
<p class="indent">The <span class="FontName">@Qualifier</span> annotation can also be applied to a method argument for auto-wiring.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Qualifier;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">public void myOwnCustomInjectionName(</span><br class="calibre10"/>            <span class="FontName">@Qualifier("datePrefixGenerator") PrefixGenerator prefixGenerator) {</span><br class="calibre10"/>        <span class="FontName">this.prefixGenerator = prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">If you want to auto-wire bean properties by name, you can annotate a setter method, a constructor, or a field with the JSR-250 <span class="FontName">@Resource</span> annotation described in the next recipe.</p>
<p id="Sec29" class="Heading2">Resolve POJO References from multiple locations</p>
<p class="noindent">As an application grows it can become difficult to manage every POJO in a single Java Configuration class.<a id="cXXX.2070" class="calibre5"></a><a id="cXXX.2075" class="calibre5"></a> A common practice is to separate POJOs into multiple Java Configuration classes according to their functionalities. When you create multiple Java Configuration classes, obtaining references and auto-wiring POJOs that are defined in different classes isn’t as straightforward as when everything is in a single Java Configuration class.</p>
<p class="indent">One approach is to initialize the application context with the location of each Java Configuration class. In this manner, the POJOs for each Java configuration class are loaded into the context and references and autowiring between POJOs is possible.</p>
<pre class="calibre11"><span class="FontName">AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();</span><br class="calibre10"/><span class="FontName">context.register({"SequenceConfiguration.class","PrefixConfiguration.class"});</span><br class="calibre10"/><span class="FontName">context.refresh();</span></pre><p class="indent">Another alternative is to use the <span class="FontName">@Import</span> annotation<a id="cXXX.237" class="calibre5"></a> so Spring makes the POJOs from one configuration file available in another.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Import;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Value;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.sequence.SequenceGenerator;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.sequence.PrefixGenerator;</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">@Import(PrefixConfiguration.class)</span><br class="calibre10"/><span class="FontName">public class SequenceConfiguration {</span><br class="calibre10"/>        <span class="FontName">@Value("#{datePrefixGenerator}")</span><br class="calibre10"/>        <span class="FontName">private PrefixGenerator prefixGenerator;</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public SequenceGenerator sequenceGenerator() {</span><br class="calibre10"/>           <span class="FontName">SequenceGenerator sequence= new SequenceGenerator();</span><br class="calibre10"/>           <span class="FontName">sequence.setInitial(100000);</span><br class="calibre10"/>           <span class="FontName">sequence.setSuffix("A");</span><br class="calibre10"/>           <span class="FontName">sequence.setPrefixGenerator(prefixGenerator);</span><br class="calibre10"/>           <span class="FontName">return sequence;</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The <span class="FontName">sequenceGenerator</span> bean requires to set a <span class="FontName">prefixGenerator</span> bean. But notice no <span class="FontName">prefixGenerator</span> bean is defined in the Java Configuration class. The <span class="FontName">prefixGenerator</span> bean is defined in a separate Java Configuration class <span class="FontName">PrefixConfiguration</span>.</p>
<p class="indent">With the <span class="FontName">@Import(PrefixConfiguration.class)</span> annotation, Spring brings all the POJOs in the Java Configuration class into the scope of the present Configuration class. With the POJOs from <span class="FontName">PrefixConfiguration</span> in scope, we use the <span class="FontName">@Value</span> annotation and SpEL to inject the bean named <span class="FontName">datePrefixGenerator</span> into the <span class="FontName">prefixGenerator</span> field. Once the bean is injected it can be used to set a <span class="FontName">prefixGenerator</span> bean for the <span class="FontName">sequenceGenerator</span> bean.</p>
<p id="Sec30" class="Heading">3-4. Auto-wire POJOs the @Resource and @Inject annotation</p>
<div class="Singlethin">
<p class="Heading4a"><b class="calibre1">POJOS WITH ANNOTATIONS AND JAVA COLLECTION ATTRIBUTES</b></p>
<p class="box-left">Recipe 3-4 won’t describe how to configure POJOs with Java collection attributes<a id="cXXX.2071" class="calibre5"></a><a id="cXXX.2072" class="calibre5"></a>, like Recipe 2-4 described this process with XML configuration files.</p>
<p class="box-left">POJOs with annotations that use Java collection attributes don’t require any specific technique. Java config classes<a id="cXXX.2150" class="calibre5"></a> use standard Java syntax and can therefore use standard Java collection code. And to reference Java collection attributes you can create multiple bean instances of the same type and use auto-wiring to automatically group the different beans into a group or collection — this last technique is illustrated in Recipe 3-3.</p></div>
<p id="Sec31" class="Heading1">Problem</p>
<p class="noindent">You want to use the Java standard <span class="FontName">@Resource</span> and <span class="FontName">@Inject</span> annotations to reference POJOs<a id="cXXX.2148" class="calibre5"></a> via autowiring, instead of the Spring specific <span class="FontName">@Autowired</span> annotation.</p>
<p id="Sec32" class="Heading1">Solution</p>
<p class="noindent">JSR-250 or Common Annotations for the Java Platform defines the <span class="FontName">@Resource</span> annotation to autowire POJO references by name. The JSR-330 or Standard Annotations for injection defines the <span class="FontName">@Inject</span> annotations to autowire POJO references by type.</p>
<p id="Sec33" class="Heading1">How It Works</p>
<p class="noindent">The <span class="FontName">@Autowired</span> annotation described in the previous recipe belongs to the Spring framework, specifically to the <span class="FontName">org.springframework.beans.factory.annotation</span> package. This means it can only be used in the context of the Spring framework.</p>
<p class="indent">Soon after Spring added support for the <span class="FontName">@Autowired</span> annotation, the Java language itself standardized various annotations to fulfill the same purpose of the <span class="FontName">@Autowired</span> annotation. These annotations are <span class="FontName">@Resource</span> which belongs to the <span class="FontName">javax.annotation</span> package and <span class="FontName">@Inject</span> which belongs to the <span class="FontName">javax.inject</span> package.</p>
<p id="Sec34" class="Heading2">Auto-wire POJOs with the @Resource annotation<a id="cXXX.238" class="calibre6"></a><a id="cXXX.239" class="calibre6"></a></p>
<p class="noindent">By default, the <span class="FontName">@Resource</span> annotation works like Spring’s <span class="FontName">@Autowired</span> annotation and attempts to autowire by type. For example, the following POJO attribute is decorated with the <span class="FontName">@Resource</span> annotation and so Spring attempts to locate a POJO that matches the <span class="FontName">PrefixGenerator</span> type.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.annotation.Resource;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Resource</span><br class="calibre10"/>    <span class="FontName">private PrefixGenerator prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">However, unlike the <span class="FontName">@Autowired</span> annotation which requires the <span class="FontName">@Qualifier</span> annotation to autowire a POJO by name, the <span class="FontName">@Resource</span> ambiguity is eliminated if more than one POJO type of the same kind exists. Essentially, the <span class="FontName">@Resource</span> annotation provides the same functionality as putting together the <span class="FontName">@Autowired</span> annotation and <span class="FontName">@Qualifier</span> annotation.</p>
<p id="Sec35" class="Heading2">Auto-wire POJOs with the @Inject annotation<a id="cXXX.240" class="calibre6"></a><a id="cXXX.241" class="calibre6"></a></p>
<p class="noindent">By, the <span class="FontName">@Inject</span> annotation also attempts to autowire by type, like the <span class="FontName">@Resource</span> and <span class="FontName">@Autowired</span> annotations. For example, the following POJO attribute is decorated with the <span class="FontName">@Inject</span> annotation and so Spring attempts to locate a POJO that matches the <span class="FontName">PrefixGenerator</span> type.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.inject.Inject;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Inject</span><br class="calibre10"/>    <span class="FontName">private PrefixGenerator prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">But just like the <span class="FontName">@Resource</span> and <span class="FontName">@Autowired</span> annotations, a different approach has to be used to match POJOs by name or avoid ambiguity if more than one POJO type of the same kind exists.</p>
<p class="indent">The first step to do autowiring by name with the <span class="FontName">@Inject</span> annotation is to create a custom annotation to identify both the POJO injection class and POJO injection point.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.lang.annotation.Documented;</span><br class="calibre10"/><span class="FontName">import java.lang.annotation.ElementType;</span><br class="calibre10"/><span class="FontName">import java.lang.annotation.Retention;</span><br class="calibre10"/><span class="FontName">import java.lang.annotation.RetentionPolicy;</span><br class="calibre10"/><span class="FontName">import java.lang.annotation.Target;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.inject.Qualifier;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Qualifier</span><br class="calibre10"/><span class="FontName">@Target({ElementType.TYPE, ElementType.FIELD, ElementType.PARAMETER})</span><br class="calibre10"/><span class="FontName">@Documented</span><br class="calibre10"/><span class="FontName">@Retention(RetentionPolicy.RUNTIME)</span><br class="calibre10"/><span class="FontName">public @interface DatePrefixAnnotation {</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Notice the custom annotation makes use of the <span class="FontName">@Qualifier</span> annotation. This annotation is different from the one used with Spring’s <span class="FontName">@Qualifier</span> annotation, as this last class belongs to the same Java package as the <span class="FontName">@Inject</span> annotation (i.e., <span class="FontName">javax.inject</span>)</p>
<p class="indent">Once the custom annotation is done, it’s necessary to decorate the POJO injection class that generates the bean instance, which in this case is the <span class="FontName">DatePrefixGenerator</span> class.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">@DatePrefixAnnotation</span><br class="calibre10"/><span class="FontName">public class DatePrefixGenerator implements PrefixGenerator {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Finally, the POJO attribute or injection point is decorated with the same custom annotation to qualify the POJO and eliminate any ambiguity.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.inject.Inject;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Inject @DataPrefixAnnotation</span><br class="calibre10"/>    <span class="FontName">private PrefixGenerator prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><div class="Singlethin">
<p class="Heading4a"><b class="calibre1">@AUTOWIRED, @RESOURCE OR @INJECT ?</b></p>
<p class="box-left">As you’ve seen in Recipes 3-3 and 3-4, the three annotations @Autowired, @Resource and @Inject can achieve the same result. The @Autowired annotation is a Spring based solution, whereas the @Resource and @Inject annotations are Java standard (i.e., JSR) based solutions.</p>
<p class="box-left">If you’re going to do name based autowiring, the @Resource annotation offers the simplest syntax. For autowiring by class type, all three annotations are as straightforward to use because all three require a single annotation.</p></div>
<p id="Sec36" class="Heading">3-5. Set a POJOs Scope with the @Scope annotation<a id="cXXX.242" class="calibre6"></a></p>
<p id="Sec37" class="Heading1">Problem</p>
<p class="noindent">When you declare a POJO instance with an annotation like <span class="FontName">@Component</span>, you are actually defining a template for bean creation, not an actual bean instance. When a bean is requested by the <span class="FontName">getBean()</span> method or a reference from other beans, Spring decides which bean instance should be returned according to the bean scope. Sometimes, you have to set an appropriate scope for a bean other than the default scope.</p>
<p id="Sec38" class="Heading1">Solution</p>
<p class="noindent">A bean’s scope is set in the scope is set with the <span class="FontName">@Scope</span> annotation. By default, Spring creates exactly one instance for each bean declared in the IoC container, and this instance is shared in the scope of the entire IoC container. This unique bean instance is returned for all subsequent <span class="FontName">getBean()</span> calls and bean references. This scope is called singleton, which is the default scope of all beans. <a id="_Tab1" href="part0012.html#Tab1" class="calibre5">Table 3-1</a> lists all valid bean scopes in Spring.</p>
<div class="Table" id="Tab1">
<p class="TabCapt"><span class="calibre4"><a href="part0012.html#_Tab1" class="calibre5">Table 3-1</a>.</span> Valid Bean Scopes in Spring<a id="cXXX.243" class="calibre5"></a></p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">Scope</p></th><th valign="top" class="calibre14">
<p class="tab-left">Description</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">singleton</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">Creates a single bean instance per Spring IoC container</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">prototype</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">Creates a new bean instance each time when requested</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">request</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">Creates a single bean instance per HTTP request; only valid in the context of a web application</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">session</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">Creates a single bean instance per HTTP session; only valid in the context of a web application</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">globalSession</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">Creates a single bean instance per global HTTP session; only valid in the context of a portal application</p></td></tr></tbody></table>
</div>
<p id="Sec39" class="Heading1">How It Works</p>
<p class="noindent">To demonstrate the concept of bean scope, let’s consider a shopping cart example in a shopping application. First, you create the <span class="FontName">ShoppingCart</span> class as follows:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class ShoppingCart {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private List&lt;Product&gt; items = new ArrayList&lt;Product&gt;();</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void addItem(Product item) {</span><br class="calibre10"/>        <span class="FontName">items.add(item);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public List&lt;Product&gt; getItems() {</span><br class="calibre10"/>        <span class="FontName">return items;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Then you declare some product beans in a Java config file so they can later be added to the shopping cart:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class ShopConfiguration {</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Product aaa() {</span><br class="calibre10"/>           <span class="FontName">Battery p1 = new Battery();</span><br class="calibre10"/>           <span class="FontName">p1.setName("AAA");</span><br class="calibre10"/>           <span class="FontName">p1.setPrice(2.5);</span><br class="calibre10"/>           <span class="FontName">p1.setRechargeable(true);</span><br class="calibre10"/>           <span class="FontName">return p1;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Product cdrw() {</span><br class="calibre10"/>           <span class="FontName">Disc p2 = new Disc("CD-RW",1.5);</span><br class="calibre10"/>           <span class="FontName">p2.setCapacity(700);</span><br class="calibre10"/>           <span class="FontName">return p2;</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Next, you declare the necessary statements to scan packages that contain annotations inside a Spring XML configuration file.</p>
<pre class="calibre11"> <span class="FontName">&lt;context:component-scan base-package="com.apress.springrecipes.shop.config" /&gt;</span><br class="calibre10"/>   <span class="FontName">&lt;context:component-scan base-package="com.apress.springrecipes.shop"&gt;</span><br class="calibre10"/>      <span class="FontName">&lt;context:include-filter type="regex" expression="com\.apress\.      springrecipes\.shop\..*ShoppingCart.*" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/context:component-scan&gt;</span></pre><p class="indent">Once you do this, you can define a <span class="FontName">Main</span> class to test the shopping cart by adding some products to it. Suppose there are two customers navigating in your shop at the same time. The first one gets a shopping cart by the <span class="FontName">getBean()</span> method and adds two products to it. Then, the second customer also gets a shopping cart by the <span class="FontName">getBean()</span> method and adds another product to it.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span><br class="calibre10"/>            <span class="FontName">new GenericXmlApplicationContext("appContext.xml");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Product aaa = (Product) context.getBean("aaa");</span><br class="calibre10"/>        <span class="FontName">Product cdrw = (Product) context.getBean("cdrw");</span><br class="calibre10"/>        <span class="FontName">Product dvdrw = (Product) context.getBean("dvdrw");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">ShoppingCart cart1 = (ShoppingCart) context.getBean("shoppingCart");</span><br class="calibre10"/>        <span class="FontName">cart1.addItem(aaa);</span><br class="calibre10"/>        <span class="FontName">cart1.addItem(cdrw);</span><br class="calibre10"/>        <span class="FontName">System.out.println("Shopping cart 1 contains " + cart1.getItems());</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">ShoppingCart cart2 = (ShoppingCart) context.getBean("shoppingCart");</span><br class="calibre10"/>        <span class="FontName">cart2.addItem(dvdrw);</span><br class="calibre10"/>        <span class="FontName">System.out.println("Shopping cart 2 contains " + cart2.getItems());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">As a result of the preceding bean declaration, you can see that the two customers get the same shopping cart instance.</p>
<pre class="calibre11"><span class="FontName">Shopping cart 1 contains [AAA 2.5, CD-RW 1.5]</span><br class="calibre10"/><span class="FontName">Shopping cart 2 contains [AAA 2.5, CD-RW 1.5, DVD-RW 3.0]</span></pre><p class="indent">This is because Spring’s default bean scope is <span class="FontName">singleton</span>, which means Spring creates exactly one shopping cart instance per IoC container.</p>
<p class="indent">In your shop application, you expect each customer to get a different shopping cart instance when the <span class="FontName">getBean()</span> method is called. To ensure this behavior, the scope of the shoppingCart bean needs to be set to <span class="FontName">prototype</span>. Then Spring creates a new bean instance for each <span class="FontName">getBean()</span> method call.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Scope;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">@Scope("prototype")</span><br class="calibre10"/><span class="FontName">public class ShoppingCart {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private List&lt;Product&gt; items = new ArrayList&lt;Product&gt;();</span><br class="calibre10"/>    <span class="FontName">...</span></pre><p class="indent">Now if you run the <span class="FontName">Main</span> class again, you can see the two customers get a different shopping cart instance.</p>
<pre class="calibre11"><span class="FontName">Shopping cart 1 contains [AAA 2.5, CD-RW 1.5]</span><br class="calibre10"/><span class="FontName">Shopping cart 2 contains [DVD-RW 3.0]</span></pre><p id="Sec40" class="Heading">3-6. Use data from External Resources (Text files, XML files, properties files, or image files)</p>
<p id="Sec41" class="Heading1">Problem</p>
<p class="noindent">Sometimes, applications need to read external resources (e.g., text files, XML files, properties file, or image files) from different locations (e.g., a file system, classpath, or URL). Usually, you have to deal with different APIs for loading resources from different locations.</p>
<p id="Sec42" class="Heading1">Solution</p>
<p class="noindent">Spring<a id="cXXX.244" class="calibre5"></a> offers the <span class="FontName">@PropertySource</span> annotation as a facility to load the contents of <span class="FontName">.properties</span> file (i.e., key-value pairs) to set up bean properties.</p>
<p class="indent">Spring also has a resource loader mechanism which provides a unified <span class="FontName">Resource</span> interface to retrieve any type of external resource by a resource path. You can specify different prefixes for this path to load resources from different locations with the <span class="FontName">@Value</span> annotation. To load a resource from a file system, you use the <span class="FontName">file</span> prefix. To load a resource from the classpath, you use the <span class="FontName">classpath</span> prefix. You can also specify a URL in the resource path.</p>
<p id="Sec43" class="Heading1">How It Works</p>
<p class="noindent">To read the contents of a <span class="FontName">properties</span> file (i.e., key-value pairs) to setup bean properties you can use Spring’s <span class="FontName">@PropertySource</span> annotation with <span class="FontName">PropertySourcesPlaceholderConfigurer</span>. If you want to read the contents of any file you can use Spring’s <span class="FontName">Resource</span> mechanism decorated with the <span class="FontName">@Value</span> annotation.</p>
<p id="Sec44" class="Heading2">Use properties file data to setup POJO instantiation values</p>
<p class="noindent">Let’s assume you have a series of values in a <span class="FontName">properties</span> file you want to access to setup bean properties. Typically this can be the configuration properties of a database or some other application values composed of key-values. For example, take the following key-values stored in a file called <span class="FontName">discounts.properties</span>.</p>
<pre class="calibre11"><span class="FontName">specialcustomer.discount=0.1</span><br class="calibre10"/><span class="FontName">summer.discount=0.15</span><br class="calibre10"/><span class="FontName">endofyear.discount=0.2</span></pre><div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To read properties files for the purpose of internationalization (i18n) see the next recipe.</p></div>
<p class="indent">To make the contents of the <span class="FontName">discounts.properties</span> file accessible to set up other beans, you can use the <span class="FontName">@PropertySource</span> annotation to convert the key-values into a bean inside a Java config class.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop.config;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.PropertySource;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Value;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">@PropertySource("classpath:discounts.properties")</span><br class="calibre10"/><span class="FontName">public class ShopConfiguration {</span><br class="calibre10"/>       <span class="FontName">private @Value("${specialcustomer.discount:0}") double specialCustomerDiscountField;</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/>       <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {</span><br class="calibre10"/>            <span class="FontName">return new PropertySourcesPlaceholderConfigurer();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/>       <span class="FontName">@Bean</span><br class="calibre10"/>       <span class="FontName">public Product aaa() {</span><br class="calibre10"/>           <span class="FontName">Battery p1 = new Battery();</span><br class="calibre10"/>           <span class="FontName">p1.setName("AAA");</span><br class="calibre10"/>           <span class="FontName">p1.setPrice(2.5);</span><br class="calibre10"/>           <span class="FontName">p1.setRechargeable(true);</span><br class="calibre10"/>           <span class="FontName">p1.setDiscount(specialCustomerDiscountField);</span><br class="calibre10"/>           <span class="FontName">return p1;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><span class="FontName">...</span></pre><p class="indent">You define a <span class="FontName">@PropertySource</span> annotation with a <span class="FontName">value</span> of <span class="FontName">classpath:discounts.properties</span> to decorate the Java config class. The <span class="FontName">classpath:</span> prefix tells Spring to look for the <span class="FontName">discounts.properties</span> file in the Java classpath.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  The parameters <span class="FontName">ignoreResourceNotFound</span> and <span class="FontName">ignoreUnresolvablePlaceholders</span> to increase fault tolerance in the use properties — as used in the XML equivalent process in Recipe 2-6 — is still not supported for the <span class="FontName">@PropertySource</span> annotation at the time of this writing. See <span class="FontName"><a href="https://jira.springsource.org/browse/SPR-8371" class="calibre5">https://jira.springsource.org/browse/SPR-8371</a></span> for updates.</p></div>
<p class="indent">Once you define the <span class="FontName">@PropertySource</span> annotation to load the properties file, you also need to define a <span class="FontName">PropertySourcePlaceholderConfigurer</span> bean with the <span class="FontName">@Bean</span> annotation. Spring automatically wires the <span class="FontName">@PropertySource discounts.properties</span> file so its properties become accessible as bean properties.</p>
<p class="indent">Next, you need to define Java variables to take values from the discount <span class="FontName">discounts.properties</span> file. To define the Java variable values with these values you make use of the <span class="FontName">@Value</span> annotation with SpeL statements.</p>
<p class="indent">The syntax is <span class="FontName">@Value("${key:default_value}")</span>. A search is done for the <span class="FontName">key</span> value in all the loaded application properties. If a matching <span class="FontName">key=value</span> is found in the properties file, the corresponding <span class="FontName">value</span> is assigned to the bean property. If no matching <span class="FontName">key=value</span> is found in the loaded application properties, the <span class="FontName">default_value</span> (i.e. after <span class="FontName">${key:</span>) is assigned to the bean property.</p>
<p class="indent">Once a Java variable is set with a discount value, you can use it to setup bean instances for a bean’s discount property.</p>
<p class="indent">If you want to use properties file data for a different purpose than setting up bean properties, you should use Spring’s <span class="FontName">Resource</span> mechanism which is described next.</p>
<p id="Sec45" class="Heading2">Use data from any external resource file for use in a POJO</p>
<p class="noindent">Suppose you want to display a banner at the startup of an application. The banner is made up of the following characters and stored in a text file called <span class="FontName">banner.txt</span><a id="cXXX.245" class="calibre5"></a>. This file can be put in the classpath of your application.</p>
<pre class="calibre11"><span class="FontName">*************************</span><br class="calibre10"/><span class="FontName">*  Welcome to My Shop!  *</span><br class="calibre10"/><span class="FontName">*************************</span></pre><p class="indent">Next, let’s write a <span class="FontName">BannerLoader</span> POJO class to load the banner and output it to the console.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.core.io.Resource;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import javax.annotation.PostConstruct;</span><br class="calibre10"/><span class="FontName">public class BannerLoader {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Resource banner;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setBanner(Resource banner) {</span><br class="calibre10"/>        <span class="FontName">this.banner = banner;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@PostConstruct</span><br class="calibre10"/>    <span class="FontName">public void showBanner() throws IOException {</span><br class="calibre10"/>        <span class="FontName">InputStream in = banner.getInputStream();</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">BufferedReader reader = new BufferedReader(new InputStreamReader(in));</span><br class="calibre10"/>        <span class="FontName">while (true) {</span><br class="calibre10"/>            <span class="FontName">String line = reader.readLine();</span><br class="calibre10"/>            <span class="FontName">if (line == null)</span><br class="calibre10"/>                <span class="FontName">break;</span><br class="calibre10"/>            <span class="FontName">System.out.println(line);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">reader.close();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Notice the POJO <span class="FontName">banner</span> field is a Spring <span class="FontName">Resource</span> type. The field value will be populated through setter injection when the bean instance is created — to be explained shortly. The <span class="FontName">showBanner</span> method makes a call to the <span class="FontName">getInputStream()</span> method to retrieve the input stream from the <span class="FontName">Resource</span> field. Once you have an InputStream, you’re able to use standard Java file manipulation class. In this case, the file contents are read line by line with <span class="FontName">BufferedReader</span> and outputted to the console.</p>
<p class="indent">Also notice the <span class="FontName">showBanner()</span> method is decorated with the <span class="FontName">@PostConstruct</span> annotation. Because you want to show the banner at startup, you use this annotation to tell Spring to invoke the method automatically after creation. This guarantees the <span class="FontName">showBanner()</span> method is one of the first methods to be run by the application and therefore ensures the banner appears at the outset.</p>
<p class="indent">Next, the POJO <span class="FontName">BannerLoader</span> needs to be initialized as an instance. In addition, the <span class="FontName">banner</span> field of the <span class="FontName">BannerLoader</span> also needs to be injected. So let’s create a Java config class for these tasks.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">@PropertySource("classpath:discounts.properties")</span><br class="calibre10"/><span class="FontName">public class ShopConfiguration {</span><br class="calibre10"/>       <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">@Value("classpath:banner.txt")</span><br class="calibre10"/>         <span class="FontName">private Resource banner;</span><br class="calibre10"/><br class="calibre10"/>       <span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/>       <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public BannerLoader bannerLoader() {</span><br class="calibre10"/>            <span class="FontName">BannerLoader bl = new BannerLoader();</span><br class="calibre10"/>            <span class="FontName">bl.setBanner(banner);</span><br class="calibre10"/>            <span class="FontName">return bl;</span><br class="calibre10"/>        <span class="FontName">}</span></pre><p class="indent">See how the <span class="FontName">banner</span> property is decorated with the <span class="FontName">@Value("classpath:banner.txt")</span> annotation. This tells Spring to search for the banner.txt file in the classpath and inject it. Spring uses the preregistered property editor <span class="FontName">ResourceEditor</span> to convert the file definition into a <span class="FontName">Resource</span> object before injecting it into the bean.</p>
<p class="indent">Once the <span class="FontName">banner</span> property is injected, it’s assigned to the <span class="FontName">BannerLoader</span> bean instance via setter injection.</p>
<p class="indent">Because the banner file is located in the Java classpath, the resource path starts with the <span class="FontName">classpath:</span> prefix. The previous resource path specifies a resource in the relative path of the file system. You can specify an absolute path as well.</p>
<pre class="calibre11"><span class="FontName">file:c:/shop/banner.txt</span></pre><p class="indent">When a resource is located in Java’s classpath, you have to use the <span class="FontName">classpath</span> prefix. If there’s no path information presented, it will be loaded from the root of the classpath.</p>
<pre class="calibre11"><span class="FontName">classpath:banner.txt</span></pre><p class="indent">If the resource is located in a particular package, you can specify the absolute path from the classpath root.</p>
<pre class="calibre11"><span class="FontName">classpath:com/apress/springrecipes/shop/banner.txt</span></pre><p class="indent">Besides support to load from a file system path or the classpath, a resource can also be loaded by specifying a URL.</p>
<pre class="calibre11"><span class="FontName"><a href="http://springrecipes.apress.com/shop/banner.txt" class="calibre5">http://springrecipes.apress.com/shop/banner.txt</a></span></pre><p class="indent">Since the bean class uses the <span class="FontName">@PostConstruct</span> annotation on the <span class="FontName">showBanner()</span> method, the banner is sent to output when the IoC container is setup. Because of this, there’s no need to tinker with an application’s context or explicitly call the bean to output the banner. However, sometimes it can be necessary to access an external resource to interact with an application’s context.</p>
<p class="indent">Now suppose you want to display a legend at the end of an application. The legend is made up of the discounts previously described in the <span class="FontName">discounts.properties</span> file. To access the contents of the properties file you can also leverage Spring’s <span class="FontName">Resource</span> mechanism.</p>
<p class="indent">Next, let’s use Spring’s <span class="FontName">Resource</span> mechanism, but this time directly inside an application’s Main class to output a legend when the application finishes.</p>
<pre class="calibre11"><span class="FontName">import org.springframework.core.io.ClassPathResource;</span><br class="calibre10"/><span class="FontName">import org.springframework.core.io.support.PropertiesLoaderUtils;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) throws Exception {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">ShoppingCart cart2 = (ShoppingCart) context.getBean("shoppingCart");</span><br class="calibre10"/><span class="FontName">cart2.addItem(dvdrw);</span><br class="calibre10"/><span class="FontName">System.out.println("Shopping cart 2 contains " + cart2.getItems());</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">Resource resource = new ClassPathResource("discounts.properties");</span><br class="calibre10"/><span class="FontName">Properties props = PropertiesLoaderUtils.loadProperties(resource);</span><br class="calibre10"/><span class="FontName">System.out.println("And don’t forget our discounts!");</span><br class="calibre10"/><span class="FontName">System.out.println(props);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Spring’s <span class="FontName">ClassPathResource</span> class is used to access the <span class="FontName">discounts.properties</span> file, which casts the file’s contents into a <span class="FontName">Resource</span> object. Next, the <span class="FontName">Resource</span> object is processed into a <span class="FontName">Properties</span> object with Spring’s <span class="FontName">PropertiesLoaderUtils</span> class. Finally, the contents of the <span class="FontName">Properties</span> object are sent to the console as the final output of the application.</p>
<p class="indent">Because the legend file (i.e., <span class="FontName">discounts.properties</span>) is located in the Java classpath, the resource is accessed with Spring’s <span class="FontName">ClassPathResource</span> class. If the external resource were in a file system path the resource would be loaded with Spring’s <span class="FontName">FileSystemResource</span>.</p>
<pre class="calibre11"><span class="FontName">Resource resource = new FileSystemResource("c:/shop/banner.txt")</span></pre><p class="indent">If the external resource were at a URL the resource would be loaded with Spring’s <span class="FontName">UrlResource</span>.</p>
<pre class="calibre11"><span class="FontName">Resource resource = new UrlResource("</span><span class="FontName"><a href="http://www.apress.com/" class="calibre5">http://www.apress.com/</a></span><span class="FontName">")</span></pre><p id="Sec46" class="Heading">3-7. Resolve I18N Text Messages for different locales in properties files</p>
<p id="Sec47" class="Heading1">Problem</p>
<p class="noindent">You<a id="cXXX.246" class="calibre5"></a> want an application to support internationalization (I18N) via annotations<a id="cXXX.247" class="calibre5"></a>.</p>
<p id="Sec48" class="Heading1">Solution</p>
<p class="noindent"><span class="FontName">MessageSource</span><a id="cXXX.248" class="calibre5"></a> is an interface that defines several methods for resolving messages in resource bundles. <span class="FontName">ResourceBundleMessageSource</span> is the most common <span class="FontName">MessageSource</span> implementation that resolves messages from resource bundles for different locales. After you implement a <span class="FontName">ResourceBundleMessageSource</span> POJO, you can use the <span class="FontName">@Bean</span> annotation in a Java config file to make the I18N data available in an application.</p>
<p id="Sec49" class="Heading1">How It Works</p>
<p class="noindent">As an example, create the following resource bundle, <span class="FontName">messages_en_US.properties</span>, for the English language in the United States. Resource bundles are loaded from the root of the classpath, so ensure it’s available on the Java classpath. Place the following key-value in the file:</p>
<pre class="calibre11"><span class="FontName">alert.checkout=A shopping cart has been checked out.</span><br class="calibre10"/><span class="FontName">alert.inventory.checkout=A shopping cart with {0} has been checked out at {1}.</span></pre><p class="indent">To resolve messages from resource bundles, let’s create a Java config file with an instance of a <span class="FontName">ReloadableResourceBundleMessageSource</span> bean.</p>
<pre class="calibre11"><span class="FontName">import org.springframework.context.support.</span><br class="calibre10"/><span class="FontName">ReloadableResourceBundleMessageSource;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class ShopConfiguration {</span><br class="calibre10"/><br class="calibre10"/>       <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public static ReloadableResourceBundleMessageSource messageSource() {</span><br class="calibre10"/>        <span class="FontName">ReloadableResourceBundleMessageSource messageSource= new         ReloadableResourceBundleMessageSource();</span><br class="calibre10"/>        <span class="FontName">String[] resources = {"classpath:messages"};</span><br class="calibre10"/>        <span class="FontName">messageSource.setBasenames(resources);</span><br class="calibre10"/>        <span class="FontName">messageSource.setCacheSeconds(1);</span><br class="calibre10"/>        <span class="FontName">return messageSource;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The bean instance must have the name <span class="FontName">messageSource</span> for the application context to detect it. Also notice the <span class="FontName">@Bean</span> definition is declared as <span class="FontName">static</span>, unlike other beans you’ve defined in Java config files up to this point. The <span class="FontName">static</span> qualifier is necessary because <span class="FontName">ReloadableRsourceBundleMessageSource</span> is bean post processor. Bean post processors are discussed in detail in Recipes 3-9 and 2-9.</p>
<p class="indent">Inside the bean definition you declare a String list via the <span class="FontName">setBasenames</span> method to locate bundles for the <span class="FontName">ResourceBundleMessageSource</span>. In this case, we just specify the default convention to lookup files located in Java classpath that start with <span class="FontName">messages</span>. In addition, the <span class="FontName">setCacheSeconds</span> methods sets a value to <span class="FontName">1</span> to avoid reading stale messages. Note that a refresh attempt first checks the last-modified timestamp of the properties file before actually reloading it; so if files don’t change, the <span class="FontName">setCacheSeconds</span> interval can be set rather low, as refresh attempts aren’t actually reloaded.</p>
<p class="indent">For this <span class="FontName">MessageSource</span> definition, if you look up a text message for the United States locale, whose preferred language is English, the resource bundle <span class="FontName">message_en_US.properties</span> is considered first. If there’s no such resource bundle or the message can’t be found, then a <span class="FontName">message_en.properties</span> file that matches the language is considered. If a resource bundle still can’t be found, the default <span class="FontName">message.properties</span> for all locales is chosen. For more information on resource bundle loading, you can refer to the Javadoc of the <span class="FontName">java.util.ResourceBundle</span> class.</p>
<p class="indent">Next, you can configure the application context to resolve messages with the <span class="FontName">getMessage()</span> method. The first argument is the key corresponding to the message, and the third is the target locale.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) throws Exception {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span><br class="calibre10"/>            <span class="FontName">new GenericXmlApplicationContext("appContext.xml");</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">String alert = context.getMessage("alert.checkout", null, Locale.US);</span><br class="calibre10"/>           <span class="FontName">String alert_inventory = context.getMessage("alert.inventory.checkout", new Object[] {<br class="calibre10"/>            "[DVD-RW 3.0]", new Date() }, Locale.US);</span><br class="calibre10"/>        <span class="FontName">System.out.println(alert);</span><br class="calibre10"/>        <span class="FontName">System.out.println(alert_inventory);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The second argument of the <span class="FontName">getMessage()</span> method is an array of message parameters. In the first String statement the value is null, in the second String statement an object array to fill in the message parameters is used.</p>
<p class="indent">In the <span class="FontName">Main</span> class, you can resolve text messages because you can access the application context directly. But for a bean to resolve text messages, you have to inject a <span class="FontName">MessageSource</span> implementation into the bean that needs to resolve text messages. Let’s implement a Cashier class for the shopping application that illustrates how to resolve messages.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class Cashier {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private MessageSource messageSource;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setMessageSource(MessageSource messageSource) {</span><br class="calibre10"/>        <span class="FontName">this.messageSource = messageSource;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void checkout(ShoppingCart cart) throws IOException {</span><br class="calibre10"/>        <span class="FontName">String alert = messageSource.getMessage("alert.inventory.checkout",</span><br class="calibre10"/>                                                <span class="FontName">new Object[] { cart.getItems(), new Date() },                                                 Locale.US);</span><br class="calibre10"/>        <span class="FontName">System.out.println(alert);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Notice the POJO <span class="FontName">messageSource</span> field is a Spring <span class="FontName">MessageSource</span> type. The field value is decorated with the <span class="FontName">@Autowired</span> annotation so it’s populated through setter injection when the bean instance is created. Then the <span class="FontName">checkout</span> method can access the <span class="FontName">messageSource</span> field, which gives the bean access to the <span class="FontName">getMessage</span> method to gain access to text messages based on I18N criteria.</p>
<p class="indent">Finally, for both of the previous scenarios, remember you need to setup the necessary XML configuration file so Spring is able can detect POJOs with annotations.</p>
<p id="Sec50" class="Heading">3-8. Customize POJO Initialization and Destruction with annotations</p>
<p id="Sec51" class="Heading1">Problem</p>
<p class="noindent">Some POJOs have to perform certain types of initialization tasks before they’re used. These tasks can include opening a file, opening a network/database connection, allocating memory, and so on. In addition, these same POJO also have to perform the corresponding destruction tasks at the end of their life cycle. Therefore, sometimes it’s necessary to customize bean initialization and destruction in the Spring IoC container.</p>
<p id="Sec52" class="Heading1">Solution</p>
<p class="noindent">Spring can recognize initialization and destruction callback methods by setting the <span class="FontName">initmethod</span> and <span class="FontName">destroyMethod</span> attributes of a <span class="FontName">@Bean</span> definition in a Java config class. Or Spring can also recognize initialization and destruction callback methods if POJO methods are decorated with the <span class="FontName">@PostConstruct</span> and <span class="FontName">@PreDestroy</span> annotations, respectively.</p>
<p class="indent">Spring can also delay the creation of a bean up until the point it’s required — a process called lazy initialization — with the <span class="FontName">@Lazy</span> annotation. Spring can also ensure the initialization of certain beans before others with the <span class="FontName">@DependsOn</span> annotation.</p>
<p id="Sec53" class="Heading1">How It Works</p>
<p id="Sec54" class="Heading2">Define methods to run before POJO initialization and destruction with @Bean<a id="cXXX.249" class="calibre6"></a><a id="cXXX.250" class="calibre6"></a></p>
<p class="noindent">Let’s take the case of the shopping application and consider an example involving a checkout function. Let’s modify the <span class="FontName">Cashier</span> class to record a shopping cart’s products and the checkout time to a text file.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Cashier {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private String fileName;</span><br class="calibre10"/>    <span class="FontName">private String path;</span><br class="calibre10"/>    <span class="FontName">private BufferedWriter writer;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setFileName(String fileName) {</span><br class="calibre10"/>        <span class="FontName">this.fileName = fileName;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setPath(String path) {</span><br class="calibre10"/>        <span class="FontName">this.path = path;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void openFile() throws IOException {</span><br class="calibre10"/>           <span class="FontName">File targetDir = new File(path);</span><br class="calibre10"/>        <span class="FontName">if (!targetDir.exists()) {</span><br class="calibre10"/>            <span class="FontName">targetDir.mkdir();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>       <span class="FontName">File checkoutFile = new File(path, fileName + ".txt");</span><br class="calibre10"/>        <span class="FontName">if(!checkoutFile.exists()) {</span><br class="calibre10"/>            <span class="FontName">checkoutFile.createNewFile();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>       <span class="FontName">writer = new BufferedWriter(new OutputStreamWriter(</span><br class="calibre10"/>                <span class="FontName">new FileOutputStream(checkoutFile, true)));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void checkout(ShoppingCart cart) throws IOException {</span><br class="calibre10"/>        <span class="FontName">writer.write(new Date() + "\t" +cart.getItems() + "\r\n");</span><br class="calibre10"/>        <span class="FontName">writer.flush();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void closeFile() throws IOException {</span><br class="calibre10"/>        <span class="FontName">writer.close();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In the <span class="FontName">Cashier</span> class, the <span class="FontName">openFile()</span> method first verifies if the target directory and the file to write the data exists. It then opens the text file in the specified system path and assigns it to the <span class="FontName">writer</span> field. Then each time the <span class="FontName">checkout()</span> method is called, the date and cart items are appended to the text file. Finally, the <span class="FontName">closeFile()</span> method closes the file to release its system resources.</p>
<p class="indent">Next, let’s explore how this bean definition has to be set up in a Java config class, in order to execute the <span class="FontName">openFile()</span> method just before the bean is created and the <span class="FontName">closeFile()</span> method just before it’s destroyed.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class ShopConfiguration {</span><br class="calibre10"/>      <span class="FontName">...</span><br class="calibre10"/>      <span class="FontName">@Bean(initMethod="openFile",destroyMethod="closeFile")</span><br class="calibre10"/>        <span class="FontName">public Cashier cashier() {</span><br class="calibre10"/>            <span class="FontName">Cashier c1 = new Cashier();</span><br class="calibre10"/>            <span class="FontName">c1.setFileName("checkout");</span><br class="calibre10"/>            <span class="FontName">c1.setPath("c:/Windows/Temp/cashier");</span><br class="calibre10"/>            <span class="FontName">return c1;</span><br class="calibre10"/>        <span class="FontName">}</span></pre><div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  The path value is set to c:/Windows/Temp/ because it’s a Windows world-writeable directory. If you use another path, ensure it’s accessible by the user that executes the application.</p></div>
<p class="indent">Notice the POJO’s initialization and destruction tasks are defined with the <span class="FontName">initMethod</span> and <span class="FontName">destroyMethod</span> attributes of a <span class="FontName">@Bean</span> annotation. With these two attributes set in the bean declaration, when the <span class="FontName">Cashier</span> class is created it first triggers the <span class="FontName">openFile()</span> method — verifying if the target directory and the file to write the data exist, as well as opening the file to append records — and when the bean is destroyed it triggers the <span class="FontName">closeFile()</span> method —ensuring the file reference is closed to release system resources.</p>
<p id="Sec55" class="Heading2">Define methods to run before POJO initialization and destruction with @PostConstruct and @PreDestroy<a id="cXXX.251" class="calibre6"></a></p>
<p class="noindent">Another alterative if you’ll define POJO instances outside a Java config class (e.g., with the <span class="FontName">@Component</span> annotation) is to use the <span class="FontName">@PostConstruct</span> and <span class="FontName">@PreDestroy</span> annotations<a id="cXXX.252" class="calibre5"></a> directly in the POJO class.</p>
<pre class="calibre11"><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class Cashier {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Value("checkout")</span><br class="calibre10"/>    <span class="FontName">private String fileName;</span><br class="calibre10"/>    <span class="FontName">@Value("c:/Windows/Temp/cashier")</span><br class="calibre10"/>    <span class="FontName">private String path;</span><br class="calibre10"/>    <span class="FontName">private BufferedWriter writer;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setFileName(String fileName) {</span><br class="calibre10"/>        <span class="FontName">this.fileName = fileName;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setPath(String path) {</span><br class="calibre10"/>        <span class="FontName">this.path = path;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@PostConstruct</span><br class="calibre10"/>    <span class="FontName">public void openFile() throws IOException {</span><br class="calibre10"/>        <span class="FontName">File targetDir = new File(path);</span><br class="calibre10"/>        <span class="FontName">if (!targetDir.exists()) {</span><br class="calibre10"/>            <span class="FontName">targetDir.mkdir();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">File checkoutFile = new File(path, fileName + ".txt");</span><br class="calibre10"/>        <span class="FontName">if(!checkoutFile.exists()) {</span><br class="calibre10"/>            <span class="FontName">checkoutFile.createNewFile();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">writer = new BufferedWriter(new OutputStreamWriter(</span><br class="calibre10"/>                <span class="FontName">new FileOutputStream(checkoutFile, true)));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void checkout(ShoppingCart cart) throws IOException {</span><br class="calibre10"/>        <span class="FontName">writer.write(new Date() + "\t" +cart.getItems() + "\r\n");</span><br class="calibre10"/>        <span class="FontName">writer.flush();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@PreDestroy</span><br class="calibre10"/>    <span class="FontName">public void closeFile() throws IOException {</span><br class="calibre10"/>        <span class="FontName">writer.close();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The <span class="FontName">@Component</span> annotation tells Spring to manage the POJO, just like it’s been used in previous recipes. Two of the POJO fields’ values are set with the <span class="FontName">@Value</span> annotation, a concept that was also explored in a previous recipe.</p>
<p class="indent">The <span class="FontName">openFile()</span> method is decorated with the <span class="FontName">@PostConstruct</span> annotation, which tells Spring to execute the method right after a bean is constructed. The <span class="FontName">closeFile()</span> method is decorated with the <span class="FontName">@PreDestroy</span> annotation, which tells Spring to execute the method right before a bean is destroyed.</p>
<p id="Sec56" class="Heading2">Define lazy initialization<a id="cXXX.253" class="calibre6"></a> for POJOs with @Lazy<a id="cXXX.254" class="calibre6"></a></p>
<p class="noindent">By default, Spring performs eager initialization on all POJOs. This means POJOs are initialized at startup. In certain circumstances though, it can be convenient to delay the POJO initialization process until a bean is required. Delaying the initialization is called ’lazy initialization’.</p>
<p class="indent">Lazy initialization helps limit resource consumption peaks at startup and save overall system resources. Lazy initialization can be particularly relevant for POJOs that perform heavyweight operations (e.g., network connections, file operations). To mark a bean with lazy initialization you decorate a bean with the <span class="FontName">@Lazy</span> annotation.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Scope;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Lazy;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">@Scope("prototype")</span><br class="calibre10"/><span class="FontName">@Lazy</span><br class="calibre10"/><span class="FontName">public class ShoppingCart {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private List&lt;Product&gt; items = new ArrayList&lt;Product&gt;();</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void addItem(Product item) {</span><br class="calibre10"/>        <span class="FontName">items.add(item);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public List&lt;Product&gt; getItems() {</span><br class="calibre10"/>        <span class="FontName">return items;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In the previous declaration because the POJO is decorated with the <span class="FontName">@Lazy</span> annotation, if the POJO is never required by the application or referenced by another POJO, it’s never instantiated.</p>
<p id="Sec57" class="Heading2">Define initialization of POJOs before other POJOs with @DependsOn<a id="cXXX.255" class="calibre6"></a></p>
<p class="noindent">As an application’s<a id="cXXX.256" class="calibre5"></a> POJOs grow, so does the number of POJO initializations. This can create race conditions if POJOs reference one another and are spread out in different Java Configuration classes. What happens if bean ‘C’ requires the logic in bean ‘B’ and bean ‘F’? If bean ‘C’ is detected first and Spring hasn’t initialized bean ‘B’ and bean ‘F’, you’ll get an error which can be hard to detect.</p>
<p class="indent">To ensure that certain POJOs are initialized before other POJOs and to get a more descriptive error in case of a failed initialization process, Spring offers the <span class="FontName">@DependsOn</span> annotation. The <span class="FontName">@DependsOn</span> annotation ensures a given bean is initialized before another bean.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.DependsOn;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.sequence.DatePrefixGenerator;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.sequence.NumberPrefixGenerator;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.sequence.SequenceGenerator;</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class SequenceConfiguration {</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">@DependsOn("datePrefixGenerator")</span><br class="calibre10"/>        <span class="FontName">public SequenceGenerator sequenceGenerator() {</span><br class="calibre10"/>           <span class="FontName">SequenceGenerator sequence= new SequenceGenerator();</span><br class="calibre10"/>           <span class="FontName">sequence.setInitial(100000);</span><br class="calibre10"/>           <span class="FontName">sequence.setSuffix("A");</span><br class="calibre10"/>           <span class="FontName">return sequence;</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In the previous snippet, the declaration <span class="FontName">@DependsOn("datePrefixGenerator")</span> ensures the <span class="FontName">datePrefixGenerator</span> bean is created before the <span class="FontName">sequenceGenerator</span> bean. The <span class="FontName">@DependsOn</span> attribute also supports defining multiple dependency beans with a CSV list surrounded vy {} (e.g., <span class="FontName">@DependsOn({"datePrefixGenerator, numberPrefixGenerator, randomPrefixGenerator"}</span>)</p>
<p id="Sec58" class="Heading">3-9. Create Post Processors<a id="cXXX.2131" class="calibre6"></a> to validate and modify POJOs</p>
<p id="Sec59" class="Heading1">Problem</p>
<p class="noindent">You want to apply tasks to all bean instances or specific types of instances during construction to validate or modify bean properties according to particular criteria.</p>
<p id="Sec60" class="Heading1">Solution</p>
<p class="noindent">A bean post processor allows bean processing before and after the initialization callback method (i.e., the one assigned to the <span class="FontName">initmethod</span> attribute of the <span class="FontName">@Bean</span> annotation or the method decorated with the <span class="FontName">@PostConstruct</span> annotation). The main characteristic<a id="cXXX.257" class="calibre5"></a> of a bean post processor is that it processes all the bean instances in the IoC container, not just a single bean instance. Typically, bean post processors are used to check the validity of bean properties, alter bean properties according to particular criteria, or apply certain tasks to all bean instances.</p>
<p class="indent">Spring also supports the <span class="FontName">@Required</span> annotation<a id="cXXX.258" class="calibre5"></a> which is backed by the built-in Spring post-processor RequiredAnnotationBeanPostProcessor. The RequiredAnnotationBeanPostProcessor bean post processor checks if all the bean properties with the @Required annotation have been set.</p>
<p id="Sec61" class="Heading1">How It Works</p>
<p class="noindent">Suppose you want to audit the creation of every bean. You may want to do this to debug an application, verify the properties of every bean or some other scenario. A bean post processor is an ideal choice to implement this feature, because you don’t have to modify any pre-existing POJO code.</p>
<p id="Sec62" class="Heading2">Create POJO to process every bean instance<a id="cXXX.259" class="calibre6"></a></p>
<p class="noindent">To write a bean post processor a class has to implement <span class="FontName">BeanPostProcessor</span>. When Spring detects a bean that implements this class, it applies the <span class="FontName">postProcessBeforeInitialization()</span> and <span class="FontName">postProcessAfterInitialization()</span>methods to all bean instances managed by Spring. You can implement any logic you wish in these methods, to either inspect, modify, or verify the status of a bean.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.BeansException;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class AuditCheckBeanPostProcessor implements BeanPostProcessor {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Object postProcessBeforeInitialization(Object bean, String beanName)</span><br class="calibre10"/>            <span class="FontName">throws BeansException {</span><br class="calibre10"/>        <span class="FontName">System.out.println("In AuditCheckBeanPostProcessor.postProcessBeforeInitialization,         processing bean type: " + bean.getClass());</span><br class="calibre10"/>        <span class="FontName">return bean;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Object postProcessAfterInitialization(Object bean, String beanName)</span><br class="calibre10"/>            <span class="FontName">throws BeansException {</span><br class="calibre10"/>        <span class="FontName">return bean;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Notice the <span class="FontName">postProcessBeforeInitialization()</span> and <span class="FontName">postProcessAfterInitialization()</span> methods must return the original bean instance even if you don’t do anything in the method.</p>
<p class="indent">To register a bean post processor in an application context, just annotate the class with the <span class="FontName">@Component</span> annotation. The application context is able to detect which bean implements the <span class="FontName">BeanPostProcessor</span> interface and register it to process all other bean instances in the container.</p>
<p id="Sec63" class="Heading2">Create POJO to process selected bean instances<a id="cXXX.260" class="calibre6"></a></p>
<p class="noindent">During bean construction, the Spring IoC container passes all the bean instances to the bean post processor one by one. This means if you only want to apply a bean post processor to certain types of beans, you must filter the beans by checking their instance type . This allows you to apply logic more selectively across beans.</p>
<p class="indent">Suppose you now want to apply a bean post processor but just to <span class="FontName">Product</span> bean instances. The following example is another bean post processor that does just this.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.BeansException;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class ProductCheckBeanPostProcessor implements BeanPostProcessor {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Object postProcessBeforeInitialization(Object bean, String beanName)</span><br class="calibre10"/>            <span class="FontName">throws BeansException {</span><br class="calibre10"/>        <span class="FontName">if (bean instanceof Product) {</span><br class="calibre10"/>            <span class="FontName">String productName = ((Product) bean).getName();</span><br class="calibre10"/>            <span class="FontName">System.out.println("In ProductCheckBeanPostProcessor.postProcessBeforeInitialization,             processing Product: " + productName);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return bean;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Object postProcessAfterInitialization(Object bean, String beanName)</span><br class="calibre10"/>            <span class="FontName">throws BeansException {</span><br class="calibre10"/>        <span class="FontName">if (bean instanceof Product) {</span><br class="calibre10"/>            <span class="FontName">String productName = ((Product) bean).getName();</span><br class="calibre10"/>            <span class="FontName">System.out.println("In ProductCheckBeanPostProcessor.postProcessAfterInitialization,             processing Product: " + productName);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return bean;</span><br class="calibre10"/>    <span class="FontName">}</span></pre><p class="indent">Both the <span class="FontName">postProcessBeforeInitialization()</span> and <span class="FontName">postProcessAfterInitialization()</span> methods must return an instance of the bean being processed. However, this also means you can even replace the original bean instance with a brand-new instance in your bean post processor.</p>
<p id="Sec64" class="Heading2">Verify POJO Properties with the @Required Annotation<a id="cXXX.261" class="calibre6"></a></p>
<p class="noindent">In certain cases, it may be necessary to check if particular properties have been set. Instead of creating of custom post-constructor to verify the particular properties of a bean, it’s possible to decorate a property with the <span class="FontName">@Required</span> annotation. The <span class="FontName">@Required</span> annotation provides access to the <span class="FontName">@RequiredAnnotationBeanPostProcessor</span><a id="cXXX.262" class="calibre5"></a> class — a Spring bean post processor that can check if certain bean properties have been set. Note that this processor can only check if the properties have been set, but can’t check if their value is null or something else.</p>
<p class="indent">Suppose that both the <span class="FontName">prefixGenerator</span> and <span class="FontName">suffix</span> properties are required for a sequence generator. You can annotate their setter methods with <span class="FontName">@Required</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Required;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private PrefixGenerator prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">private String suffix;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Required</span><br class="calibre10"/>    <span class="FontName">public void setPrefixGenerator(PrefixGenerator prefixGenerator) {</span><br class="calibre10"/>        <span class="FontName">this.prefixGenerator = prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Required</span><br class="calibre10"/>    <span class="FontName">public void setSuffix(String suffix) {</span><br class="calibre10"/>        <span class="FontName">this.suffix = suffix;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">To ask Spring to check if these properties have been set you just need to enable scanning so Spring can detect and enforce the <span class="FontName">@Required</span> annotation . If any properties with <span class="FontName">@Required</span> have not been set, a BeanInitializationException error is thrown.</p>
<p id="Sec65" class="Heading">3-10. Create POJOs with a factory (Static method, Instance method, Spring’s FactoryBean)</p>
<p id="Sec66" class="Heading1">Problem</p>
<p class="noindent">You want to create a POJO instance in the Spring IoC container by invoking a static factory method or instance factory method. The purpose of this approach is to encapsulate the object-creation process in either a static method or in a method of another object instance, respectively. The client who requests an object can simply make a call to this method without knowing about the creation details.</p>
<p class="indent">You want to create a POJO instance in the Spring IoC container using Spring’s factory bean. A factory bean is a bean that serves as a factory for creating other beans within the IoC container. Conceptually, a factory bean is very similar to a factory method, but it’s a Spring-specific bean that can be identified by the Spring IoC container during bean construction.</p>
<p id="Sec67" class="Heading1">Solution</p>
<p class="noindent">To create a POJO by invoking a static factory inside a <span class="FontName">@Bean</span> definition of a Java configuration class, you use standard Java syntax to call the static factory method. The create a POJO by invoking an instance factory method inside a <span class="FontName">@Bean</span> definition of a Java configuration class, you create a POJO to instantiate the factory values and another POJO to act as a façade to access the factory.</p>
<p class="indent">As a convenience, Spring provides an abstract template class called <span class="FontName">AbstractFactoryBean</span> to extend Spring’s <span class="FontName">FactoryBean</span> interface.</p>
<p id="Sec68" class="Heading1">How It Works</p>
<p id="Sec69" class="Heading2">Create POJOs by invoking a static factory method<a id="cXXX.263" class="calibre6"></a><a id="cXXX.264" class="calibre6"></a></p>
<p class="noindent">For example, you can write the following <span class="FontName">createProduct</span> static factory method to create a product from a predefined product ID. According to the product ID, this method decides which concrete product class to instantiate. If there is no product matching this ID, Spring throws an <span class="FontName">IllegalArgumentException</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class ProductCreator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static Product createProduct(String productId) {</span><br class="calibre10"/>        <span class="FontName">if ("aaa".equals(productId)) {</span><br class="calibre10"/>            <span class="FontName">return new Battery("AAA", 2.5);</span><br class="calibre10"/>        <span class="FontName">} else if ("cdrw".equals(productId)) {</span><br class="calibre10"/>            <span class="FontName">return new Disc("CD-RW", 1.5);</span><br class="calibre10"/>        <span class="FontName">} else if ("dvdrw".equals(productId)) {</span><br class="calibre10"/>            <span class="FontName">return new Disc("DVD-RW", 3.0);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">throw new IllegalArgumentException("Unknown product");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">To create a POJO with a static factory method inside a <span class="FontName">@Bean</span> definition of a Java Configuration class you use regular Java syntax to call the factory method.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class ShopConfiguration {</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Product aaa() {</span><br class="calibre10"/>            <span class="FontName">return ProductCreator.createProduct("aaa");</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Product cdrw() {</span><br class="calibre10"/>            <span class="FontName">return ProductCreator.createProduct("cdrw");</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Product dvdrw() {</span><br class="calibre10"/>            <span class="FontName">return ProductCreator.createProduct("dvdrw");</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec70" class="Heading2">Create POJOs by invoking an instance factory method<a id="cXXX.265" class="calibre6"></a><a id="cXXX.266" class="calibre6"></a></p>
<p class="noindent">For example, you can write the following <span class="FontName">ProductCreator</span> class by using a configurable map to store predefined products. The <span class="FontName">createProduct()</span> instance factory method finds a product by looking up the supplied productId in the map. If there is no product matching this ID, it will throw an IllegalArgumentException.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class ProductCreator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Map&lt;String, Product&gt; products;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setProducts(Map&lt;String, Product&gt; products) {</span><br class="calibre10"/>        <span class="FontName">this.products = products;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Product createProduct(String productId) {</span><br class="calibre10"/>        <span class="FontName">Product product = products.get(productId);</span><br class="calibre10"/>        <span class="FontName">if (product != null) {</span><br class="calibre10"/>            <span class="FontName">return product;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">throw new IllegalArgumentException("Unknown product");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">To create products from this <span class="FontName">ProductCreator</span>, you first declare a <span class="FontName">@Bean</span> to instantiate the factory values. Next, you declare a second bean to act as a façade to access the factory. Finally, you can call the factory and execute the <span class="FontName">createProduct()</span>method in to instantiate other beans.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class ShopConfiguration {</span><br class="calibre10"/>       <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public ProductCreator productCreatorFactoryBean() {</span><br class="calibre10"/>            <span class="FontName">ProductCreator factory = new ProductCreator();</span><br class="calibre10"/>            <span class="FontName">Map&lt;String, Product&gt; products = new HashMap();</span><br class="calibre10"/>            <span class="FontName">products.put("aaa", new Battery("AAA", 2.5));</span><br class="calibre10"/>            <span class="FontName">products.put("cdrw", new Disc("CD-RW", 1.5));</span><br class="calibre10"/>            <span class="FontName">products.put("dvdrw", new Disc("DVD-RW", 3.0));</span><br class="calibre10"/>            <span class="FontName">factory.setProducts(products);</span><br class="calibre10"/>            <span class="FontName">return factory;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public ProductCreator productCreatorFactory() {</span><br class="calibre10"/>            <span class="FontName">return (ProductCreator) productCreatorFactoryBean();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Product aaa() {</span><br class="calibre10"/>            <span class="FontName">return productCreatorFactory().createProduct("aaa");</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Product cdrw() {</span><br class="calibre10"/>            <span class="FontName">return productCreatorFactory().createProduct("cdrw");</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Product dvdrw() {</span><br class="calibre10"/>            <span class="FontName">return productCreatorFactory().createProduct("dvdrw");</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec71" class="Heading2">Create POJOs using Spring’s factory bean<a id="cXXX.267" class="calibre6"></a><a id="cXXX.268" class="calibre6"></a></p>
<p class="noindent">Although you’ll seldom have to write custom factory beans, you may find it helpful to understand their internal mechanisms through an example. For example, you can write a factory bean for creating a product with a discount applied to the price. It accepts a product property and a discount property to apply the discount to the product and return it as a new bean.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.config.AbstractFactoryBean;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class DiscountFactoryBean extends AbstractFactoryBean {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Product product;</span><br class="calibre10"/>    <span class="FontName">private double discount;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setProduct(Product product) {</span><br class="calibre10"/>        <span class="FontName">this.product = product;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setDiscount(double discount) {</span><br class="calibre10"/>        <span class="FontName">this.discount = discount;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Class getObjectType() {</span><br class="calibre10"/>        <span class="FontName">return product.getClass();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">protected Object createInstance() throws Exception {</span><br class="calibre10"/>        <span class="FontName">product.setPrice(product.getPrice() * (1 - discount));</span><br class="calibre10"/>        <span class="FontName">return product;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">By extending the <span class="FontName">AbstractFactoryBean</span> class, the factory bean can simply override the <span class="FontName">createInstance()</span> method to create the target bean instance. In addition, you have to return the target bean’s type in the <span class="FontName">getObjectType()</span> method for the auto-wiring feature to work properly.</p>
<p class="indent">Next, you can declare product instances using a regular <span class="FontName">@Bean</span> annotation to apply <span class="FontName">DiscountFactoryBean</span>.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class ShopConfiguration {</span><br class="calibre10"/>       <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Battery aaa() {</span><br class="calibre10"/>            <span class="FontName">Battery aaa = new Battery("AAA",2.5);</span><br class="calibre10"/>            <span class="FontName">return aaa;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>       <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Disc cdrw() {</span><br class="calibre10"/>            <span class="FontName">Disc aaa = new Disc("CD-RW",1.5);</span><br class="calibre10"/>            <span class="FontName">return aaa;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>       <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Disc dvdrw() {</span><br class="calibre10"/>            <span class="FontName">Disc aaa = new Disc("DVD-RW",3.0);</span><br class="calibre10"/>            <span class="FontName">return aaa;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>       <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public DiscountFactoryBean discountFactoryBeanAAA() {</span><br class="calibre10"/>            <span class="FontName">DiscountFactoryBean factory = new DiscountFactoryBean();</span><br class="calibre10"/>            <span class="FontName">factory.setProduct(aaa());</span><br class="calibre10"/>            <span class="FontName">factory.setDiscount(0.2);</span><br class="calibre10"/>            <span class="FontName">return factory;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public DiscountFactoryBean discountFactoryBeanCDRW() {</span><br class="calibre10"/>            <span class="FontName">DiscountFactoryBean factory = new DiscountFactoryBean();</span><br class="calibre10"/>            <span class="FontName">factory.setProduct(cdrw());</span><br class="calibre10"/>            <span class="FontName">factory.setDiscount(0.1);</span><br class="calibre10"/>            <span class="FontName">return factory;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public DiscountFactoryBean discountFactoryBeanDVDRW() {</span><br class="calibre10"/>            <span class="FontName">DiscountFactoryBean factory = new DiscountFactoryBean();</span><br class="calibre10"/>            <span class="FontName">factory.setProduct(dvdrw());</span><br class="calibre10"/>            <span class="FontName">factory.setDiscount(0.1);</span><br class="calibre10"/>            <span class="FontName">return factory;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec72" class="Heading">3-11. Use Spring Environments and Profiles to load different sets of POJOs</p>
<p id="Sec73" class="Heading1">Problem</p>
<p class="noindent">You want to use the same set of POJO instances or beans but with different instantiation values for different application scenarios (e.g., ‘production’, ‘development’ &amp; ‘testing’ ).</p>
<p id="Sec74" class="Heading1">Solution</p>
<p class="noindent">Create multiple Java Configuration classes and group POJOs instances or beans into each of these classes. Assign a profile name to the Java Configuration class with the <span class="FontName">@Profile</span> annotation based on the purpose of the group. Get the environment for an application’s context and set the profile to load a specific group of POJOs.</p>
<p id="Sec75" class="Heading1">How it works</p>
<p class="noindent">POJO instantiation values can vary depending on different application scenarios. For example, a common scenario can occur when an application goes from development, to testing and on to production. In each of these scenarios, the properties for certain beans can vary slightly to accommodate environment changes (e.g., database username/password, file paths, etc.).</p>
<p class="indent">You can create multiple Java Configuration classes each with different POJO (e.g., <span class="FontName">ShopConfigurationGlobal</span>, <span class="FontName">ShopConfigurationStr</span> and <span class="FontName">ShopConfigurationSumWin</span>). And in the application context only load a given Configuration class file based on the scenario.</p>
<p id="Sec76" class="Heading2">Create Java Configuration class with @Profile annotation<a id="cXXX.269" class="calibre6"></a></p>
<p class="noindent">Let’s create a multiple Java Configuration class with a <span class="FontName">@Profile</span> annotation<a id="cXXX.270" class="calibre5"></a> for the shopping application presented in previous recipes.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Profile;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">@Profile("global")</span><br class="calibre10"/><span class="FontName">public class ShopConfigurationGlobal {</span><br class="calibre10"/><br class="calibre10"/>      <span class="FontName">@Bean(initMethod="openFile",destroyMethod="closeFile")</span><br class="calibre10"/>      <span class="FontName">public Cashier cashier() {</span><br class="calibre10"/>            <span class="FontName">Cashier c1 = new Cashier();</span><br class="calibre10"/>            <span class="FontName">c1.setFileName("checkout");</span><br class="calibre10"/>            <span class="FontName">c1.setPath("c:/Windows/Temp/cashier");</span><br class="calibre10"/>            <span class="FontName">return c1;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.shop.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Profile;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">@Profile({"summer","winter"})</span><br class="calibre10"/><span class="FontName">public class ShopConfigurationSumWin {</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Product aaa() {</span><br class="calibre10"/>           <span class="FontName">Battery p1 = new Battery();</span><br class="calibre10"/>           <span class="FontName">p1.setName("AAA");</span><br class="calibre10"/>           <span class="FontName">p1.setPrice(2.0);</span><br class="calibre10"/>           <span class="FontName">p1.setRechargeable(true);</span><br class="calibre10"/>           <span class="FontName">return p1;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Product cdrw() {</span><br class="calibre10"/>           <span class="FontName">Disc p2 = new Disc("CD-RW",1.0);</span><br class="calibre10"/>           <span class="FontName">p2.setCapacity(700);</span><br class="calibre10"/>           <span class="FontName">return p2;</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">@Bean</span><br class="calibre10"/>        <span class="FontName">public Product dvdrw() {</span><br class="calibre10"/>           <span class="FontName">Disc p2 = new Disc("DVD-RW",2.5);</span><br class="calibre10"/>           <span class="FontName">p2.setCapacity(700);</span><br class="calibre10"/>           <span class="FontName">return p2;</span><br class="calibre10"/>           <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The <span class="FontName">@Profile</span> annotation decorates the entire Java configuration class, so all the <span class="FontName">@Bean</span> instances belong to the same profile. To assign a <span class="FontName">@Profile</span> name you just place the name inside <span class="FontName">""</span>. Notice it’s also possible to assign multiple <span class="FontName">@Profile</span> names using a CSV syntax surrounded by <span class="FontName">{}</span> (e.g., <span class="FontName">{"summer","winter"}</span>).</p>
<p id="Sec77" class="Heading2">Load Profile<a id="cXXX.271" class="calibre6"></a> into Environment</p>
<p class="indent">To load the beans from a certain profile into an application, you need to activate a profile. You can load multiple profiles at a time and it’s also possible to load profiles programmatically, through a Java runtime flag or even as an initialization parameter of a WAR file.</p>
<p class="indent">To load profiles programmatically (i.e., via the application context) you get the context environment from where you can load profiles via the <span class="FontName">setActiveProfiles()</span> method.</p>
<pre class="calibre11"><span class="FontName">AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">context.getEnvironment().setActiveProfiles("global","winter");</span><br class="calibre10"/><span class="FontName">context.scan("com.apress.springrecipes.shop");</span><br class="calibre10"/><span class="FontName">context.refresh();</span><br class="calibre10"/><span class="FontName">/**At this point beans declared inside the package com.apress.springrecipes.shop.config with the global and summer profiles are accessible*/</span></pre><p class="indent">It’s also possible to indicate which Spring profile to load via a Java runtime flag. In this manner, you can pass the following runtime flag to load all beans that belong to the global and winter profiles: <span class="FontName">Dspring.profiles.active="global, winter"</span></p>
<p class="indent">Finally, a Spring profile can also be setup directly inside a WAR’s <span class="FontName">web.xml</span> configuration file. This scenario is relevant for Spring web applications.</p>
<pre class="calibre11"><span class="FontName">&lt;servlet&gt;</span><br class="calibre10"/> <span class="FontName">&lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br class="calibre10"/> <span class="FontName">&lt;servlet-class&gt;</span><br class="calibre10"/>   <span class="FontName">org.springframework.web.servlet.DispatcherServlet</span><br class="calibre10"/> <span class="FontName">&lt;/servlet-class&gt;</span><br class="calibre10"/> <span class="FontName">&lt;init-param&gt;</span><br class="calibre10"/>   <span class="FontName">&lt;param-name&gt;spring.profiles.active&lt;/param-name&gt;</span><br class="calibre10"/>   <span class="FontName">&lt;param</span><span class="FontName">-value&gt;winter&lt;/param-value&gt;</span><br class="calibre10"/> <span class="FontName">&lt;/init-param&gt;</span><br class="calibre10"/><span class="FontName">&lt;/servlet&gt;</span></pre><p id="Sec78" class="Heading2">Set default Profile</p>
<p class="noindent">To avoid the possibility of errors because no profiles are loaded into an application, you can define default profiles<a id="cXXX.272" class="calibre5"></a>. Default profiles are only used when Spring can’t detect any active profiles — defined using any of the previous methods: programmatically, via a Java runtime flag or web application initialization parameter.</p>
<p class="indent">To setup default profiles, you can also use any of the three methods to setup active profiles. Programmatically you use the method <span class="FontName">setDefaultProfiles()</span>instead of <span class="FontName">setActiveProfiles()</span>, and via a Java runtime flag or web application initialization parameter you can use the <span class="FontName">spring.profiles.default</span> parameter instead of <span class="FontName">spring.profiles.active</span>.</p>
<p id="Sec79" class="Heading">3-12. Aspect Orientated programming<a id="cXXX.2007" class="calibre6"></a><a id="cXXX.273" class="calibre6"></a> with Annotations</p>
<p id="Sec80" class="Heading1">Problem</p>
<p class="noindent">You want to use aspect orientated programming with Spring and annotations.</p>
<p id="Sec81" class="Heading1">Solution</p>
<p class="noindent">You define<a id="cXXX.274" class="calibre5"></a> an aspect by decorating a Java class with the <span class="FontName">@Aspect</span> annotation. Each of the methods in a class can be become an advice with another annotation. You can use five types of advice annotations<a id="cXXX.2005" class="calibre5"></a><a id="cXXX.275" class="calibre5"></a>: <span class="FontName">@Before</span>, <span class="FontName">@After</span>, <span class="FontName">@AfterReturning</span>, <span class="FontName">@AfterThrowing</span>, and <span class="FontName">@Around</span>.</p>
<p class="indent">To enable annotation support in the Spring IoC container, you also have to define an empty XML element to activate AspectJ in your bean configuration file: <span class="FontName">&lt;aop:aspectj-autoproxy&gt;</span>. For cases in which interfaces are not available or not used in an application’s design, it’s possible to create proxies by relying on CGLIB. To enable CGLIB, you need to set the attribute <span class="FontName">&lt;proxy-target-class=true</span> in <span class="FontName">&lt;aop:aspectj-autoproxy&gt;</span>.</p>
<p id="Sec82" class="Heading1">How It Works</p>
<p class="noindent">To support aspect orientated programming with annotations, Spring uses the same annotations as AspectJ, using a library supplied by AspectJ for pointcut parsing and matching. Although the AOP runtime is still pure Spring AOP and there is no dependency on the AspectJ compiler or weaver.</p>
<p class="indent">To illustrate the enablement of aspect orientated programming with annotations, we’ll use the following calculator interfaces to define a set of sample POJOs<a id="cXXX.276" class="calibre5"></a>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface ArithmeticCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double add(double a, double b);</span><br class="calibre10"/>    <span class="FontName">public double sub(double a, double b);</span><br class="calibre10"/>    <span class="FontName">public double mul(double a, double b);</span><br class="calibre10"/>    <span class="FontName">public double div(double a, double b);</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface UnitCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double kilogramToPound(double kilogram);</span><br class="calibre10"/>    <span class="FontName">public double kilometerToMile(double kilometer);</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Next, let’s create POJO classes for each interface with println statements to know when each method is executed:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Component("arithmeticCalculator")</span><br class="calibre10"/><span class="FontName">public class ArithmeticCalculatorImpl implements ArithmeticCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double add(double a, double b) {</span><br class="calibre10"/>        <span class="FontName">double result = a + b;</span><br class="calibre10"/>        <span class="FontName">System.out.println(a + " + " + b + " = " + result);</span><br class="calibre10"/>        <span class="FontName">return result;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double sub(double a, double b) {</span><br class="calibre10"/>        <span class="FontName">double result = a - b;</span><br class="calibre10"/>        <span class="FontName">System.out.println(a + " - " + b + " = " + result);</span><br class="calibre10"/>        <span class="FontName">return result;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">public double mul(double a, double b) {</span><br class="calibre10"/>        <span class="FontName">double result = a * b;</span><br class="calibre10"/>        <span class="FontName">System.out.println(a + " * " + b + " = " + result);</span><br class="calibre10"/>        <span class="FontName">return result;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double div(double a, double b) {</span><br class="calibre10"/>        <span class="FontName">if (b == 0) {</span><br class="calibre10"/>            <span class="FontName">throw new IllegalArgumentException("Division by zero");</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">double result = a / b;</span><br class="calibre10"/>        <span class="FontName">System.out.println(a + " / " + b + " = " + result);</span><br class="calibre10"/>        <span class="FontName">return result;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Component("unitCalculator")</span><br class="calibre10"/><span class="FontName">public class UnitCalculatorImpl implements UnitCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double kilogramToPound(double kilogram) {</span><br class="calibre10"/>        <span class="FontName">double pound = kilogram * 2.2;</span><br class="calibre10"/>        <span class="FontName">System.out.println(kilogram + " kilogram = " + pound + " pound");</span><br class="calibre10"/>        <span class="FontName">return pound;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double kilometerToMile(double kilometer) {</span><br class="calibre10"/>        <span class="FontName">double mile = kilometer * 0.62;</span><br class="calibre10"/>        <span class="FontName">System.out.println(kilometer + " kilometer = " + mile + " mile");</span><br class="calibre10"/>        <span class="FontName">return mile;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Note that each POJO implementation is decorated with the <span class="FontName">@Component</span> annotation to create bean instances.</p>
<p id="Sec83" class="Heading2">Declare Aspects, Advices and Pointcuts</p>
<p class="noindent">An aspect is a Java class that modularizes a set of concerns (e.g., logging or transaction management) that cuts across multiple types and objects. Java classes that modularize such concerns are decorated with the <span class="FontName">@Aspect</span> annotation<a id="cXXX.277" class="calibre5"></a>.</p>
<p class="indent">In AOP terminology, aspects are also complemented by advices, which in themselves have pointcuts. An advice is a simple Java method with one of the advice annotations. AspectJ supports five types of advice annotations: <span class="FontName">@Before</span>, <span class="FontName">@After</span>, <span class="FontName">@AfterReturning</span>, <span class="FontName">@AfterThrowing</span>, and <span class="FontName">@Around</span>. Whereas a pointcut is an expression that looks for types and objects on which to apply the aspect’s advices.</p>
<p id="Sec84" class="Heading3">Aspect with @Before advice<a id="cXXX.278" class="calibre6"></a><a id="cXXX.279" class="calibre6"></a></p>
<p class="noindent">To create a before advice to handle crosscutting concerns before particular program execution points, you use the <span class="FontName">@Before</span> annotation and include the pointcut expression as the annotation value.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.apache.commons.logging.Log;</span><br class="calibre10"/><span class="FontName">import org.apache.commons.logging.LogFactory;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Before;</span><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Log log = LogFactory.getLog(this.getClass());</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before("execution(* ArithmeticCalculator.add(..))")</span><br class="calibre10"/>    <span class="FontName">public void logBefore() {</span><br class="calibre10"/>        <span class="FontName">log.info("The method add() begins");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">This pointcut expression matches the <span class="FontName">add()</span> method execution of the <span class="FontName">ArithmeticCalculator</span> interface. The preceding wildcard in this expression matches any modifier (public, protected, and private) and any return type. The two dots in the argument list match any number of arguments.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  For the previous aspect to work (i.e., Output its message) you need to setup logging. Specifically create a log4j.properties file with configuration properties like the following.</p>
<p class="paraaftertitle">log4j.rootLogger=INFO, A1<br class="calibre10"/>log4j.appender.A1=org.apache.log4j.ConsoleAppender<br class="calibre10"/>log4j.appender.A1.layout=org.apache.log4j.PatternLayout<br class="calibre10"/>log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n</p>
<p class="paraaftertitle">The @Aspect annotation is not sufficient for autodetection in the classpath. Therefore you need to add a separate @Component annotation for the POJO to be detected.</p></div>
<p class="indent">Next, you create an XML Spring configuration to scan all POJOs, including the POJO calculator implementation and aspect, as well as include the <span class="FontName">&lt;aop:aspectj-autoproxy&gt;</span> tag.</p>
<pre class="calibre11"><span class="FontName">&lt;beans   xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:context="</span><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:aop="</span><span class="FontName"><a href="http://www.springframework.org/schema/aop" class="calibre5">http://www.springframework.org/schema/aop</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/context/spring-context-3.2.xsd" class="calibre5">http://www.springframework.org/schema/context/spring-context-3.2.xsd</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/aop" class="calibre5">http://www.springframework.org/schema/aop</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/aop/spring-aop-3.2.xsd" class="calibre5">http://www.springframework.org/schema/aop/spring-aop-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;aop:aspectj-autoproxy/&gt;</span>  <br class="calibre10"/>    <span class="FontName">&lt;context:component-scan base-package="com.apress.springrecipes.calculator"/&gt;</span>  <br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">And as the last step you can test the aspect with the following Main class:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span><br class="calibre10"/>            <span class="FontName">new GenericXmlApplicationContext("appContext.xml");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">ArithmeticCalculator arithmeticCalculator =</span><br class="calibre10"/>        <span class="FontName">(ArithmeticCalculator) context.getBean("arithmeticCalculator");</span><br class="calibre10"/>        <span class="FontName">arithmeticCalculator.add(1, 2);</span><br class="calibre10"/>        <span class="FontName">arithmeticCalculator.sub(4, 3);</span><br class="calibre10"/>        <span class="FontName">arithmeticCalculator.mul(2, 3);</span><br class="calibre10"/>        <span class="FontName">arithmeticCalculator.div(4, 2);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">UnitCalculator unitCalculator =</span><br class="calibre10"/>        <span class="FontName">(UnitCalculator) context.getBean("unitCalculator");</span><br class="calibre10"/>        <span class="FontName">unitCalculator.kilogramToPound(10);</span><br class="calibre10"/>        <span class="FontName">unitCalculator.kilometerToMile(5);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The execution points matched by a pointcut are called join points. In this term, a pointcut is an expression to match a set of join points, while an advice is the action to take at a particular join point.</p>
<p class="indent">For your advice to access the detail of the current join point, you can declare an argument of type JoinPoint in your advice method. Then, you can get access to join point details such as the method name and argument values. Now, you can expand your pointcut to match all methods by changing the class name and method name to wildcards.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import java.util.Arrays;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.aspectj.lang.JoinPoint;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Before;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Before("execution(* *.*(..))")</span><br class="calibre10"/>    <span class="FontName">public void logBefore(JoinPoint joinPoint) {</span><br class="calibre10"/>        <span class="FontName">log.info("The method " + joinPoint.getSignature().getName()</span><br class="calibre10"/>                <span class="FontName">+ "() begins with " + Arrays.toString(joinPoint.getArgs()));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec85" class="Heading3">Aspect with @After advice<a id="cXXX.280" class="calibre6"></a><a id="cXXX.281" class="calibre6"></a></p>
<p class="noindent">An after advice is executed after a join point finishes, whenever it returns a result or throws an exception abnormally. The following after advice logs the calculator method ending.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.JoinPoint;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.After;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public</span> <span class="FontName">class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@After("execution(* *.*(..))")</span><br class="calibre10"/>    <span class="FontName">public void logAfter(JoinPoint joinPoint) {</span><br class="calibre10"/>        <span class="FontName">log.info("The method " + joinPoint.getSignature().getName()</span><br class="calibre10"/>                <span class="FontName">+ "() ends");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec86" class="Heading3">Aspect with @AfterReturning advice<a id="cXXX.282" class="calibre6"></a><a id="cXXX.283" class="calibre6"></a></p>
<p class="noindent">An after advice is executed regardless of whether a join point returns normally or throws an exception. If you would like to perform logging only when a join point returns, you should replace the after advice with an after returning advice.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.JoinPoint;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.AfterReturning;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@AfterReturning("execution(* *.*(..))")</span><br class="calibre10"/>    <span class="FontName">public void logAfterReturning(JoinPoint joinPoint) {</span><br class="calibre10"/>        <span class="FontName">log.info("The method " + joinPoint.getSignature().getName()</span><br class="calibre10"/>                <span class="FontName">+ "() ends");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In an after returning advice, you can get access to the return value of a join point by adding a returning attribute to the <span class="FontName">@AfterReturning</span> annotation. The value of this attribute should be the argument name of this advice method for the return value to pass in. Then, you have to add an argument to the advice method signature with this name. At runtime, Spring AOP will pass in the return value through this argument. Also note that the original pointcut expression needs to be presented in the pointcut attribute instead.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.JoinPoint;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.AfterReturning;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName"></span><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@AfterReturning(</span><br class="calibre10"/>        <span class="FontName">pointcut = "execution(* *.*(..))",</span><br class="calibre10"/>        <span class="FontName">returning = "result")</span><br class="calibre10"/>    <span class="FontName">public void logAfterReturning(JoinPoint joinPoint, Object result) {</span><br class="calibre10"/>        <span class="FontName">log.info("The method " + joinPoint.getSignature().getName()</span><br class="calibre10"/>                <span class="FontName">+ "() ends with " + result);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec87" class="Heading3">Aspect with @AfterThrowing advice<a id="cXXX.284" class="calibre6"></a><a id="cXXX.285" class="calibre6"></a></p>
<p class="noindent">An after throwing advice is executed only when an exception is thrown by a join point.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.JoinPoint;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.AfterThrowing;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@AfterThrowing("execution(* *.*(..))")</span><br class="calibre10"/>    <span class="FontName">public void logAfterThrowing(JoinPoint joinPoint) {</span><br class="calibre10"/>        <span class="FontName">log.error("An exception has been thrown in "</span><br class="calibre10"/>                <span class="FontName">+ joinPoint.getSignature().getName() + "()");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Similarly, the exception thrown by the join point can be accessed by adding a throwing attribute to the <span class="FontName">@AfterThrowing</span> annotation. The type Throwable is the superclass of all errors and exceptions in the Java language. So, the following advice will catch any of the errors and exceptions thrown by the join points:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.JoinPoint;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.AfterThrowing;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@AfterThrowing(</span><br class="calibre10"/>        <span class="FontName">pointcut = "execution(* *.*(..))",</span><br class="calibre10"/>        <span class="FontName">throwing = "e")</span><br class="calibre10"/>    <span class="FontName">public void logAfterThrowing(JoinPoint joinPoint, Throwable e) {</span><br class="calibre10"/>        <span class="FontName">log.error("An exception " + e + " has been thrown in "</span><br class="calibre10"/>                <span class="FontName">+ joinPoint.getSignature().getName() + "()");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">However, if you are interested in one particular type of exception only, you can declare it as the argument type of the exception. Then your advice will be executed only when exceptions of compatible type (i.e., this type and its subtypes) are thrown.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import java.util.Arrays;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.aspectj.lang.JoinPoint;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.AfterThrowing;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@AfterThrowing(</span><br class="calibre10"/>        <span class="FontName">pointcut = "execution(* *.*(..))",</span><br class="calibre10"/>        <span class="FontName">throwing = "e")</span><br class="calibre10"/>    <span class="FontName">public void logAfterThrowing(JoinPoint joinPoint,</span><br class="calibre10"/>            <span class="FontName">IllegalArgumentException e) {</span><br class="calibre10"/>        <span class="FontName">log.error("Illegal argument " + Arrays.toString(joinPoint.getArgs())</span><br class="calibre10"/>                <span class="FontName">+ " in " + joinPoint.getSignature().getName() + "()");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec88" class="Heading3">Aspect with @Around advice<a id="cXXX.286" class="calibre6"></a><a id="cXXX.287" class="calibre6"></a></p>
<p class="noindent">The last type of advice is an around advice. It is the most powerful of all the advice types. It gains full control of a join point, so you can combine all the actions of the preceding advices into one single advice. You can even control when, and whether, to proceed with the original join point execution.</p>
<p class="indent">The following around advice is the combination of the before, after returning, and after throwing advices you created before. Note that for an around advice, the argument type of the join point must be ProceedingJoinPoint. It’s a subinterface of JoinPoint that allows you to control when to proceed with the original join point.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import java.util.Arrays;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.aspectj.lang.ProceedingJoinPoint;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Around;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public</span> <span class="FontName">class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Around("execution(* *.*(..))")</span><br class="calibre10"/>    <span class="FontName">public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {</span><br class="calibre10"/>        <span class="FontName">log.info("The method " + joinPoint.getSignature().getName()</span><br class="calibre10"/>                <span class="FontName">+ "() begins with " + Arrays.toString(joinPoint.getArgs()));</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">Object result = joinPoint.proceed();</span><br class="calibre10"/>            <span class="FontName">log.info("The method " + joinPoint.getSignature().getName()</span><br class="calibre10"/>                    <span class="FontName">+ "() ends with " + result);</span><br class="calibre10"/>            <span class="FontName">return result;</span><br class="calibre10"/>        <span class="FontName">} catch (IllegalArgumentException e) {</span><br class="calibre10"/>            <span class="FontName">log.error("Illegal argument "</span><br class="calibre10"/>                    <span class="FontName">+ Arrays.toString(joinPoint.getArgs()) + " in "</span><br class="calibre10"/>                    <span class="FontName">+ joinPoint.getSignature().getName() + "()");</span><br class="calibre10"/>            <span class="FontName">throw e;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The around advice type is very powerful and flexible in that you can even alter the original argument values and change the final return value. You must use this type of advice with great care, as the call to proceed with the original join point may easily be forgotten.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Tip</b>  A common rule for choosing an advice type is to use the least powerful one that can satisfy your requirements.</p></div>
<p id="Sec89" class="Heading">3-13. Accessing the Join Point Information</p>
<p id="Sec90" class="Heading1">Problem</p>
<p class="noindent">In<a id="cXXX.288" class="calibre5"></a> AOP, an advice is applied to different program execution points, which are called join points<a id="cXXX.289" class="calibre5"></a>. For an advice to take the correct action, it often requires detailed information about join points.</p>
<p id="Sec91" class="Heading1">Solution</p>
<p class="noindent">An advice can access the current join point information by declaring an argument of type <span class="FontName">org.aspectj.lang.JoinPoint</span> in the advice method signature.</p>
<p id="Sec92" class="Heading1">How It Works</p>
<p class="noindent">For example, you can access the join point information through the following advice. The information includes the join point kind (only method-execution in Spring AOP), the method signature (declaring type and method name), and the argument values, as well as the target object and proxy object.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import java.util.Arrays;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.aspectj.lang.JoinPoint;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Before;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Before("execution(* *.*(..))")</span><br class="calibre10"/>    <span class="FontName">public void logJoinPoint(JoinPoint joinPoint) {</span><br class="calibre10"/>        <span class="FontName">log.info("Join point kind : "</span><br class="calibre10"/>                <span class="FontName">+ joinPoint.getKind());</span><br class="calibre10"/>        <span class="FontName">log.info("Signature declaring type : "</span><br class="calibre10"/>                <span class="FontName">+ joinPoint.getSignature().getDeclaringTypeName());</span><br class="calibre10"/>        <span class="FontName">log.info("Signature name : "</span><br class="calibre10"/>                <span class="FontName">+ joinPoint.getSignature().getName());</span><br class="calibre10"/>        <span class="FontName">log.info("Arguments : "</span><br class="calibre10"/>                <span class="FontName">+ Arrays.toString(joinPoint.getArgs()));</span><br class="calibre10"/>        <span class="FontName">log.info("Target class : "</span><br class="calibre10"/>                <span class="FontName">+ joinPoint.getTarget().getClass().getName());</span><br class="calibre10"/>        <span class="FontName">log.info("This class : "</span><br class="calibre10"/>                <span class="FontName">+ joinPoint.getThis().getClass().getName());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The original bean that was wrapped by a proxy is called the target object, while the proxy object is called the this object. They can be accessed by the join point’s <span class="FontName">getTarget()</span>and <span class="FontName">getThis()</span>methods. From the following outputs, you can see that the classes of these two objects are not the same:</p>
<pre class="calibre11"><span class="FontName">Join point kind : method-execution</span><br class="calibre10"/><span class="FontName">Signature declaring type : com.apress.springrecipes.calculator.ArithmeticCalculator</span><br class="calibre10"/><span class="FontName">Signature name : add</span><br class="calibre10"/><span class="FontName">Arguments</span> <span class="FontName">: [1.0, 2.0]</span><br class="calibre10"/><span class="FontName">Target class : com.apress.springrecipes.calculator.ArithmeticCalculatorImpl</span><br class="calibre10"/><span class="FontName">This</span> <span class="FontName">class : com.sun.proxy.$Proxy6</span></pre><p id="Sec93" class="Heading">3-14. Specifying Aspect Precedence with the @Order annotation<a id="cXXX.290" class="calibre6"></a></p>
<p id="Sec94" class="Heading1">Problem<a id="cXXX.291" class="calibre6"></a></p>
<p class="noindent">When there’s more than one aspect applied to the same join point, the precedence of the aspects is undefined unless you have explicitly specified it.</p>
<p id="Sec95" class="Heading1">Solution</p>
<p class="noindent">The precedence of aspects can be specified either by implementing the <span class="FontName">Ordered</span> interface or by using the <span class="FontName">@Order</span> annotation.</p>
<p id="Sec96" class="Heading1">How It Works</p>
<p class="noindent">Suppose you have written another aspect to validate the calculator arguments. There’s only one before advice in this aspect.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.aspectj.lang.JoinPoint;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Before;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class CalculatorValidationAspect {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before("execution(* *.*(double, double))")</span><br class="calibre10"/>    <span class="FontName">public void validateBefore(JoinPoint joinPoint) {</span><br class="calibre10"/>        <span class="FontName">for (Object arg : joinPoint.getArgs()) {</span><br class="calibre10"/>            <span class="FontName">validate((Double) arg);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private void validate(double a) {</span><br class="calibre10"/>        <span class="FontName">if (a &lt; 0) {</span><br class="calibre10"/>            <span class="FontName">throw new IllegalArgumentException("Positive numbers only");</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">If you apply this aspect and the previous you can’t guarantee which one is applied first. To guarantee that one aspect is applied before another you need to specify precedence. To specify precedence, you have to make both aspects implement the <span class="FontName">Ordered</span> interface or use the <span class="FontName">@Order</span> annotation.</p>
<p class="indent">If you decide to implement the <span class="FontName">Ordered</span> interface, the lower value returned by the <span class="FontName">getOrder</span> method represents higher priority. So, if you prefer the validation aspect to be applied first, it should return a value lower than the logging aspect.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.core.Ordered;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class CalculatorValidationAspect implements Ordered {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public int getOrder() {</span><br class="calibre10"/>        <span class="FontName">return 0;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.core.Ordered;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect implements Ordered {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public int getOrder() {</span><br class="calibre10"/>        <span class="FontName">return 1;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Another way to specify precedence is through the <span class="FontName">@Order</span> annotation. The order number should be presented in the annotation value.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.core.annotation.Order;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">@Order</span><span class="FontName">(0)</span><br class="calibre10"/><span class="FontName">public class CalculatorValidationAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.core.annotation.Order;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">@Order(1)</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec97" class="Heading">3-15. Reuse Aspect Pointcut<a id="cXXX.292" class="calibre6"></a> Definitions</p>
<p id="Sec98" class="Heading1">Problem<a id="cXXX.293" class="calibre6"></a></p>
<p class="noindent">When writing aspects, you can directly embed a pointcut expression in an advice annotation. You want to use the same pointcut expression in multiple advices without embedding it multiple times.</p>
<p id="Sec99" class="Heading1">Solution</p>
<p class="noindent">You can use the <span class="FontName">@Pointcut</span> annotation to define a pointcut independently to be reused in multiple advices.</p>
<p id="Sec100" class="Heading1">How It Works</p>
<p class="noindent">In an aspect, a pointcut can be declared as a simple method with the <span class="FontName">@Pointcut</span> annotation. The method body of a pointcut is usually empty, as it is unreasonable to mix a pointcut definition with application logic. The access modifier of a pointcut method controls the visibility of this pointcut as well. Other advices can refer to this pointcut by the method name.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Pointcut;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Pointcut("execution(* *.*(..))")</span><br class="calibre10"/>    <span class="FontName">private void loggingOperation() {}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before("loggingOperation()")</span><br class="calibre10"/>    <span class="FontName">public void logBefore(JoinPoint joinPoint) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@AfterReturning(</span><br class="calibre10"/>        <span class="FontName">pointcut = "loggingOperation()",</span><br class="calibre10"/>        <span class="FontName">returning = "result")</span><br class="calibre10"/>    <span class="FontName">public void logAfterReturning(JoinPoint joinPoint, Object result) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@AfterThrowing(</span><br class="calibre10"/>        <span class="FontName">pointcut = "loggingOperation()",</span><br class="calibre10"/>        <span class="FontName">throwing = "e")</span><br class="calibre10"/>    <span class="FontName">public void logAfterThrowing(JoinPoint joinPoint, IllegalArgumentException e) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Around("loggingOperation()")</span><br class="calibre10"/>    <span class="FontName">public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Usually, if your pointcuts are shared between multiple aspects, it is better to centralize them in a common class. In this case, they must be declared as public.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Pointcut;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class CalculatorPointcuts {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Pointcut("execution(* *.*(..))")</span><br class="calibre10"/>    <span class="FontName">public void loggingOperation() {}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">When you refer to this pointcut, you have to include the class name as well. If the class is not located in the same package as the aspect, you have to include the package name also.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Before("CalculatorPointcuts.loggingOperation()")</span><br class="calibre10"/>    <span class="FontName">public void logBefore(JoinPoint joinPoint) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@AfterReturning(</span><br class="calibre10"/>        <span class="FontName">pointcut = "CalculatorPointcuts.loggingOperation()",</span><br class="calibre10"/>        <span class="FontName">returning = "result")</span><br class="calibre10"/>    <span class="FontName">public void logAfterReturning(JoinPoint joinPoint, Object result) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@AfterThrowing(</span><br class="calibre10"/>        <span class="FontName">pointcut = "CalculatorPointcuts.loggingOperation()",</span><br class="calibre10"/>        <span class="FontName">throwing = "e")</span><br class="calibre10"/>    <span class="FontName">public void logAfterThrowing(JoinPoint joinPoint, IllegalArgumentException e) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Around("CalculatorPointcuts.loggingOperation()")</span><br class="calibre10"/>    <span class="FontName">public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec101" class="Heading">3-16. Writing<a id="cXXX.294" class="calibre6"></a> AspectJ Pointcut Expressions</p>
<p id="Sec102" class="Heading1">Problem</p>
<p class="noindent">Crosscutting concerns can happen at different program execution points, which are called join points. Because of the variety of join points, you need a powerful expression language to help match them.</p>
<p id="Sec103" class="Heading1">Solution</p>
<p class="noindent">The AspectJ pointcut language is a powerful expression language that can match various kinds of join points. However, Spring AOP only supports method execution join points for beans declared in its IoC container. For this reason, only those pointcut expressions supported by Spring AOP are presented in this recipe. For a full description of the AspectJ pointcut language, please refer to the AspectJ programming guide available on AspectJ’s web site (<span class="FontName"><a href="http://www.eclipse.org/aspectj/" class="calibre5">http://www.eclipse.org/aspectj/</a></span>).</p>
<p class="indent">Spring AOP makes use of the AspectJ pointcut language for its pointcut definition and interprets the pointcut expressions at runtime by using a library provided by AspectJ.</p>
<p class="indent">When writing AspectJ pointcut expressions for Spring AOP<a id="cXXX.295" class="calibre5"></a>, you must keep in mind that Spring AOP only supports method execution join points for the beans in its IoC container. If you use a pointcut expression out of this scope, an <span class="FontName">IllegalArgumentException</span> is thrown.</p>
<p id="Sec104" class="Heading1">How It Works</p>
<p id="Sec105" class="Heading2">Method Signature Patterns</p>
<p class="noindent">The most typical pointcut expressions are used to match a number of methods by their signatures. For example, the following pointcut expression matches all of the methods declared in the <span class="FontName">ArithmeticCalculator</span> interface<a id="cXXX.296" class="calibre5"></a>. The initial wildcard matches methods with any modifier (public, protected, and private) and any return type. The two dots in the argument list match any number of arguments.</p>
<pre class="calibre11"><span class="FontName">execution(* com.apress.springrecipes.calculator.ArithmeticCalculator.*(..))</span></pre><p class="indent">You can omit the package name if the target class or interface is located in the same package as the aspect.</p>
<pre class="calibre11"><span class="FontName">execution(* ArithmeticCalculator.*(..))</span></pre><p class="indent">The following pointcut expression matches all the public methods declared in the <span class="FontName">ArithmeticCalculator</span> interface:</p>
<pre class="calibre11"><span class="FontName">execution(public * ArithmeticCalculator.*(..))</span></pre><p class="indent">You can also restrict the method return type. For example, the following pointcut matches the methods that return a double number:</p>
<pre class="calibre11"><span class="FontName">execution(public double ArithmeticCalculator.*(..))</span></pre><p class="indent">The argument list of the methods can also be restricted. For example, the following pointcut matches the methods whose first argument is of primitive double type. The two dots then match any number of followed arguments.</p>
<pre class="calibre11"><span class="FontName">execution(public double ArithmeticCalculator.*(double, ..))</span></pre><p class="indent">Or, you can specify all the argument types in the method signature for the pointcut to match.</p>
<pre class="calibre11"><span class="FontName">execution(public double ArithmeticCalculator.*(double, double))</span></pre><p class="indent">Although the AspectJ pointcut language<a id="cXXX.2006" class="calibre5"></a> is powerful in matching various join points, sometimes, you may not be able to find any common characteristics (e.g., modifiers, return types, method name patterns, or arguments) for the methods you would like to match. In such cases, you can consider providing a custom annotation for them. For instance, you can define the following marker annotation<a id="cXXX.297" class="calibre5"></a>. This annotation can be applied to both method level and type level.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.lang.annotation.Documented;</span><br class="calibre10"/><span class="FontName">import java.lang.annotation.ElementType;</span><br class="calibre10"/><span class="FontName">import java.lang.annotation.Retention;</span><br class="calibre10"/><span class="FontName">import java.lang.annotation.RetentionPolicy;</span><br class="calibre10"/><span class="FontName">import java.lang.annotation.Target;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Target( { ElementType.METHOD, ElementType.TYPE })</span><br class="calibre10"/><span class="FontName">@Retention(RetentionPolicy.RUNTIME)</span><br class="calibre10"/><span class="FontName">@Documented</span><br class="calibre10"/><span class="FontName">public @interface LoggingRequired {</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Next, you can annotate all methods that require logging with this annotation or the class itself to apply the behavior to all methods. Note that the annotations must be added to the implementation class but not the interface, as they will not be inherited.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@LoggingRequired</span><br class="calibre10"/><span class="FontName">public class ArithmeticCalculatorImpl implements ArithmeticCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double add(double a, double b) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double sub(double a, double b) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Then you can write a pointcut expression to match a class or methods with the <span class="FontName">@LoggingRequired</span> annotation<a id="cXXX.298" class="calibre5"></a> using the <span class="FontName">annotation</span> keyword on <span class="FontName">@Pointcut</span> annotation.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Pointcut;</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class CalculatorPointcuts {</span><br class="calibre10"/><br class="calibre10"/>      <span class="FontName">@Pointcut("annotation(com.apress.springrecipes.calculator.LoggingRequired)")</span><br class="calibre10"/>      <span class="FontName">public void loggingOperation() {}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec106" class="Heading2">Type Signature Patterns<a id="cXXX.299" class="calibre6"></a></p>
<p class="noindent">Another kind of pointcut expressions matches all join points within certain types. When applied to Spring AOP, the scope of these pointcuts will be narrowed to matching all method executions within the types. For example, the following pointcut matches all the method execution join points within the <span class="FontName">com.apress.springrecipes.calculator</span> package:</p>
<pre class="calibre11"><span class="FontName">within(com.apress.springrecipes.calculator.*)</span></pre><p class="indent">To match the join points within a package and its subpackage, you have to add one more dot before the wildcard.</p>
<pre class="calibre11"><span class="FontName">within(com.apress.springrecipes.calculator..*)</span></pre><p class="indent">The following pointcut expression matches the method execution join points within a particular class:</p>
<pre class="calibre11"><span class="FontName">within(com.apress.springrecipes.calculator.ArithmeticCalculatorImpl)</span></pre><p class="indent">Again, if the target class is located in the same package as this aspect, the package name can be omitted.</p>
<pre class="calibre11"><span class="FontName">within(ArithmeticCalculatorImpl)</span></pre><p class="indent">You can match the method execution join points within all classes that implement the ArithmeticCalculator interface by adding a plus symbol.</p>
<pre class="calibre11"><span class="FontName">within(ArithmeticCalculator+)</span></pre><p class="indent">The custom annotation <span class="FontName">@LoggingRequired</span> can be applied to the class or method level as illustrated previously.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@LoggingRequired</span><br class="calibre10"/><span class="FontName">public class ArithmeticCalculatorImpl implements ArithmeticCalculator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">And then you can match the join points within the classes or methods that have been annotated with <span class="FontName">@LoggingRequired</span> using the <span class="FontName">within</span> keyword on <span class="FontName">@Pointcut</span> annotation.</p>
<pre class="calibre11"><span class="FontName">@Pointcut("within(com.apress.springrecipes.calculator.LoggingRequired)")</span><br class="calibre10"/><span class="FontName">public void loggingOperation() {}</span></pre><p id="Sec107" class="Heading2">Combining Pointcut Expressions</p>
<p class="noindent">In AspectJ, pointcut expressions can be combined with the operators<a id="cXXX.300" class="calibre5"></a> &amp;&amp; (and), || (or), and ! (not). For example, the following pointcut matches the join points within classes that implement either the <span class="FontName">ArithmeticCalculator</span> or <span class="FontName">UnitCalculator</span> interface:</p>
<pre class="calibre11"><span class="FontName">within(ArithmeticCalculator+) || within(UnitCalculator+)</span></pre><p class="indent">The operands of these operators can be any pointcut expressions or references to other pointcuts.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Pointcut;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public</span> <span class="FontName">class CalculatorPointcuts {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Pointcut("within(ArithmeticCalculator+)")</span><br class="calibre10"/>    <span class="FontName">public void arithmeticOperation() {}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Pointcut("within(UnitCalculator+)")</span><br class="calibre10"/>    <span class="FontName">public void unitOperation() {}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Pointcut("arithmeticOperation() || unitOperation()")</span><br class="calibre10"/>    <span class="FontName">public void loggingOperation() {}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec108" class="Heading2">Declaring<a id="cXXX.301" class="calibre6"></a> Pointcut Parameters</p>
<p class="noindent">One way to access join point information is by reflection (i.e., via an argument of type <span class="FontName">org.aspectj.lang.JoinPoint</span> in the advice method). Besides, you can access join point information in a declarative way by using some kinds of special pointcut expressions. For example, the expressions <span class="FontName">target()</span> and <span class="FontName">args()</span> capture the target object and argument values of the current join point and expose them as pointcut parameters. These parameters are passed to your advice method via arguments of the same name.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Before;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Before("execution(* *.*(..)) &amp;&amp; target(target) &amp;&amp; args(a,b)")</span><br class="calibre10"/>    <span class="FontName">public void logParameter(Object target, double a, double b) {</span><br class="calibre10"/>        <span class="FontName">log.info("Target class : " + target.getClass().getName());</span><br class="calibre10"/>        <span class="FontName">log.info("Arguments : " + a + ", " + b);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">When declaring an independent pointcut that exposes parameters, you have to include them in the argument list of the pointcut method as well.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import</span> <span class="FontName">org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Pointcut;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class CalculatorPointcuts {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Pointcut("execution(* *.*(..)) &amp;&amp; target(target) &amp;&amp; args(a,b)")</span><br class="calibre10"/>    <span class="FontName">public void parameterPointcut(Object target, double a, double b) {}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Any advice that refers to this parameterized pointcut can access the pointcut parameters via method arguments of the same name.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Aspect;</span><br class="calibre10"/><span class="FontName">import org.aspectj.lang.annotation.Before;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Aspect</span><br class="calibre10"/><span class="FontName">public class CalculatorLoggingAspect {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Before("CalculatorPointcuts.parameterPointcut(target, a, b)")</span><br class="calibre10"/>    <span class="FontName">public void logParameter(Object target, double a, double b) {</span><br class="calibre10"/>        <span class="FontName">log.info("Target class : " + target.getClass().getName());</span><br class="calibre10"/>        <span class="FontName">log.info("Arguments : " + a + ", " + b);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec109" class="Heading">3-17. AOP<a id="cXXX.302" class="calibre6"></a> introductions for POJOs</p>
<p id="Sec110" class="Heading1">Problem</p>
<p class="noindent">Sometimes, you may have a group of classes that share a common behavior. In OOP, they must extend the same base class or implement the same interface. This issue is actually a crosscutting concern that can be modularized with AOP.</p>
<p class="indent">In addition, the single inheritance mechanism of Java only allows a class to extend one base class at most. So, you cannot inherit behaviors from multiple implementation classes at the same time.</p>
<p id="Sec111" class="Heading1">Solution</p>
<p class="noindent">An Introduction is a special type of advice in AOP. It allows objects to implement an interface dynamically by providing an implementation class for that interface. It seems as if objects extend an implementation class at runtime.</p>
<p class="indent">Moreover, you are able to introduce multiple interfaces<a id="cXXX.303" class="calibre5"></a> with multiple implementation classes to your objects at the same time. This can achieve the same effect as multiple inheritance.</p>
<p id="Sec112" class="Heading1">How It Works</p>
<p class="noindent">Suppose you have two interfaces, MaxCalculator and MinCalculator, to define the <span class="FontName">max()</span> and <span class="FontName">min()</span> operations.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface MaxCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double max(double a, double b);</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.calculator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface MinCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double min(double a, double b);</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Then you have an implementation for each interface with <span class="FontName">println</span> statements to let you know when the methods are executed.</p></div>
</body></html>
