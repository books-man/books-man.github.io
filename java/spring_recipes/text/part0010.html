<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Chapter 2 Spring Core Tasks</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre"><p class="ChapterNumber"><a id="b9781430259084_2" class="calibre6"></a>CHAPTER 2</p><p class="Chapimage"><img src="../images/00008.jpeg" alt="image" class="calibre3"/></p><p class="ChapterTitle">Spring Core Tasks</p><div class="calibre10"><p class="noindent"><a id="cXXX.62" class="calibre5"></a>In this chapter, you’ll learn about the core tasks associated with Spring. At the heart of the Spring framework is the Spring Inversion of Control (IoC) container. The IoC container is used to manage and configure POJOs or Plain Old Java Objects.<a id="_Fn1" href="part0011.html#Fn1" class="calibre5"><sup class="calibre9">1</sup></a> Because one of the primary appeals of the Spring framework is to build Java applications with POJOs, many of Spring’s core tasks involve managing and configuring POJOs in the IoC container.</p><p class="indent">So whether you plan to use the Spring framework for web applications, enterprise integration, or some other type of project, working with POJOs and the IoC container is one of the first steps you need to take to work with the Spring framework. The majority of the recipes in this chapter cover tasks that you’ll use throughout the book and on a daily basis to develop Spring applications.</p><div class="notepara"><p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  The term ‘bean’ is used interchangeably with a POJO instance both in the book and the Spring documentation. Both refer to an object instance created from a Java class. The term ‘component’ is used interchangeably with a POJO class both in the book and the Spring documentation. Both refer to the actual Java class from which object instances are created.</p></div>
<p class="indent">The source code download is organized to use gradle to build the different Recipe applications. Gradle takes care of loading all the necessary Java classes, dependencies and creating an executable. <a href="part0009.html" class="calibre5">Chapter 1</a> describes how to setup the Gradle tool. Furthermore, if a Recipe illustrates more than one approach, the source code is classified with various examples with roman letters (e.g., Recipe_2_1_i, Recipe_2_1_ii, Recipe_2_1_iii, etc.).</p><div class="notepara"><p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To build each application, go inside the Recipe directory (e.g., <span class="FontName">Ch2/Recipe_2_1_i/</span>) and execute the <span class="FontName">gradle</span> command to compile the source code. Once the source code is compiled, a <span class="FontName">build/libs</span> sub-directory is created with the application executable. You can then run the application JAR from the command line (e.g., <span class="FontName">java -jar Recipe_2_1_i-1.0.SNAPSHOT.jar)</span></p></div>
<p id="Sec1" class="Heading">2-1. Manage and Configure POJOs with the Spring IoC Container</p><p id="Sec2" class="Heading1">Problem</p><p class="noindent">You want to manage POJOs with Spring’s IoC container.</p><p id="Sec3" class="Heading1">Solution</p><p class="noindent">Design a POJO class. Next, configure POJO instance values for the Spring IoC container in an XML file<a id="cXXX.2139" class="calibre5"></a>. Next, instantiate the Spring IoC container to gain access to the POJO instance values defined in an<a id="cXXX.63" class="calibre5"></a> XML file. The POJO instances or bean instances become accessible to put together as part of an application.</p><p id="Sec4" class="Heading1">How It Works</p><p class="noindent">Suppose you are going to develop an application to generate sequence numbers. And that you are also going to need many series of sequence numbers for different purposes. Each sequence will have its own prefix, suffix, and initial value. So you have to create and maintain multiple generator instances for the application.</p><p id="Sec5" class="Heading2">Create the POJO Class</p><p class="noindent">Let’s create a <span class="FontName">SequenceGenerator</span> class<a id="cXXX.64" class="calibre5"></a> that has three properties— <span class="FontName">prefix, suffix</span>, and <span class="FontName">initial</span><a id="cXXX.2138" class="calibre5"></a>. The class will have a private field <span class="FontName">counter</span> to store the numeric value of each generator. Each time you call the <span class="FontName">getSequence()</span> method on a generator instance, you get the last sequence number with the prefix and suffix joined. You declare this last method as synchronized to make it thread-safe.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">private String prefix;</span><br class="calibre10"/>    <span class="FontName">private String suffix;</span><br class="calibre10"/>    <span class="FontName">private int initial;</span><br class="calibre10"/>    <span class="FontName">private int counter;</span><br class="calibre10"/>    <span class="FontName">public SequenceGenerator() {}</span><br class="calibre10"/>    <span class="FontName">public SequenceGenerator(String prefix, String suffix, int initial) {</span><br class="calibre10"/>        <span class="FontName">this.prefix = prefix;</span><br class="calibre10"/>        <span class="FontName">this.suffix = suffix;</span><br class="calibre10"/>        <span class="FontName">this.initial = initial;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">public void setPrefix(String prefix) {</span><br class="calibre10"/>        <span class="FontName">this.prefix = prefix;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setSuffix(String suffix) {</span><br class="calibre10"/>        <span class="FontName">this.suffix = suffix;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setInitial(int initial) {</span><br class="calibre10"/>        <span class="FontName">this.initial = initial;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">public synchronized String getSequence() {</span><br class="calibre10"/>        <span class="FontName">StringBuffer buffer = new StringBuffer();</span><br class="calibre10"/>        <span class="FontName">buffer.append(prefix);</span><br class="calibre10"/>        <span class="FontName">buffer.append(initial + counter++);</span><br class="calibre10"/>        <span class="FontName">buffer.append(suffix);</span><br class="calibre10"/>        <span class="FontName">return buffer.toString();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Note this last <span class="FontName">SequenceGenerator</span> class can be instantiated by setter methods or by a standard Java constructor. When you use the Spring IoC container to initialize POJOs, if you use the standard Java constructor the mechanism is called constructor injection<a id="cXXX.65" class="calibre5"></a>, where as if you use setter methods the mechanism is called setter injection<a id="cXXX.66" class="calibre5"></a>.</p><p id="Sec6" class="Heading2">Create a XML Configuration<a id="cXXX.2137" class="calibre6"></a> for your POJO</p><p class="noindent"><a id="cXXX.67" class="calibre5"></a><a id="cXXX.68" class="calibre5"></a>To define instances of a POJO class in the Spring IoC container, you have to create an XML configuration with instantiation values.</p><p class="indent">Spring XML configuration files can have any name, but by convention we’ll call the configuration file <span class="FontName">beans.xml</span>. You can put this file in the root of the classpath for easier testing within an IDE.</p><div class="notepara"><p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Tip</b>  Spring allows you to configure POJO instances or beans in one or more XML configuration files. For a simple application, you can just centralize your beans in a single configuration file (e.g., <span class="FontName">beans.xml</span>). But for a large application with a lot of beans, you should separate them in multiple configuration files according to their functionalities (e.g., DAOs and controllers). One useful division is by the architectural layer of context services. Recipe 2-3, section ‘Resolve POJO references from multiple locations’ describes this process.</p></div>
<p class="indent">The Spring XML configuration allows you to use custom tags from different schemas (tx, jndi, jee, and so on) to make the bean configuration simpler and clearer. Here’s an example of the simplest XML configuration possible.</p><pre class="calibre11"><span class="FontName">&lt;beans   xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">Each POJO instance or bean should have a unique name or id and a fully qualified POJO class name so the Spring IoC container to instantiate it. For each bean property of a simple type (e.g., String and other primitive types), you can specify a <span class="FontName">&lt;value&gt;</span> element for it. Spring will attempt to convert your value into the declaring type of this property. To configure a property via setter injection, you use the <span class="FontName">&lt;property&gt;</span> element and specify the property name in its name attribute. A <span class="FontName">&lt;property&gt;</span> requires that the underlying POJO class contain a corresponding setter method.</p><pre class="calibre11"><span class="FontName">&lt;bean name="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="prefix"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;30&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffix"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;A&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="initial"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;100000&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">You can also configure bean properties via constructor injection by declaring them in the <span class="FontName">&lt;constructor-arg&gt;</span> elements. Note there’s no name attribute in <span class="FontName">&lt;constructor-arg&gt;</span>, because constructor arguments are position based.</p><pre class="calibre11"><span class="FontName">&lt;bean name="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;30&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/constructor-arg&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;A&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/constructor-arg&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;100000&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/constructor-arg&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">In the Spring IoC container, each bean’s name should be unique for each context. Duplicate names are allowed for overriding bean declaration if more than one context is loaded. The concept of contexts is explained in the next section ‘Instantiate the Spring IoC container’.</p><p class="indent">Although a bean’s name can be defined by the name attribute of the <span class="FontName">&lt;bean&gt;</span> element, the preferred way of identifying a bean is through the standard XML id attribute. In this way, if your text editor is XML-aware, it can help to validate each bean’s uniqueness at design time.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">However, be aware XML has restrictions on the characters that can appear in the XML id attribute. For this reason alone, the name attribute can be helpful if you use such special characters in a bean name. In addition, Spring allows you to specify multiple bean names for the same bean separated by commas in the name attribute, something you can’t do this with the XML id attribute because commas are not allowed.</p><p class="indent">With respect to bean names it’s also worth mentioning that neither the name attribute nor the id attribute is required. A bean that has no name defined is called an anonymous bean<a id="cXXX.69" class="calibre5"></a>. You will usually create these types of beans for administrative purposes, mainly because application beans are referenced by name or id to be used by other application beans.</p><p class="indent">Spring also supports a shortcut for specifying the value of a simple type property. You can present a value attribute in the <span class="FontName">&lt;property&gt;</span> element instead of enclosing a <span class="FontName">&lt;value&gt;</span> element inside.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="prefix" value="30" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">This shortcut also works for constructor arguments.</p><pre class="calibre11"><span class="FontName">&lt;bean name="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg value="30" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg value="A" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg value="100000" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">Spring also has another convenient shortcut to define properties via setter injection. It consists of using the p schema to define bean properties as attributes of the <span class="FontName">&lt;bean&gt;</span> element. This can shorten the lines of XML configuration.</p><pre class="calibre11"><span class="FontName">&lt;beans   xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:p="</span><span class="FontName"><a href="http://www.springframework.org/schema/p" class="calibre5">http://www.springframework.org/schema/p</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">p:prefix="30" p:suffix="A" p:initial="100000" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">And Spring also has another convenient shortcut to define properties via constructor injection. It consists of using the c schema to define constructor arguments as attributes of the <span class="FontName">&lt;bean&gt;</span> element. This can shorten the lines of XML configuration.</p><pre class="calibre11"><span class="FontName">&lt;beans   xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>  <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>  <span class="FontName">xmlns:c="</span><span class="FontName"><a href="http://www.springframework.org/schema/c" class="calibre5">http://www.springframework.org/schema/c</a></span><span class="FontName">"</span><br class="calibre10"/>  <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>      <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">c:prefix ="30 " c:suffix ="A" c:initial="100000" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p id="Sec7" class="Heading2">Instantiate the Spring IoC Container</p><p class="noindent"><a id="cXXX.70" class="calibre5"></a>To create bean instances<a id="cXXX.2133" class="calibre5"></a>, you have to instantiate the Spring IoC container by reading the XML configuration files with bean instantiation values. Then, you can get the bean instances from the IoC container itself.</p><p class="indent">Spring provides two types of IoC container implementations. The basic one is called bean factory<a id="cXXX.71" class="calibre5"></a>. The more advanced one is called application context<a id="cXXX.72" class="calibre5"></a>, which is compatible with the bean factory. Note the configuration files for these two types of IoC containers are identical.</p><p class="indent">The application context provides more advanced features than the bean factory while keeping the basic features compatible. Therefore, we strongly recommend using the application context for every application unless the resources of an application are restricted (e.g., such as when running Spring for an applet or a mobile device).</p><p class="indent">The interfaces for the bean factory and the application context are <span class="FontName">BeanFactory</span> and <span class="FontName">ApplicationContext</span>, respectively. The <span class="FontName">ApplicationContext</span> interface is a subinterface of <span class="FontName">BeanFactory</span> for maintaining compatibility.</p><p class="indent">Since <span class="FontName">ApplicationContext</span> is an interface, you have to instantiate an implementation of it. Spring has several application context implementations, we recommend you use <span class="FontName">GenericXmlApplicationContext</span> which is the newest and most flexible implementation. With this class you can load the XML configuration file from the classpath.</p><pre class="calibre11"><span class="FontName">ApplicationContext context = new GenericXmlApplicationContext("beans.xml");</span></pre><p class="indent">Once the application context is instantiated, the object reference—in this case context—provides an entry point to access the POJO instances or beans.</p><p id="Sec8" class="Heading2">Get POJO Instances or Beans from the IoC Container</p><p class="noindent">To get a declared bean from a bean factory or an application context, you just make a call to the <span class="FontName">getBean()</span> method<a id="cXXX.2132" class="calibre5"></a><a id="cXXX.73" class="calibre5"></a> and pass in the unique bean name. The return type of the <span class="FontName">getBean()</span> method is <span class="FontName">java.lang.Object</span>, so you have to cast it to its actual type before using it.</p><pre class="calibre11"><span class="FontName">SequenceGenerator generator =</span> <span class="FontName">(SequenceGenerator) context.getBean("sequenceGenerator");</span></pre><p class="indent">The <span class="FontName">getBean()</span> method also supports another variation where you can provide the bean class name to avoid making the cast.</p><pre class="calibre11"><span class="FontName">SequenceGenerator generator = context.getBean("sequenceGenerator",SequenceGenerator.class);</span></pre><p class="indent">Once you reach this step you can use the POJO or bean just like any object created using a constructor outside of Spring.</p><p class="indent">A <span class="FontName">Main</span> class for running the sequence generator application would be the following:</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span><br class="calibre10"/>            <span class="FontName">new GenericXmlApplicationContext("beans.xml");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">SequenceGenerator generator =</span><br class="calibre10"/>            <span class="FontName">(SequenceGenerator) context.getBean("sequenceGenerator");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">System.out.println(generator.getSequence());</span><br class="calibre10"/>        <span class="FontName">System.out.println(generator.getSequence());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">If everything is available in the Java classpath (the <span class="FontName">beans.xml</span> file, <span class="FontName">SequenceGenerator</span> POJO class and the Spring JAR dependencies), you should see the following output, along with some logging messages:</p><pre class="calibre11"><span class="FontName">30100000A</span><br class="calibre10"/><span class="FontName">30100001A</span></pre><p id="Sec9" class="Heading">2-2. Create POJOs by Invoking a Constructor</p><p id="Sec10" class="Heading1">Problem</p><p class="noindent"><a id="cXXX.74" class="calibre5"></a><a id="cXXX.75" class="calibre5"></a>You would like to create a POJO instance or bean in the Spring IoC container by invoking its constructor, which is the most common and direct way of creating beans. It is equivalent to using the <span class="FontName">new</span> operator to create objects in Java.</p><p id="Sec11" class="Heading1">Solution</p><p class="noindent"><a id="cXXX.76" class="calibre5"></a>Define a POJO class with a constructor or constructors. Use Spring’s <span class="FontName">&lt;constructor-arg&gt;</span> element to define constructor arguments, then for each <span class="FontName">&lt;property&gt;</span> element Spring injects the value through the setter method. If no <span class="FontName">&lt;constructor-arg&gt;</span> is specified, the default constructor with no arguments is invoked. You can specify the <span class="FontName">type</span> and <span class="FontName">index</span> attributes or the <span class="FontName">name</span> attribute for the <span class="FontName">&lt;constructor-arg&gt;</span> element to avoid constructor ambiguity.</p><p id="Sec12" class="Heading1">How It Works</p><p class="noindent">Suppose you’re going to develop a shop application to sell products online. First of all, you create the Product POJO class, which has several<a id="cXXX.77" class="calibre5"></a> properties, such as the product name and price. As there are many types of products in your shop, you make the Product class abstract to extend it for different product subclasses.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public abstract class Product {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private String name;</span><br class="calibre10"/>    <span class="FontName">private double price;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Product() {}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Product(String name, double price) {</span><br class="calibre10"/>        <span class="FontName">this.name = name;</span><br class="calibre10"/>        <span class="FontName">this.price = price;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Getters and Setters</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public String toString() {</span><br class="calibre10"/>        <span class="FontName">return name + " " + price;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec13" class="Heading2">Create the POJO Classes with Constructors</p><p class="noindent"><a id="cXXX.78" class="calibre5"></a>Then you create two product subclasses, <span class="FontName">Battery</span> and <span class="FontName">Disc</span>. Each of them has its own properties.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Battery extends Product {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private boolean rechargeable;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Battery() {</span><br class="calibre10"/>        <span class="FontName">super();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Battery(String name, double price) {</span><br class="calibre10"/>        <span class="FontName">super(name, price);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Getters and Setters</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Disc extends Product {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private int capacity;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Disc() {</span><br class="calibre10"/>        <span class="FontName">super();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Disc(String name, double price) {</span><br class="calibre10"/>        <span class="FontName">super(name, price);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Getters and Setters</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec14" class="Heading2">Create XML Configuration to Create POJOs via Constructor</p><p class="noindent"><a id="cXXX.79" class="calibre5"></a>To <a id="cXXX.80" class="calibre5"></a>define some products in the Spring IoC container, you create the following bean configuration file:</p><pre class="calibre11"><span class="FontName">&lt;beans   xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="aaa" class="com.apress.springrecipes.shop.Battery"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="name" value="AAA" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="price" value="2.5" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="rechargeable" value="true" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="cdrw" class="com.apress.springrecipes.shop.Disc"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="name" value="CD-RW" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="price" value="1.5" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="capacity" value="700" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">If there’s no <span class="FontName">&lt;constructor-arg&gt;</span> element specified, the default constructor with no argument is invoked. Then for each <span class="FontName">&lt;property&gt;</span> element, Spring injects the value through the setter method. The preceding bean configuration is equivalent to the following code snippet:</p><pre class="calibre11"><span class="FontName">Product aaa = new Battery();</span><br class="calibre10"/><span class="FontName">aaa.setName("AAA");</span><br class="calibre10"/><span class="FontName">aaa.setPrice(2.5);</span><br class="calibre10"/><span class="FontName">aaa.setRechargeable(true);</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">Product cdrw = new Disc();</span><br class="calibre10"/><span class="FontName">cdrw.setName("CD-RW");</span><br class="calibre10"/><span class="FontName">cdrw.setPrice(1.5);</span><br class="calibre10"/><span class="FontName">cdrw.setCapacity(700);</span></pre><p class="indent">Otherwise, if one or more <span class="FontName">&lt;constructor-arg&gt;</span> elements is specified, Spring invokes the most appropriate constructor that matches your arguments.</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="aaa" class="com.apress.springrecipes.shop.Battery"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;constructor-arg value="AAA" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;constructor-arg value="2.5" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="rechargeable" value="true" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="cdrw" class="com.apress.springrecipes.shop.Disc"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;constructor-arg value="CD-RW" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;constructor-arg value="1.5" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="capacity" value="700" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">As there is no constructor ambiguity for the <span class="FontName">Product</span> class and subclasses, the preceding bean configuration is equivalent to the following code snippet:</p><pre class="calibre11"><span class="FontName">Product aaa = new Battery("AAA", 2.5);</span><br class="calibre10"/><span class="FontName">aaa.setRechargeable(true);</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">Product cdrw = new Disc("CD-RW", 1.5);</span><br class="calibre10"/><span class="FontName">cdrw.setCapacity(700);</span></pre><p class="indent">You can write the following <span class="FontName">Main</span> class to test your products by retrieving them from the Spring IoC container:</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) throws Exception {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span><br class="calibre10"/>            <span class="FontName">new GenericXmlApplicationContext("beans.xml");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Product aaa = (Product) context.getBean("aaa");</span><br class="calibre10"/>        <span class="FontName">Product cdrw = (Product) context.getBean("cdrw");</span><br class="calibre10"/>        <span class="FontName">System.out.println(aaa);</span><br class="calibre10"/>        <span class="FontName">System.out.println(cdrw);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec15" class="Heading2">Resolve Constructor Ambiguity</p><p class="noindent">When you specify one or more constructor<a id="cXXX.2017" class="calibre5"></a> arguments for a POJO instance or bean, Spring attempts to find an appropriate constructor in the POJO class and pass in your arguments for bean instantiation. However, if the arguments can be applied to more than one constructor, it may cau<a id="cXXX.81" class="calibre5"></a>se ambiguity in constructor matching. In this case, Spring may not be able to invoke your expected constructor.</p><p class="indent">Now let’s use another example of the <span class="FontName">SequenceGenerator</span> class—introduced in Recipe 2-1. Let’s add a new constructor to the <span class="FontName">SequenceGenerator</span> class with the prefix and suffix as arguments.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public SequenceGenerator(String prefix, String suffix) {</span><br class="calibre10"/>        <span class="FontName">this.prefix = prefix;</span><br class="calibre10"/>        <span class="FontName">this.suffix = suffix;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In the bean declaration (i.e., XML file), you can specify one or more constructor arguments through the <span class="FontName">&lt;constructor-arg&gt;</span> elements. Spring attempts to find an appropriate constructor for that class and pass in your arguments for bean instantiation.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg value="30" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg value="A" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">It’s easy for Spring to find a constructor for these two arguments, as there is only one constructor that requires two arguments. But suppose you have to add another constructor to <span class="FontName">SequenceGenerator</span> with <span class="FontName">prefix</span> and <span class="FontName">initial</span> as arguments.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public SequenceGenerator(String prefix, String suffix) {</span><br class="calibre10"/>        <span class="FontName">this.prefix = prefix;</span><br class="calibre10"/>        <span class="FontName">this.suffix = suffix;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public SequenceGenerator(String prefix, int initial) {</span><br class="calibre10"/>        <span class="FontName">this.prefix = prefix;</span><br class="calibre10"/>        <span class="FontName">this.initial = initial;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">To invoke this constructor, you make the following bean declaration to pass a prefix and an initial value. The remaining suffix is injected through the setter method.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg value="30" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg value="100000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">However, if you run the application now, you will get the following result:</p><pre class="calibre11"><span class="FontName">300A</span><br class="calibre10"/><span class="FontName">301A</span></pre><p class="indent">The cause of this unexpected result is that the first constructor, with prefix and suffix as arguments, has been invoked, but not the second. This is because Spring resolves both of your arguments as <span class="FontName">String</span> type by default and considers the first constructor was most suitable, as no type conversion was required. To specify the expected type of your arguments, you have to set it in the <span class="FontName">type</span> attribute in <span class="FontName">&lt;constructor-arg&gt;</span>.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg type="java.lang.String" value="30" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg type="int" value="100000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">Now add one more constructor to <span class="FontName">SequenceGenerator</span> with <span class="FontName">initial</span> and <span class="FontName">suffix</span> as arguments.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public SequenceGenerator(String prefix, String suffix) {</span><br class="calibre10"/>        <span class="FontName">this.prefix = prefix;</span><br class="calibre10"/>        <span class="FontName">this.suffix = suffix;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public SequenceGenerator(String prefix, int initial) {</span><br class="calibre10"/>        <span class="FontName">this.prefix = prefix;</span><br class="calibre10"/>        <span class="FontName">this.initial = initial;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public SequenceGenerator(int initial, String suffix) {</span><br class="calibre10"/>        <span class="FontName">this.initial = initial;</span><br class="calibre10"/>        <span class="FontName">this.suffix = suffix;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Next, modify the bean declaration accordingly to match this new constructor.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg type="int" value="100000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg type="java.lang.String" value="A" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="prefix" value="30" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">If you run the application again, you may get the right result or the following unexpected result:</p><pre class="calibre11"><span class="FontName">30100000null</span><br class="calibre10"/><span class="FontName">30100001null</span></pre><p class="indent">The reason for this uncertainty is that Spring internally scores each constructor for compatibility with your arguments. But during the scoring process, the order in which your arguments appear in the XML is not considered. This means that from the view of Spring, the second and the third constructors get the same score. Which one Spring picks depends on which one is matched first. According to the Java Reflection API, or more accurately the <span class="FontName">Class.getDeclaredConstructors()</span> method, the constructors returned will be in an arbitrary order that may differ from the declaration order. All these factors, acting together, cause ambiguity in constructor matching.</p><p class="indent">To avoid this problem, you have to indicate the indexes of your arguments explicitly through the <span class="FontName">index</span> attribute of <span class="FontName">&lt;constructor-arg&gt;</span>. With both the <span class="FontName">&lt;type&gt;</span> and <span class="FontName">&lt;index&gt;</span> attributes set, Spring is able to find the expected constructor for a bean accurately.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg type="int" index="0" value="100000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg type="java.lang.String" index="1" value="A" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="prefix" value="30" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">And yet another approach to avoid ambiguity in constructors is to specify the constructor parameter names with the <span class="FontName">name</span> attribute.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg name="initial" value="100000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg name="suffix" value="A" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="prefix" value="30" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">However, to make the constructor <span class="FontName">name</span> attribute work out of the box, the code must be compiled with the debug flag enabled. This allows Spring to look up the parameter name from the constructor. If you can’t compile your code with debug flag (or don’t want to) you can use <span class="FontName">@ConstructorProperties</span> JDK annotation to explicitly name your constructor arguments. In this case the POJO class with the <span class="FontName">@ConstructorProperties</span> JDK annotation would look like:</p><pre class="calibre11"><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@ConstructorProperties({"prefix", "suffix"})</span><br class="calibre10"/>    <span class="FontName">public SequenceGenerator(String prefix, String suffix) {</span><br class="calibre10"/>        <span class="FontName">this.prefix = prefix;</span><br class="calibre10"/>        <span class="FontName">this.suffix = suffix;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">@ConstructorProperties({"prefix", "initial"})</span><br class="calibre10"/>    <span class="FontName">public SequenceGenerator(String prefix, int initial) {</span><br class="calibre10"/>        <span class="FontName">this.prefix = prefix;</span><br class="calibre10"/>        <span class="FontName">this.initial = initial;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">@ConstructorProperties({"initial", "suffix"})</span><br class="calibre10"/>    <span class="FontName">public SequenceGenerator(int initial, String suffix) {</span><br class="calibre10"/>        <span class="FontName">this.initial = initial;</span><br class="calibre10"/>        <span class="FontName">this.suffix = suffix;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p id="Sec16" class="Heading">2-3. Use POJO References, Auto-Wiring, and Imports to Interact with Other POJOs</p><p id="Sec17" class="Heading1">Problem</p><p class="noindent">The POJO instances or beans that make up an application often need to collaborate with each other to complete the application’s functions. For beans to access each other, you have to specify bean references in the bean configuration file. The Spring container can auto-wire your beans to save you the trouble of configuring the wirings manually.</p><p id="Sec18" class="Heading1">Solution</p><p class="noindent">In the bean configuration file, you can specify a bean reference for a bean property or a constructor argument by the <span class="FontName">&lt;ref&gt;</span> element. It’s as easy as specifying a simple value by the <span class="FontName">&lt;value&gt;</span> element. You can also enclose a bean declaration in a property or a constructor argument directly as an inner bean. To specify auto-wiring mode in the Spring IoC container you only have to specify the autowire attribute of <span class="FontName">&lt;bean&gt;</span> tag.</p><p id="Sec19" class="Heading1">How It Works</p><p class="noindent">It can be common to have POJO instances reference one another. For example, the prefix value of the <span class="FontName">SequenceGenerator</span> class — initially described in Recipe 2-1 — uses a string. However, it’s possible to use another POJO instead of using a simple string. This can make it easier to adapt to future requirements, because instead of hardcoded values, values are based on programming logic contained in another POJOs.</p><p id="Sec20" class="Heading2">Create Multiple POJO Classes that Reference One Another</p><p class="noindent"><a id="cXXX.82" class="calibre5"></a>You can create the <span class="FontName">PrefixGenerator</span> interface to define the prefix generation operation.<a id="cXXX.83" class="calibre5"></a></p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface PrefixGenerator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public String getPrefix();</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">A prefix generation strategy could be to use the current system date. Let’s create the <span class="FontName">DatePrefixGenerator</span> class that implements the <span class="FontName">PrefixGenerator</span> interface.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">import java.text.SimpleDateFormat;</span><br class="calibre10"/><span class="FontName">import java.text.DateFormat;</span><br class="calibre10"/><span class="FontName">import java.util.Date;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class DatePrefixGenerator implements PrefixGenerator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private DateFormat formatter;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setPattern(String pattern) {</span><br class="calibre10"/>        <span class="FontName">this.formatter = new SimpleDateFormat(pattern);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public String getPrefix() {</span><br class="calibre10"/>        <span class="FontName">return formatter.format(new Date());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The pattern of this generator will be injected through the setter method <span class="FontName">setPattern()</span> and then used to create a <span class="FontName">java.text.DateFormat</span> object to format the date. Note that since the <span class="FontName">pattern</span> string won’t be used once the <span class="FontName">DateFormat</span> object is created, it’s not necessary to store it in a private field. Next, you can declare a <span class="FontName">DatePrefixGenerator</span> bean with string pattern for date formatting.</p><pre class="calibre11"><span class="FontName">&lt;bean id="datePrefixGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.DatePrefixGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="pattern" value="yyyyMMdd" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p id="Sec21" class="Heading2">Specify POJO References for Setter Methods</p><p class="noindent"><a id="cXXX.84" class="calibre5"></a>To apply this prefix generator approach, the <span class="FontName">SequenceGenerator</span> class should accept a <span class="FontName">PrefixGenerator</span> object instead of a simple string. You can choose setter injection to accept this prefix generator. You have to delete the <span class="FontName">prefix</span> property, its setter methods and constructors to avoid compiler errors.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">private PrefixGenerator prefixGenerator;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setPrefixGenerator(PrefixGenerator prefixGenerator) {</span><br class="calibre10"/>        <span class="FontName">this.prefixGenerator = prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public synchronized String getSequence() {</span><br class="calibre10"/>        <span class="FontName">StringBuffer buffer = new StringBuffer();</span><br class="calibre10"/>        <span class="FontName">buffer.append(prefixGenerator.getPrefix());</span><br class="calibre10"/>        <span class="FontName">buffer.append(initial + counter++);</span><br class="calibre10"/>        <span class="FontName">buffer.append(suffix);</span><br class="calibre10"/>        <span class="FontName">return buffer.toString();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">With this change a <span class="FontName">SequenceGenerator</span> bean can refer to the <span class="FontName">dataPrefixGenerator</span> bean as its <span class="FontName">prefixGenerator</span> property by enclosing it in the <span class="FontName">&lt;ref&gt;</span> element.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="prefixGenerator"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;ref bean="datePrefixGenerator" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">The <span class="FontName">bean</span> attribute in the <span class="FontName">&lt;ref&gt;</span> element can be a reference to any bean in the Spring IoC container, even if it’s not defined in the same XML configuration file. If you are referring to a bean in the same XML file, you should use the <span class="FontName">local</span> attribute, as it is an XML ID reference. Your XML editor can help to validate whether a bean with that ID exists in the same XML file (i.e., the reference integrity).</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;property name="prefixGenerator"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;ref local="datePrefixGenerator" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">There is also a convenient shortcut to specify a bean reference in the <span class="FontName">ref</span> attribute of the <span class="FontName">&lt;property&gt;</span> element.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;property name="prefixGenerator" ref="datePrefixGenerator" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">Another convenient shortcut to specify bean references is by using the p schema to specify bean references as attributes of the <span class="FontName">&lt;bean&gt;</span> element. This can shorten the lines of XML configuration.</p><pre class="calibre11"><span class="FontName">&lt;beans   xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:p="</span><span class="FontName"><a href="http://www.springframework.org/schema/p" class="calibre5">http://www.springframework.org/schema/p</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="datePrefixGenerator"</span><br class="calibre10"/>         <span class="FontName">class="com.apress.springrecipes.sequence.DatePrefixGenerator"&gt;</span><br class="calibre10"/>       <span class="FontName">&lt;property name="pattern" value="yyyyMMdd" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">p:suffix="A" p:initial="1000000"</span><br class="calibre10"/>        <span class="FontName">p:prefixGenerator-ref="datePrefixGenerator" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">To distinguish a bean reference from a simple property value, you have to add the -ref suffix to the property name.</p><p id="Sec22" class="Heading2">Specify POJO References for Constructor Arguments<a id="cXXX.2141" class="calibre6"></a></p><p class="noindent"><a id="cXXX.85" class="calibre5"></a>Bean references can also be applied to constructor injection. For example, you can add a constructor that accepts a <span class="FontName">PrefixGenerator</span> object as an argument.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">private PrefixGenerator prefixGenerator;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public SequenceGenerator(PrefixGenerator prefixGenerator) {</span><br class="calibre10"/>        <span class="FontName">this.prefixGenerator = prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In the <span class="FontName">&lt;constructor-arg&gt;</span> element, you can enclose a bean reference by <span class="FontName">&lt;ref&gt;</span> just like in the <span class="FontName">&lt;property&gt;</span> element.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;ref local="datePrefixGenerator" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/constructor-arg&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">The shortcut for specifying a bean reference also works for &lt;constructor-arg&gt;.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg ref="datePrefixGenerator" /&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p id="Sec23" class="Heading2">Declare Inner or Anonymous POJO References</p><p class="noindent"><a id="cXXX.86" class="calibre5"></a>Whenever a bean instance is used for only one particular property, it can be declared as an inner bean. An inner bean declaration is enclosed in <span class="FontName">&lt;property&gt;</span> or <span class="FontName">&lt;constructor-arg&gt;</span> directly, without any <span class="FontName">id</span> or <span class="FontName">name</span> attribute. In this way, the bean is anonymous and therefore can’t be used anywhere else. In fact, even if you define an <span class="FontName">id</span> or a <span class="FontName">name</span> attribute for an inner bean, it’s ignored.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;property name="prefixGenerator"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;bean class="com.apress.springrecipes.sequence.DatePrefixGenerator"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;property name="pattern" value="yyyyMMdd" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">An inner bean can also be declared in a constructor argument.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;constructor-arg&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;bean class="com.apress.springrecipes.sequence.DatePrefixGenerator"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;property name="pattern" value="yyyyMMdd" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/constructor-arg&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p id="Sec24" class="Heading2">Auto-Wire POJOs<a id="cXXX.2010" class="calibre6"></a></p><p class="noindent"><a id="cXXX.87" class="calibre5"></a>To specify the auto-wiring mode in the Spring IoC container you only have to specify the <span class="FontName">autowire</span> attribute of <span class="FontName">&lt;bean&gt;</span> element. <a id="_Tab1" href="part0010.html#Tab1" class="calibre5">Table 2-1</a> lists the<a id="cXXX.88" class="calibre5"></a> auto-wiring modes supported by Spring.</p><div class="Table" id="Tab1"><p class="TabCapt"><span class="calibre4"><a href="part0010.html#_Tab1" class="calibre5">Table 2-1</a>.</span> Auto-Wiring Modes Supported by Spring</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14"><p class="tab-left">Mode</p></th><th valign="top" class="calibre14"><p class="tab-left">Description</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16"><p class="tab-leftt">no*</p></td><td valign="top" class="calibre16"><p class="tab-leftt">No auto-wiring will be performed. You must wire the dependencies explicitly.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16"><p class="tab-leftt">byName</p></td><td valign="top" class="calibre16"><p class="tab-leftt">For each bean property, wire a bean with the same name as the property.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16"><p class="tab-leftt">byType</p></td><td valign="top" class="calibre16"><p class="tab-leftt">For each bean property, wire a bean whose type is compatible with that of the property. If more than one bean is found, an <span class="FontName">UnsatisfiedDependencyException</span> will be thrown.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16"><p class="tab-leftt">constructor</p></td><td valign="top" class="calibre16"><p class="tab-leftt">For each argument of each constructor, first find a bean whose type is compatible with the argument. Then, pick the constructor with the most matching arguments. In case of any ambiguity, an <span class="FontName">UnsatisfiedDependencyException</span> will be thrown.</p></td></tr></tbody></table>
<p class="noindent"><i class="calibre8">* The default mode is no, but this can be changed by setting the default-autowire attribute of the &lt;beans&gt; root element. This default mode can be overridden by a bean’s own mode if specified.</i></p></div>
<div class="notepara"><p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Tip</b>  Although the auto-wiring feature is very powerful, the cost is that it reduces the readability of bean configurations. Because auto-wiring is performed by Spring at runtime, you cannot derive how beans are wired from the bean configuration file. In practice, we recommend applying auto-wiring only in applications whose component dependencies are not complicated.</p></div>
<p class="indent"><a id="cXXX.89" class="calibre5"></a>For example, to auto wire by type you can set the <span class="FontName">autowire</span> attribute of the sequenceGenerator bean to <span class="FontName">byType</span> and leave the <span class="FontName">prefixGenerator</span> property unset. Then, Spring will attempt to wire a bean whose type is compatible with <span class="FontName">PrefixGenerator</span>. In this case, the <span class="FontName">dataPrefixGenerator</span> bean is wired automatically.</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">autowire="byType"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="datePrefixGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.DatePrefixGenerator"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="pattern" value="yyyyMMdd" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p id="Sec25" class="Heading2">Resolve Auto-Wire Ambiguity with the Primary Attribute</p><p class="noindent"><a id="cXXX.90" class="calibre5"></a>The main problem of auto-wiring by type is that sometimes there is more than one bean in the IoC container compatible with the target type. In this case, Spring is not be able to decide which bean is most suitable for the property, and hence cannot perform auto-wiring.</p><p class="indent">For example, if you have multiple beans that are based on the same interface and try to auto-wire by interface, auto-wiring by type won’t work. Spring will throw an <span class="FontName">UnsatisfiedDependencyException</span> if more than one bean is found for auto-wiring.</p><p class="indent">To help Spring decide which bean to use in case there is more than one bean compatible with the target type to auto-wire, you can use the <span class="FontName">primary</span> attribute on a bean definition. The <span class="FontName">primary</span> attribute gives preference to a bean when multiple candidates are qualified to autowire a single-valued dependency.</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">autowire="byType"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>  <span class="FontName">&lt;bean id="datePrefixGenerator" primary="true"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.DatePrefixGenerator"&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>  <span class="FontName">&lt;bean id="numberprefixGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.NumberPrefixGenerator"&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p id="Sec26" class="Heading2">Resolve Auto-Wire Ambiguity with the ByName Attribute</p><p class="noindent"><a id="cXXX.91" class="calibre5"></a>Another mode of auto-wiring by name using the <span class="FontName">byName</span> attribute, which can sometimes resolve the problems of auto-wiring by type. It works very similarly to <span class="FontName">byType</span>, but in this case, Spring attempts to wire a bean whose class name is the same as the property name, rather than with the compatible type. As the bean name is unique within a container, auto-wiring by name does not cause ambiguity.</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">autowire="byName"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="prefixGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.DatePrefixGenerator"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="pattern" value="yyyyMMdd" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">However, auto-wiring by name may not work in all cases. Sometimes, it’s not possible to make the name of the target bean the same as the property. So in practice, you often need to specify ambiguous dependencies explicitly while keeping others beans auto-wired. That means you employ a mixture of explicit wiring and auto-wiring.</p><p class="indent">Another alternative to auto-wiring is to do it by constructor. This process works like auto-wiring by type, but it’s more complicated. For a bean with a single constructor, Spring attempts to wire a bean with a compatible type for each constructor argument. But for a beans with multiple constructors this process gets more complicated. Spring first attempts to find a bean with a compatible type for each argument of each constructor. Then, it picks the constructor with the most matching arguments.</p><p class="indent">Suppose that <span class="FontName">SequenceGenerator</span> has one default constructor and one constructor with an argument <span class="FontName">PrefixGenerator</span>.</p><pre class="calibre11"><span class="FontName">package com.apress.springenterpriserecipes.sequence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public SequenceGenerator() {}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public SequenceGenerator(PrefixGenerator prefixGenerator) {</span><br class="calibre10"/>        <span class="FontName">this.prefixGenerator = prefixGenerator;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In this case, the second constructor is matched and picked because Spring can find a bean whose type is compatible with <span class="FontName">PrefixGenerator</span>.</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">autowire="constructor"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="datePrefixGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.DatePrefixGenerator"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="pattern" value="yyyyMMdd" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">However, multiple constructors in a class can cause ambiguity for constructor argument matching. The situation may be further complicated if you ask Spring to determine a constructor for you.</p><p class="indent">As you have seen, if Spring finds more than one candidate bean for auto-wiring, it will throw an <span class="FontName">UnsatisfiedDependencyException</span>. In addition, if the auto-wiring mode is set to <span class="FontName">byName</span> or <span class="FontName">byType</span>, and Spring cannot find a matching bean to wire, it leaves the property unset, which may cause a <span class="FontName">NullPointerException</span> or a value that has not been initialized.</p><p class="indent">So, if you use this auto-wiring mode, take great care to avoid ambiguity and try to use the following guidelines to avoid it:</p>
<ul class="bulleted"><li class="calibre17">Exclusively use constructor injection (instead of setter injection) to ensure the right properties are set.</li>
<li class="calibre17">Create setters with a dedicated init method.</li>
<li class="calibre17">Create setters with <span class="FontName">@Required</span> annotation when the property is required.</li>
<li class="calibre17">Use the <span class="FontName">@Autowired</span> annotation which implies a required property by default.</li></ul>
<div class="notepara"><p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  The <span class="FontName">@Required</span> and <span class="FontName">@Autowired</span> annotations are described in the next chapter.</p>
<p class="paraaftertitle">And to avoid auto-wiring issues altogether, it’s also possible to exclude beans from auto-wiring by adding the <span class="FontName">autowire-candidate</span> attribute of the <span class="FontName">&lt;bean&gt;</span> element to <span class="FontName">false</span>. This technique is useful for beans you never want to be injected into other beans by autowiring. It does not mean that an excluded bean cannot itself be configured using autowiring. Rather, the bean itself is not a candidate for autowiring other beans.</p></div>
<p id="Sec27" class="Heading2">Resolve POJO References from Multiple Locations</p><p class="noindent">As an application grows it can become difficult to manage every POJO in a single configuration file (e.g., <span class="FontName">beans.xml</span>). A common practice is to separate POJOs into multiple configuration files according to their functionalities. When you create multiple configuration files, obtaining references and auto-wiring POJOs that are defined in different files isn’t as straightforward as when everything is in a single configuration file.</p><p class="indent"><a id="cXXX.92" class="calibre5"></a>One approach is to initialize the application context with the location of each configuration file. In this manner, the POJOs for each configuration file are loaded into the context and references and autowiring between POJOs is possible.</p><pre class="calibre11"><span class="FontName">ApplicationContext context = new GenericXmlApplicationContext(new String[] {"beans.xml","generators.xml"});</span></pre><p class="indent">Instead of initializing the application context with a String configuration file, you use a String array to specify multiple configuration files.</p><p class="indent">Another alternative is to use the <span class="FontName">&lt;import&gt;</span> tag so Spring makes the POJOs from one configuration file available in another.</p><pre class="calibre11"><span class="FontName">&lt;beans   xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>  <span class="FontName">&lt;import resource="generators.xml"/&gt;</span><br class="calibre10"/><br class="calibre10"/>  <span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">autowire="byType" depends-on="datePrefixGenerator"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">The <span class="FontName">sequenceGenerator</span> bean requires the <span class="FontName">datePrefixGenerator</span> bean due to the <span class="FontName">depends-on</span> attribute. But notice the <span class="FontName">datePrefixGenerator</span> bean is not defined in the configuration file. The <span class="FontName">datePrefixGenerator</span> bean is defined in a separate configuration file <span class="FontName">generators.xml</span>. With the <span class="FontName">&lt;import resource="generators.xml"/&gt;</span> statement, Spring brings all the POJOs in <span class="FontName">generators.xml</span> into the scope of the present configuration file where they can be referenced or auto-wired.</p><p id="Sec28" class="Heading">2-4. Configure POJOs with Java Collection Attributes</p><p id="Sec29" class="Heading1">Problem</p><p class="noindent"><a id="cXXX.93" class="calibre5"></a><a id="cXXX.94" class="calibre5"></a>You want to configure POJOs with Java collection attributes.</p><p id="Sec30" class="Heading1">Solution</p><p class="noindent">Use the Spring tags <span class="FontName">&lt;list&gt;</span>, <span class="FontName">&lt;set&gt;</span>, and <span class="FontName">&lt;map&gt;</span>.</p><p id="Sec31" class="Heading1">How It Works</p><p class="noindent">Most POJOs use simple<a id="cXXX.95" class="calibre5"></a> type properties (e.g., String and other primitive types), but it can also be common to have POJOs that have more elaborate properties like collections. The Spring IoC container can also instantiate POJOs with Java collection attributes.</p><p class="indent"><span class="FontName">List</span>, <span class="FontName">Set</span>, and <span class="FontName">Map</span> are the core interfaces representing the three main types of collections in the Java SDK, part of a framework called the Java Collections framework<a id="cXXX.96" class="calibre5"></a>. For each collection type, Java provides several implementations with different functions and characteristics from which you can choose. In Spring, these types of collections are configured with a group of built-in XML tags: <span class="FontName">&lt;list&gt;</span>, <span class="FontName">&lt;set&gt;</span>, and <span class="FontName">&lt;map&gt;</span>.</p><p class="indent">Based on the application presented in Recipe 2-1, suppose you’re going to allow more than one suffix for a sequence generator, with the suffixes appended to the sequence numbers with hyphens as the separators. This allows the sequence generator to accept suffixes of arbitrary data types and convert them to strings when appending to the sequence numbers.</p><p id="Sec32" class="Heading2">Lists, Arrays, and Sets</p><p class="noindent">First, let’s use a <span class="FontName">java.util.List</span> collection to contain the suffixes. A list is <a id="cXXX.97" class="calibre5"></a>an ordered and indexed collection whose elements can be accessed either by index or with a for-each loop.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">private List&lt;Object&gt; suffixes;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setSuffixes(List&lt;Object&gt; suffixes) {</span><br class="calibre10"/>        <span class="FontName">this.suffixes = suffixes;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public synchronized String getSequence() {</span><br class="calibre10"/>        <span class="FontName">StringBuffer buffer = new StringBuffer();</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">for (Object suffix : suffixes) {</span><br class="calibre10"/>            <span class="FontName">buffer.append("-");</span><br class="calibre10"/>            <span class="FontName">buffer.append(suffix);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return buffer.toString();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">To define a property of the interface <span class="FontName">java.util.List</span> in the bean configuration, you specify a <span class="FontName">&lt;list&gt;</span> tag that contains the elements. The elements allowed inside the <span class="FontName">&lt;list&gt;</span> tag can be a simple constant value specified by <span class="FontName">&lt;value&gt;</span>, a bean reference specified by <span class="FontName">&lt;ref&gt;</span>, an inner bean definition specified by <span class="FontName">&lt;bean&gt;</span>, an ID reference definition specified by <span class="FontName">&lt;idref&gt;</span>, or a null element specified by <span class="FontName">&lt;null&gt;</span>. You can even embed other collections in a collection.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;property name="prefix" value="30" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;list&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;A&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;bean class="java.net.URL"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="http" /&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="</span><span class="FontName"><a href="http://www.apress.com" class="calibre5">www.apress.com</a></span><span class="FontName">" /&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="/" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;null /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/list&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">Conceptually, an array is very similar to a list in that it’s also an ordered and indexed collection that can be accessed by index. The main difference is that the length of an array is fixed and cannot be extended dynamically. In the Java Collections framework, an <a id="cXXX.98" class="calibre5"></a>array and a list can be converted to each other through the <span class="FontName">Arrays.asList()</span> and <span class="FontName">List.toArray()</span> methods. For the sequence generator, you can use an <span class="FontName">Object[]</span> array to contain the suffixes and access them either by index or with a for-each loop.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">private Object[] suffixes;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setSuffixes(Object[] suffixes) {</span><br class="calibre10"/>        <span class="FontName">this.suffixes = suffixes;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The definition of an array in the bean configuration file is identical to a list denoted by the <span class="FontName">&lt;list&gt;</span> tag.</p><p class="indent">Another common collection type is a set. Both the <span class="FontName">java.util.List</span> interface and the <span class="FontName">java.util.Set</span> interface extend the same interface: <span class="FontName">java.util.Collection</span>. A set differs from a list in that it is neither ordered nor indexed, and it can store unique objects only. That means no duplicate element can be contained in a set. When the same element is added to a set for the second time, it will replace the old one. The equality of elements is determined by the <span class="FontName">equals()</span> method.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">private Set&lt;Object&gt; suffixes;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setSuffixes(Set&lt;Object&gt; suffixes) {</span><br class="calibre10"/>        <span class="FontName">this.suffixes = suffixes;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">To define a property of <span class="FontName">java.util.Set</span> type, use the <span class="FontName">&lt;</span><span class="FontName">set&gt;</span> tag to<a id="cXXX.99" class="calibre5"></a> define the elements in the same way as a list.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;set&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;A&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;bean class="java.net.URL"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="http" /&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="</span><span class="FontName"><a href="http://www.apress.com" class="calibre5">www.apress.com</a></span><span class="FontName">" /&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="/" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;null /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;!-- The following is ignored because the collection is a setà</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;A&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;bean class="java.net.URL"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="http" /&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="</span><span class="FontName"><a href="http://www.apress.com" class="calibre5">www.apress.com</a></span><span class="FontName">" /&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="/" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;null /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/set&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">Although there’s no order concept in the original set semantics, Spring preserves the order of your elements by using <span class="FontName">java.util.LinkedHashSet</span>, an implementation of the <span class="FontName">java.util.Set</span> interface that does preserve element order.</p><p id="Sec33" class="Heading2">Maps and Properties</p><p class="noindent"><a id="cXXX.100" class="calibre5"></a>A map interface is a table that stores its entries in key/value pairs. You can get a particular value from a map by its key, and also iterate the map entries with a for-each loop. Both the keys and values of a map can be of arbitrary type. Equality between keys is also determined by the <span class="FontName">equals()</span> method. For example, you can modify your sequence generator to accept a <span class="FontName">java.util.Map</span> collection that contains suffixes with keys.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">private Map&lt;Object, Object&gt; suffixes;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setSuffixes(Map&lt;Object, Object&gt; suffixes) {</span><br class="calibre10"/>        <span class="FontName">this.suffixes = suffixes;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public synchronized String getSequence() {</span><br class="calibre10"/>        <span class="FontName">StringBuffer buffer = new StringBuffer();</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">for (Map.Entry entry : suffixes.entrySet()) {</span><br class="calibre10"/>            <span class="FontName">buffer.append("-");</span><br class="calibre10"/>            <span class="FontName">buffer.append(entry.getKey());</span><br class="calibre10"/>            <span class="FontName">buffer.append("@");</span><br class="calibre10"/>            <span class="FontName">buffer.append(entry.getValue());</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return buffer.toString();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In Spring, a map is defined by the <span class="FontName">&lt;map&gt;</span> tag, with multiple <span class="FontName">&lt;entry&gt;</span> tags as children. Each entry contains a key and a value. The key must be defined inside the <span class="FontName">&lt;key&gt;</span> tag. There is no restriction on the type of the key and value, so you are free to specify a <span class="FontName">&lt;value&gt;</span>, <span class="FontName">&lt;ref&gt;</span>, <span class="FontName">&lt;bean&gt;</span>, <span class="FontName">&lt;idref&gt;</span>, or <span class="FontName">&lt;null&gt;</span> element for them. Spring will also preserve the order of the map entries by using <span class="FontName">java.util.LinkedHashMap</span>.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;map&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;entry&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;key&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;value&gt;type&lt;/value&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;/key&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;value&gt;A&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/entry&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;entry&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;key&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;value&gt;url&lt;/value&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;/key&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;bean class="java.net.URL"&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;constructor-arg value="http" /&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;constructor-arg value="</span><span class="FontName"><a href="http://www.apress.com" class="calibre5">www.apress.com</a></span><span class="FontName">" /&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;constructor-arg value="/" /&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/entry&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/map&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">There are shortcuts to defining map keys and values as attributes of the <span class="FontName">&lt;entry&gt;</span> tag. If they are simple constant values, you can define them by key and value. If they are bean references, you can define them by <span class="FontName">key-ref</span> and <span class="FontName">value-ref</span>.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;map&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;entry key="type" value="A" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;entry key="url"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;bean class="java.net.URL"&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;constructor-arg value="http" /&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;constructor-arg value="</span><span class="FontName"><a href="http://www.apress.com" class="calibre5">www.apress.com</a></span><span class="FontName">" /&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;constructor-arg value="/" /&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/entry&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/map&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">In all the collection classes seen thus far you’ve used values. Sometimes, the desired goal is to configure a <span class="FontName">null</span> value using a Map instance. Spring’s XML configuration schema includes explicit support for this. Here is a map with <span class="FontName">null</span> values for the value of an entry:</p><pre class="calibre11"><span class="FontName">&lt;property name="nulledMapValue"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;map&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;entry&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;key&gt; &lt;value&gt;null&lt;/value&gt; &lt;/key&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/entry&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/map&gt;</span><br class="calibre10"/><span class="FontName">&lt;/property&gt;</span></pre><p class="indent">A <span class="FontName">java.util.</span><span class="FontName">Properties</span> collection is very similar to a map. It also implements the <span class="FontName">java.util.Map</span> interface and stores entries in key/value pairs. The only difference is that the keys and values of a Properties collection are always strings.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">private Properties suffixes;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setSuffixes(Properties suffixes) {</span><br class="calibre10"/>        <span class="FontName">this.suffixes = suffixes;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">To define a <span class="FontName">java.util.Properties</span> collection in Spring, use the <span class="FontName">&lt;props&gt;</span> tag with multiple <span class="FontName">&lt;prop&gt;</span> tags as children. Each <span class="FontName">&lt;prop&gt;</span> tag must have a key attribute defined and the corresponding value enclosed.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;props&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;prop key="type"&gt;A&lt;/prop&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;prop key="url"&gt;</span><span class="FontName"><a href="http://www.apress.com/" class="calibre5">http://www.apress.com/</a></span><span class="FontName">&lt;/prop&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;prop key="null"&gt;null&lt;/prop&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/props&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p id="Sec34" class="Heading2">Specify the Data Type for Collection Elements</p><p class="noindent"><a id="cXXX.101" class="calibre5"></a>By default, Spring treats every element in a collection as a string. You have to specify the data type for your collection elements if you are not going to use them as strings. You can either specify the data type for each collection element by the type attribute of the <span class="FontName">&lt;value&gt;</span> tag, or specify the data type for all elements by the <span class="FontName">value-type</span> attribute of the collection tag. Another approach available is to define a type-safe collection so that Spring reads a collection’s type information.</p><p class="indent">Suppose you want to accept a list of integer numbers as the suffixes of your sequence generator. Each number will be formatted into four digits by an instance of <span class="FontName">java.text.DecimalFormat</span>.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">private List&lt;Object&gt; suffixes;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setSuffixes(List&lt;Object&gt; suffixes) {</span><br class="calibre10"/>        <span class="FontName">this.suffixes = suffixes;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public synchronized String getSequence() {</span><br class="calibre10"/>        <span class="FontName">StringBuffer buffer = new StringBuffer();</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">DecimalFormat formatter = new DecimalFormat("0000");</span><br class="calibre10"/>        <span class="FontName">for (Object suffix : suffixes) {</span><br class="calibre10"/>            <span class="FontName">buffer.append("-");</span><br class="calibre10"/>            <span class="FontName">buffer.append(formatter.format((Integer) suffix));</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return buffer.toString();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Then define several suffixes for your sequence generator in the bean configuration file as usual.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="prefixGenerator" ref="datePrefixGenerator" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;list&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;5&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;10&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;20&lt;/value&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/list&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">If you run the application this way, you will encounter a <span class="FontName">ClassCastException</span>, indicating the suffixes can’t be cast into integers because their type is a <span class="FontName">String</span>. Spring treats every element in a collection as a string by default. You have to set the <span class="FontName">type</span> attribute of the <span class="FontName">&lt;value&gt;</span> tag to specify the element type.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;list&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value type="int"&gt;5&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value type="int"&gt;10&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value type="int"&gt;20&lt;/value&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/list&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">Or you may set the <span class="FontName">value-type</span> attribute of the collection tag to specify the type for all elements in this collection.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;list value-type="int"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;5&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;10&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;20&lt;/value&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/list&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">And another alternative is to define the suffixes list with a type-safe collection that stores integers.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.sequence;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class SequenceGenerator {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">private List&lt;Integer&gt; suffixes;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setSuffixes(List&lt;Integer&gt; suffixes) {</span><br class="calibre10"/>        <span class="FontName">this.suffixes = suffixes;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public synchronized String getSequence() {</span><br class="calibre10"/>        <span class="FontName">StringBuffer buffer = new StringBuffer();</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">DecimalFormat formatter = new DecimalFormat("0000");</span><br class="calibre10"/>        <span class="FontName">for (int suffix : suffixes) {</span><br class="calibre10"/>            <span class="FontName">buffer.append("-");</span><br class="calibre10"/>            <span class="FontName">buffer.append(formatter.format(suffix));</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return buffer.toString();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Once you define your collections in a type-safe way, Spring is able to read the collection’s type information through reflection. In this way, you no longer need to specify the <span class="FontName">value-type</span> attribute of <span class="FontName">&lt;list&gt;</span>.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;list&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;5&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;10&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;20&lt;/value&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/list&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p id="Sec35" class="Heading2">Specify Concrete Classes for Collections</p><p class="noindent"><a id="cXXX.102" class="calibre5"></a>When using the basic collection tags to define collections, you can’t specify the concrete class of a collection, such as <span class="FontName">LinkedList</span>, <span class="FontName">TreeSet</span>, or <span class="FontName">TreeMap</span>. Moreover, you cannot share a collection among different beans by defining it as a stand-alone bean for other beans to refer to.</p><p class="indent">Spring provides a couple of options to overcome the shortcomings of the basic collection tags. One option is to use a collection factory beans like <span class="FontName">ListFactoryBean</span>, <span class="FontName">SetFactoryBean</span>, and <span class="FontName">MapFactoryBean</span>. A factory bean is a special kind of Spring bean that is used to create another bean. The second option is to use collection tags such as <span class="FontName">&lt;util:list&gt;</span>, <span class="FontName">&lt;util:set&gt;</span>, and <span class="FontName">&lt;util:map&gt;</span> in the <span class="FontName">util</span> schema.</p><p class="indent">You can use a collection factory bean to define a collection and specify its target class. For example, you can specify the <span class="FontName">targetSetClass</span> property for <span class="FontName">SetFactoryBean</span>. Then Spring instantiates the specified class for the collection.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="prefix" value="30" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;bean class="org.springframework.beans.factory.config.SetFactoryBean"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;property name="targetSetClass"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;value&gt;java.util.TreeSet&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;property name="sourceSet"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;set&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;value&gt;5&lt;/value&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;value&gt;10&lt;/value&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;value&gt;20&lt;/value&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;/set&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">Or you can use a collection tag in the util schema to define a collection and set its target class (e.g., by the <span class="FontName">set-class</span> attribute of <span class="FontName">&lt;util:set&gt;</span>). But you must remember to add the <span class="FontName">util</span> schema definition to your <span class="FontName">&lt;beans&gt;</span> root element.</p><pre class="calibre11"><span class="FontName">&lt;beans   xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:util="</span><span class="FontName"><a href="http://www.springframework.org/schema/util" class="calibre5">http://www.springframework.org/schema/util</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/util" class="calibre5">http://www.springframework.org/schema/util</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/util/spring-util-3.2.xsd" class="calibre5">http://www.springframework.org/schema/util/spring-util-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="prefix" value="30" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;util:set set-class="java.util.TreeSet"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;value&gt;5&lt;/value&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;value&gt;10&lt;/value&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;value&gt;20&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/util:set&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">An advantage of collection factory beans is that you can define a collection as a stand-alone bean for other beans to refer to. For example, you can define a stand-alone set by using <span class="FontName">SetFactoryBean</span>.</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;ref local="suffixes" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="suffixes"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.beans.factory.config.SetFactoryBean"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="sourceSet"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;set&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;value&gt;5&lt;/value&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;value&gt;10&lt;/value&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;value&gt;20&lt;/value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/set&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">Or you can define a stand-alone set by using the <span class="FontName">&lt;util:set&gt;</span> tag in the <span class="FontName">util</span> schema.</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"&gt;</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">&lt;property name="suffixes"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;ref local="suffixes"/&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;util:set id="suffixes"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;5&lt;/value&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;10&lt;/value&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;20&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/util:set&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p id="Sec36" class="Heading">2-5. Set a POJOs Scope</p><p id="Sec37" class="Heading1">Problem</p><p class="noindent"><a id="cXXX.103" class="calibre5"></a>When you declare a POJO instance or bean in the configuration file, you are actually defining a template for bean creation, not an actual bean instance. When a bean is requested by the <span class="FontName">getBean()</span> method or a reference from other beans, Spring decides which bean instance should be returned according to the bean scope. Sometimes, you have to set an appropriate scope for a bean other than the default scope.</p><p id="Sec38" class="Heading1">Solution</p><p class="noindent">A bean’s scope is set in the scope attribute of the <span class="FontName">&lt;bean&gt;</span> element. By default, Spring creates exactly one instance for each bean declared in the IoC container, and this instance is shared in the scope of the entire IoC container. This unique bean instance is returned for all subsequent <span class="FontName">getBean()</span> calls and bean references. This scope is called <a id="cXXX.104" class="calibre5"></a>singleton<a id="cXXX.105" class="calibre5"></a>, which is the default scope of all beans. <a id="_Tab2" href="part0010.html#Tab2" class="calibre5">Table 2-2</a> lists all valid bean scopes in Spring<a id="cXXX.106" class="calibre5"></a>.</p><div class="Table" id="Tab2"><p class="TabCapt"><span class="calibre4"><a href="part0010.html#_Tab2" class="calibre5">Table 2-2</a>.</span> Valid Bean Scopes<a id="cXXX.2012" class="calibre5"></a> in Spring</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14"><p class="tab-left">Scope</p></th><th valign="top" class="calibre14"><p class="tab-left">Description</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16"><p class="tab-leftt">singleton</p></td><td valign="top" class="calibre16"><p class="tab-leftt">Creates a single bean instance per Spring IoC container</p></td></tr><tr class="noclass"><td valign="top" class="calibre16"><p class="tab-leftt">prototype</p></td><td valign="top" class="calibre16"><p class="tab-leftt">Creates a new bean instance each time when requested</p></td></tr><tr class="noclass"><td valign="top" class="calibre16"><p class="tab-leftt">request</p></td><td valign="top" class="calibre16"><p class="tab-leftt">Creates a single bean instance per HTTP request; only valid in the context of a web application</p></td></tr><tr class="noclass"><td valign="top" class="calibre16"><p class="tab-leftt">session</p></td><td valign="top" class="calibre16"><p class="tab-leftt">Creates a single bean instance per HTTP session; only valid in the context of a web application</p></td></tr><tr class="noclass"><td valign="top" class="calibre16"><p class="tab-leftt">globalSession</p></td><td valign="top" class="calibre16"><p class="tab-leftt">Creates a single bean instance per global HTTP session; only valid in the context of a portal application</p></td></tr></tbody></table>
</div>
<p id="Sec39" class="Heading1">How It Works</p><p class="noindent">To demonstrate the <a id="cXXX.107" class="calibre5"></a>concept of bean scope, let’s consider a shopping cart example in a shopping application. First, you create the <span class="FontName">ShoppingCart</span> class as follows:</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class ShoppingCart {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private List&lt;Product&gt; items = new ArrayList&lt;Product&gt;();</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void addItem(Product item) {</span><br class="calibre10"/>        <span class="FontName">items.add(item);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public List&lt;Product&gt; getItems() {</span><br class="calibre10"/>        <span class="FontName">return items;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Then you declare some product beans and a shopping cart bean in the IoC container as usual:</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="aaa" class="com.apress.springrecipes.shop.Battery"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="name" value="AAA" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="price" value="2.5" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="rechargeable" value="true" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="cdrw" class="com.apress.springrecipes.shop.Disc"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="name" value="CD-RW" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="price" value="1.5" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="capacity" value="700" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="dvdrw" class="com.apress.springrecipes.shop.Disc"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="name" value="DVD-RW" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="price" value="3.0" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="capacity" value="700" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="shoppingCart" class="com.apress.springrecipes.shop.ShoppingCart" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">In the following <span class="FontName">Main</span> class, you can test your shopping cart by adding some products to it. Suppose that there are two customers navigating in your shop at the same time. The first one gets a shopping cart by the <span class="FontName">getBean()</span> method and adds two products to it. Then, the second customer also gets a shopping cart by the <span class="FontName">getBean()</span> method and adds another product to it.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span><br class="calibre10"/>            <span class="FontName">new GenericXmlApplicationContext("beans.xml");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Product aaa = (Product) context.getBean("aaa");</span><br class="calibre10"/>        <span class="FontName">Product cdrw = (Product) context.getBean("cdrw");</span><br class="calibre10"/>        <span class="FontName">Product dvdrw = (Product) context.getBean("dvdrw");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">ShoppingCart cart1 = (ShoppingCart) context.getBean("shoppingCart");</span><br class="calibre10"/>        <span class="FontName">cart1.addItem(aaa);</span><br class="calibre10"/>        <span class="FontName">cart1.addItem(cdrw);</span><br class="calibre10"/>        <span class="FontName">System.out.println("Shopping cart 1 contains " + cart1.getItems());</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">ShoppingCart cart2 = (ShoppingCart) context.getBean("shoppingCart");</span><br class="calibre10"/>        <span class="FontName">cart2.addItem(dvdrw);</span><br class="calibre10"/>        <span class="FontName">System.out.println("Shopping cart 2 contains " + cart2.getItems());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">As a result of the preceding bean declaration, you can see that the two customers get the same shopping cart instance.</p><pre class="calibre11"><span class="FontName">Shopping cart 1 contains [AAA 2.5, CD-RW 1.5]</span><br class="calibre10"/><span class="FontName">Shopping cart 2 contains [AAA 2.5, CD-RW 1.5, DVD-RW 3.0]</span></pre><p class="indent">This is because Spring’s default bean scope is <span class="FontName">singleton</span>, which means Spring creates exactly one shopping cart instance per IoC container.</p><pre class="calibre11"><span class="FontName">&lt;bean id="shoppingCart"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.shop.ShoppingCart"</span><br class="calibre10"/>    <span class="FontName">scope="singleton" /&gt;</span></pre><p class="indent">In your shop application, you expect each customer to get a different shopping cart instance when the <span class="FontName">getBean()</span> method is called. To ensure this behavior, the scope of the shoppingCart bean needs to be set to<a id="cXXX.108" class="calibre5"></a> <span class="FontName">prototype</span>. Then Spring creates a new bean instance for each <span class="FontName">getBean()</span> method call.</p><pre class="calibre11"><span class="FontName">&lt;bean id="shoppingCart"</span><br class="calibre10"/>    <span class="FontName">class="com.apress.springrecipes.shop.ShoppingCart"</span><br class="calibre10"/>    <span class="FontName">scope="prototype" /&gt;</span></pre><p class="indent">Now if you run the <span class="FontName">Main</span> class again, you can see the two customers get a different shopping cart instance.</p><pre class="calibre11"><span class="FontName">Shopping cart 1 contains [AAA 2.5, CD-RW 1.5]</span><br class="calibre10"/><span class="FontName">Shopping cart 2 contains [DVD-RW 3.0]</span></pre><p id="Sec40" class="Heading">2-6. Use Data from External Resources (Text Files, XML Files, Properties Files, or Image Files)</p><p id="Sec41" class="Heading1">Problem</p><p class="noindent"><a id="cXXX.109" class="calibre5"></a>Sometimes, applications need to read external resources (e.g., text files, XML files, properties file, or image files) from different locations (e.g., a file system, classpath, or URL). Usually, you have to deal with different APIs for loading resources from different locations.</p><p id="Sec42" class="Heading1">Solution</p><p class="noindent">Spring offers the <span class="FontName">PropertySourcesPlaceholderConfigurer</span> class as a facility to load the contents of <span class="FontName">.properties</span> file (i.e. key-value pairs) to set up bean properties.</p><p class="indent">Spring also has a resource loader mechanism which provides a unified <span class="FontName">Resource</span> interface to retrieve any type of external resource by a resource path. You can specify different prefixes for this path to load resources from different locations. To load a resource from a file system, you use the <span class="FontName">file</span> prefix. To load a resource from the classpath, you use the <span class="FontName">classpath</span> prefix. You can also specify a URL in the resource path.</p><p id="Sec43" class="Heading1">How It Works</p><p class="noindent">To read the contents of a <span class="FontName">properties</span> file (i.e., key-value pairs) to setup bean properties you can use Spring’s <span class="FontName">PropertySourcesPlaceholderConfigurer</span> class. If you want to read the contents of any file you can use Spring’s <span class="FontName">Resource</span> mechanism.</p><p id="Sec44" class="Heading2">Use Properties File data to Setup POJO Instantiation Values</p><p class="noindent"><a id="cXXX.110" class="calibre5"></a>Let’s assume you have a series of values in a <span class="FontName">properties</span> file you want to access to setup bean properties. Typically this can be the configuration properties of a database or some other application values composed of key-values. For example, take the following key-values stored in a file called <span class="FontName">discounts.properties</span>.</p><pre class="calibre11"><span class="FontName">specialcustomer.discount=0.1</span><br class="calibre10"/><span class="FontName">summer.discount=0.15</span><br class="calibre10"/><span class="FontName">endofyear.discount=0.2</span></pre><div class="notepara"><p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To read properties files for the purpose of internationalization (i18n) see the next recipe</p></div>
<p class="indent">To make the contents of the <span class="FontName">discounts.properties</span> file accessible to set up other beans, you can use the <span class="FontName">PropertySourcesPlaceholderConfigurer</span> class to convert the key-values into a bean.</p><pre class="calibre11"><span class="FontName">&lt;bean id="discountPropertyConfigurer"       class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer"&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;property name="location"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;value&gt;classpath:discounts.properties&lt;/value&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;property name="ignoreResourceNotFound" value="true"/&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">You define a <span class="FontName">location</span> property for the bean with a <span class="FontName">value</span> of <span class="FontName">classpath:discounts.properties</span>. The <span class="FontName">classpath:</span> prefix tells Spring to look for the <span class="FontName">discounts.properties</span> file in the Java classpath.</p><p class="indent">The properties <span class="FontName">ignoreResourceNotFound</span> and <span class="FontName">ignoreUnresolvablePlaceholders</span> are defined explicitly to ignore potential errors in the properties file. The property <span class="FontName">ignoreResourceNotFound</span> set to <span class="FontName">true</span>, tells Spring to ignore errors if the properties file is not found. The property <span class="FontName">ignoreUnresolvablePlaceholders</span> set to <span class="FontName">true</span>, tells Spring to ignore attempts to access non-existent keys in the properties file. If these last properties are not explicitly set to true, they default to false and generate exceptions if either the properties file doesn’t exist or an attempt is made to access non-existent keys.</p><p class="indent">Once the <span class="FontName">PropertySourcesPlaceholderConfigurer</span> bean is declared, you can access the values of the <span class="FontName">discounts.properties</span> file to setup other bean properties.</p><p class="indent">If you add a <span class="FontName">discount</span> property to the <span class="FontName">Product</span>, <span class="FontName">Battery</span> and <span class="FontName">Disc</span> classes of the shopping application, you can set a bean property using values from a properties file.</p><pre class="calibre11"><span class="FontName">&lt;bean id="aaa" class="com.apress.springrecipes.shop.Battery"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="name" value="AAA" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="price" value="2.5" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="discount" value="${specialcustomer.discount:0}" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="rechargeable" value="true" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;bean id="cdrw" class="com.apress.springrecipes.shop.Disc"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="name" value="CD-RW" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="price" value="1.5" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="discount" value="${summer.discount:0}" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="capacity" value="700" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">The syntax is <span class="FontName">${key:default_value}</span>. A search is done for the <span class="FontName">key</span> value in all the loaded application properties. If a matching <span class="FontName">key=value</span> is found in the properties file, the corresponding <span class="FontName">value</span> is assigned to the bean property. If no matching <span class="FontName">key=value</span> is found in the loaded application properties, the <span class="FontName">default_value</span> (i.e., after <span class="FontName">${key:</span>) is assigned to the bean property.</p><p class="indent">If you want to use properties file data for a different purpose than setting up bean properties, you should use Spring’s <span class="FontName">Resource</span> mechanism which is described next.</p><p id="Sec45" class="Heading2">Use Data from any External Resource File for use in a POJO</p><p class="noindent">Suppose you want to display a banner at the startup of an application. The banner is made up of the following characters and stored in a text file called <span class="FontName">banner.txt</span>. This file can be put in the classpath of your application.</p><pre class="calibre11"><span class="FontName">*************************</span><br class="calibre10"/><span class="FontName">*  Welcome to My Shop!  *</span><br class="calibre10"/><span class="FontName">*************************</span></pre><p class="indent">Next, let’s write a <span class="FontName">BannerLoader</span> POJO class to load the banner and output it to the console.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.core.io.Resource;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class BannerLoader {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Resource banner;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setBanner(Resource banner) {</span><br class="calibre10"/>        <span class="FontName">this.banner = banner;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void showBanner() throws IOException {</span><br class="calibre10"/>        <span class="FontName">InputStream in = banner.getInputStream();</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">BufferedReader reader = new BufferedReader(new InputStreamReader(in));</span><br class="calibre10"/>        <span class="FontName">while (true) {</span><br class="calibre10"/>            <span class="FontName">String line = reader.readLine();</span><br class="calibre10"/>            <span class="FontName">if (line == null)</span><br class="calibre10"/>                <span class="FontName">break;</span><br class="calibre10"/>            <span class="FontName">System.out.println(line);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">reader.close();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Notice the POJO <span class="FontName">banner</span> field is a Spring <span class="FontName">Resource</span> type. The field value will be populated through setter injection when the bean instance is created (to be explained shortly). The <span class="FontName">showBanner</span> method makes a call to the <span class="FontName">getInputStream()</span> method to retrieve the input stream from the <span class="FontName">Resource</span> field. Once you have an InputStream, you’re able to use standard Java file manipulation class. In this case, the file contents are read line by line with <span class="FontName">BufferedReader</span> and outputted to the console.</p><p class="indent">Finally, you declare a <span class="FontName">BannerLoader</span> instance in the bean configuration file to display the banner.</p><pre class="calibre11"><span class="FontName">&lt;bean id="bannerLoader"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.shop.BannerLoader"</span><br class="calibre10"/>        <span class="FontName">init-method="showBanner"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="banner"&gt;</span><br class="calibre10"/>      <span class="FontName">&lt;value&gt;classpath:banner.txt&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">Because you want to show the banner at startup, you specify the <span class="FontName">showBanner()</span> method as the initialization method so it’s invoked automatically upon creation. Also notice the banner property with the <span class="FontName">classpath:banner.txt</span> value. This tells Spring to search for the banner.txt file in the classpath and inject it as the bean’s banner property. Spring uses the preregistered property editor <span class="FontName">ResourceEditor</span> to convert the file definition into a <span class="FontName">Resource</span> object before injecting it into the bean.</p><p class="indent">Because the banner file is located in the Java classpath, the resource path starts with the <span class="FontName">classpath:</span> prefix. The previous resource path specifies a resource in the relative path of the file system. You can specify an absolute path as well.</p><pre class="calibre11"><span class="FontName">file:c:/shop/banner.txt</span></pre><p class="indent">When a resource is located in Java’s classpath, you have to use the <span class="FontName">classpath</span> prefix. If there’s no path information presented, it will be loaded from the root of the classpath.</p><pre class="calibre11"><span class="FontName">classpath:banner.txt</span></pre><p class="indent">If the resource is located in a particular package, you can specify the absolute path from the classpath root.</p><pre class="calibre11"><span class="FontName">classpath:com/apress/springrecipes/shop/banner.txt</span></pre><p class="indent">Besides support to load from a file system path or the classpath, a resource can also be loaded by specifying a URL.</p><pre class="calibre11"><span class="FontName"><a href="http://springrecipes.apress.com/shop/banner.txt" class="calibre5">http://springrecipes.apress.com/shop/banner.txt</a></span></pre><p class="indent">Since the bean instance uses the <span class="FontName">init-method</span> to automatically invoke the <span class="FontName">showBanner()</span> method, the banner is sent to output when the IoC container is setup. Because of this, there’s no need to tinker with an application’s context or explicitly call the bean to output the banner. However, sometimes it can be necessary to access an external resource to interact with an application’s context.</p><p class="indent">Now suppose you want to display a legend at the end of an application. The legend is made up of the discounts previously described in the <span class="FontName">discounts.properties</span> file. To access the contents of the properties file you can also leverage Spring’s <span class="FontName">Resource</span> mechanism.</p><p class="indent">Next, let’ use Spring’s <span class="FontName">Resource</span> mechanism, but this time directly inside an application’s Main class to output a legend when the application finishes.</p><pre class="calibre11"><span class="FontName">import org.springframework.core.io.ClassPathResource;</span><br class="calibre10"/><span class="FontName">import org.springframework.core.io.support.PropertiesLoaderUtils;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) throws Exception {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">    ShoppingCart cart2 = (ShoppingCart) context.getBean("shoppingCart");</span><br class="calibre10"/><span class="FontName">    cart2.addItem(dvdrw);</span><br class="calibre10"/><span class="FontName">    System.out.println("Shopping cart 2 contains " + cart2.getItems());</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">    Resource resource = new ClassPathResource("discounts.properties");</span><br class="calibre10"/><span class="FontName">    Properties props = PropertiesLoaderUtils.loadProperties(resource);</span><br class="calibre10"/><span class="FontName">    System.out.println("And don't forget our discounts!");</span><br class="calibre10"/><span class="FontName">    System.out.println(props);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Spring’s <span class="FontName">ClassPathResource</span> class is used to access the <span class="FontName">discounts.properties</span> file, which casts the file’s contents into a <span class="FontName">Resource</span> object. Next, the <span class="FontName">Resource</span> object is processed into a <span class="FontName">Properties</span> object with Spring’s <span class="FontName">PropertiesLoaderUtils</span> class. Finally, the contents of the <span class="FontName">Properties</span> object are sent to the console as the final output of the application.</p><p class="indent">Because the legend file (i.e., <span class="FontName">discounts.properties</span>) is located in the Java classpath, the resource is accessed with Spring’s <span class="FontName">ClassPathResource</span> class. If the external resource were in a file system path the resource would be loaded with Spring’s <span class="FontName">FileSystemResource</span>.</p><pre class="calibre11"><span class="FontName">Resource resource = new FileSystemResource("c:/shop/banner.txt")</span></pre><p class="indent">If the external resource were at a URL the resource would be loaded with Spring’s <span class="FontName">UrlResource</span>.</p><pre class="calibre11"><span class="FontName">Resource resource = new UrlResource("</span><span class="FontName"><a href="http://www.apress.com/context/banner.txt" class="calibre5">http://www.apress.com/context/banner.txt</a></span><span class="FontName">")</span></pre><p id="Sec46" class="Heading">2-7. Resolve I18N Text Messages<a id="cXXX.2060" class="calibre6"></a> for Different Locales in Properties Files</p><p id="Sec47" class="Heading1">Problem</p><p class="noindent"><a id="cXXX.111" class="calibre5"></a><a id="cXXX.112" class="calibre5"></a>For an application to support internationalization (I18N for short, as there are 18 characters between the first character, “i,” and the last character, “n”), it requires the capability to resolve text messages for different locales.</p><p id="Sec48" class="Heading1">Solution</p><p class="noindent">Spring’s application context is able to resolve text messages for target locales by keys. Typically, the messages for one locale are stored in separate properties file. These properties files are called resource bundles<a id="cXXX.113" class="calibre5"></a><a id="cXXX.114" class="calibre5"></a> and follow the naming convention <span class="FontName">messages_&lt;language_code&gt;_&lt;country_code&gt;.properties</span>.</p><p class="indent"><span class="FontName">MessageSource</span> is an interface that defines several methods for resolving messages in resource bundles. The <span class="FontName">ApplicationContext</span> interface extends this interface so that all application contexts are able to resolve text messages. An application context delegates the message resolution to a bean with the name <span class="FontName">messageSource. ResourceBundleMessageSource</span> is the most common <span class="FontName">MessageSource</span> implementation that resolves messages from resource bundles for different locales.</p><p id="Sec49" class="Heading1">How It Works</p><p class="noindent">As an example, create the following resource bundle, <span class="FontName">messages_en_US.properties</span>, for the English language in the United States. Resource bundles are loaded from the root of the classpath, so ensure it’s available on the Java classpath. Place the following key-value in the file:</p><pre class="calibre11"><span class="FontName">alert.checkout=A shopping cart has been checked out.</span></pre><p class="indent">To resolve messages from resource bundles, we’ll use the <span class="FontName">ReloadableRsourceBundleMessageSource</span> as the <span class="FontName">MessageSource</span> implementation. This bean’s name must be set to <span class="FontName">messageSource</span> for the application context to detect it. You have to specify a list of <span class="FontName">basenames</span> to locate bundles for <span class="FontName">ResourceBundleMessageSource</span>. For this case, we just specify the default convention to lookup files located in Java classpath that start with <span class="FontName">messages</span>. In addition, the <span class="FontName">cacheSeconds</span> property set to <span class="FontName">1</span> to avoid reading stale message. Note that a refresh attempt first checks the last-modified timestamp of the properties file before actually reloading it; so if files don’t change, the <span class="FontName">cacheSeconds</span> interval can be set rather low, as refresh attempts aren’t actually reloaded.</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="messageSource"</span><br class="calibre10"/>          <span class="FontName">class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;</span><br class="calibre10"/>     <span class="FontName">&lt;property name="basenames"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;list&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;classpath:messages&lt;/value&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/list&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="cacheSeconds" value="1"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">For this <span class="FontName">MessageSource</span> definition, if you look up a text message for the United States locale, whose preferred language is English, the resource bundle <span class="FontName">message_en_US.properties</span> is considered first. If there’s no such resource bundle or the message can’t be found, then a <span class="FontName">message_en.properties</span> file that matches the language is considered. If a resource bundle still can’t be found, the default <span class="FontName">message.properties</span> for all locales is chosen. For more information on resource bundle loading, you can refer to the Javadoc of the <span class="FontName">java.util.ResourceBundle</span> class.</p><p class="indent">Next, you can configure the application context to resolve messages with the <span class="FontName">getMessage()</span> method. The first argument is the key corresponding to the message, and the third is the target locale.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) throws Exception {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span><br class="calibre10"/>            <span class="FontName">new GenericXmlApplicationContext("beans.xml");</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">String alert = context.getMessage("alert.checkout", null, Locale.US);</span><br class="calibre10"/>        <span class="FontName">System.out.println(alert);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">The second argument of the <span class="FontName">getMessage()</span><a id="cXXX.115" class="calibre5"></a> method is an array of message parameters. In the text message, you can define multiple parameters by index:</p><pre class="calibre11"><span class="FontName">alert.inventory.checkout=A shopping cart with {0} has been checked out at {1}.</span></pre><p class="indent">You have to pass in an object array to fill in the message parameters. The elements in this array are converted into strings before filling in the parameters.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) throws Exception {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">String alert = context.getMessage("alert.checkout",</span><br class="calibre10"/>                <span class="FontName">new Object[] { 4, new Date() }, Locale.US);</span><br class="calibre10"/>        <span class="FontName">System.out.println(alert);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In the <span class="FontName">Main</span> class, you can resolve text messages because you can access the application context directly. But for a bean to resolve text messages, you have to inject a <span class="FontName">MessageSource</span> implementation<a id="cXXX.116" class="calibre5"></a> into the bean that needs to resolve test message. Let’s implement a Cashier class for the shopping application that illustrates how to resolve messages.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Cashier {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private MessageSource messageSource;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setMessageSource(MessageSource messageSource) {</span><br class="calibre10"/>        <span class="FontName">this.messageSource = messageSource;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void checkout(ShoppingCart cart) throws IOException {</span><br class="calibre10"/>        <span class="FontName">String alert = messageSource.getMessage("alert.inventory.checkout",</span><br class="calibre10"/>                                                <span class="FontName">new Object[] { cart.getItems(), new Date() }, Locale.US);</span><br class="calibre10"/>        <span class="FontName">System.out.println(alert);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Notice the POJO <span class="FontName">messageSource</span> field is a Spring <span class="FontName">MessageSource</span> type. The field value will be populated through setter injection when the bean instance is created (to be explained shortly). Then the <span class="FontName">checkout</span> method can access the <span class="FontName">messageSource</span> field, which gives the bean access to the <span class="FontName">getMessage</span> method to gain access to text messages based on I18N criteria.</p><p class="indent"><a id="cXXX.117" class="calibre5"></a>Finally, you need to setup the bean definitions to setup the proper references.</p><pre class="calibre11"><span class="FontName">&lt;bean id="messageSource"       class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="basenames"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;list&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;classpath:messages&lt;/value&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/list&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;property name="cacheSeconds" value="1"/&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;bean id="cashier" class="com.apress.springrecipes.shop.Cashier"&gt;</span><br class="calibre10"/>   <span class="FontName">&lt;property name="messageSource"&gt;</span><br class="calibre10"/>     <span class="FontName">&lt;ref bean="messageSource"/&gt;</span><br class="calibre10"/>   <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p id="Sec50" class="Heading">2-8. Customize POJO Initialization and Destruction</p><p id="Sec51" class="Heading1">Problem</p><p class="noindent">Some POJOs have to perform certain types of initialization tasks before they’re used. These tasks can include opening a file, opening a network/database connection, allocating memory, and so on. In addition, these same POJO also have to perform the corresponding destruction tasks at the end of their life cycle. Therefore, sometimes it’s necessary to customize bean initialization and destruction in the Spring IoC container.</p><p id="Sec52" class="Heading1">Solution</p><p class="noindent">In addition to bean registration, the Spring IoC container also manages a POJOs life cycle. The Spring IoC container supports the addition of custom tasks at particular points in a POJOs life cycle. Custom life cycle tasks need to be encapsulated in callback methods for the Spring IoC container to call at a suitable time.</p><p class="indent">The following list shows the steps through which the Spring IoC container manages the life cycle of a bean. This list will be expanded as more features of the IoC container are introduced.</p><ol class="OrderedList"><li value="1" class="calibre17">Create the bean instance either by a constructor or by a factory method.</li>
<li value="2" class="calibre17">Set the values and bean references to the bean properties.</li>
<li value="3" class="calibre17">Call the initialization callback methods.</li>
<li value="4" class="calibre17">The bean is ready to be used.</li>
<li value="5" class="calibre17">When the container is shut down, call the destruction callback methods.</li></ol><p class="indent">Spring can recognize initialization and destruction callback methods by setting up the <span class="FontName">init-method</span> and <span class="FontName">destroy-method</span> attributes in the bean declaration and specify the callback method names.</p><p id="Sec53" class="Heading2">How It Works</p><p class="noindent">There are various ways to customize POJO the initialization and destruction. Next, we’ll take a look at three techniques. One approach consists of defining a set of methods to run before initialization and destruction. The other technique called lazy initialization<a id="cXXX.118" class="calibre5"></a> consists of delaying the POJO initialization process until a bean is required. And the last approach consists of initializing POJOs before other POJOs using the <span class="FontName">depends-on</span> attribute.</p><p id="Sec54" class="Heading2">Define Methods to Run Before POJO Initialization and Destruction</p><p class="noindent"><a id="cXXX.119" class="calibre5"></a>To illustrate how the Spring IoC container can call methods before a POJO’s initialization and destruction, let’s consider an example involving a checkout function for the shopping application. Let’s modify the <span class="FontName">Cashier</span> class from the previous recipe to record a shopping cart’s products and the checkout time to a text file.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Cashier {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private String fileName;</span><br class="calibre10"/>    <span class="FontName">private String path;</span><br class="calibre10"/>    <span class="FontName">private BufferedWriter writer;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setFileName(String fileName) {</span><br class="calibre10"/>        <span class="FontName">this.fileName = fileName;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setPath(String path) {</span><br class="calibre10"/>        <span class="FontName">this.path = path;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void openFile() throws IOException {</span><br class="calibre10"/>        <span class="FontName">File targetDir = new File(path);</span><br class="calibre10"/>        <span class="FontName">if (!targetDir.exists()) {</span><br class="calibre10"/>            <span class="FontName">targetDir.mkdir();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>       <span class="FontName">File checkoutFile = new File(path, fileName + ".txt");</span><br class="calibre10"/>        <span class="FontName">if(!checkoutFile.exists()) {</span><br class="calibre10"/>            <span class="FontName">checkoutFile.createNewFile();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>       <span class="FontName">writer = new BufferedWriter(new OutputStreamWriter(</span><br class="calibre10"/>                <span class="FontName">new FileOutputStream(checkoutFile, true)));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void checkout(ShoppingCart cart) throws IOException {</span><br class="calibre10"/>        <span class="FontName">writer.write(new Date() + "\t" +cart.getItems() + "\r\n");</span><br class="calibre10"/>        <span class="FontName">writer.flush();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void closeFile() throws IOException {</span><br class="calibre10"/>        <span class="FontName">writer.close();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">In the <span class="FontName">Cashier</span> class, the <span class="FontName">openFile()</span> method first verifies if the target directory and the file to write the data exists. It then opens the text file in the specified system path and assigns it to the <span class="FontName">writer</span> field. Then each time the <span class="FontName">checkout()</span> method is called, the date and cart items are appended to the text file. Finally, the <span class="FontName">closeFile()</span> method closes the file to release its system resources.</p><p class="indent">Next, it’s necessary to declare the bean in the IoC container. We’ll specify two properties to inject into the bean, a path directory and a file name.</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>   <span class="FontName">&lt;bean id="cashier" class="com.apress.springrecipes.shop.Cashier"</span><br class="calibre10"/>     <span class="FontName">init-method="openFile" destroy-method="closeFile"&gt;</span><br class="calibre10"/>      <span class="FontName">&lt;property name="fileName" value="checkout" /&gt;</span><br class="calibre10"/>      <span class="FontName">&lt;property name="path" value="c:/Windows/Temp/cashier" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><div class="notepara"><p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  The path value is set to c:/Windows/Temp/ because it’s a Windows world-writeable directory. If you use another path, ensure it’s accessible by the user that executes the application.</p></div>
<p class="indent">Spring allows a bean to perform initialization and destruction tasks by assigning POJO methods to the <span class="FontName">init-method</span> and <span class="FontName">destroy-method</span> attributes in a bean declaration. Note how the <span class="FontName">init-method</span> attribute has the <span class="FontName">openFile</span> value (i.e., the <span class="FontName">openFile</span> method) and the attribute <span class="FontName">destroy-method</span> attribute has the <span class="FontName">closeFile</span> value (i.e., the <span class="FontName">closeFile</span> method)</p><p class="indent">If these two attributes are set in the bean declaration, it indicates that when a <span class="FontName">Cashier</span> bean instance is created, that it first trigger the <span class="FontName">openFile</span> method—verifying if the target directory and the file to write the data exist, as well as opening the file to append records—and when the bean is destroyed that it trigger the <span class="FontName">closeFile</span> method—ensuring the file reference is closed to release system resources.</p><p id="Sec55" class="Heading2">Define Lazy Initialization for POJOs</p><p class="noindent"><a id="cXXX.120" class="calibre5"></a>By default, Spring performs eager initialization on all POJOs. This means POJOs are initialized at startup. In certain circumstances though, it can be convenient to delay the POJO initialization process until a bean is required. Delaying the initialization is called ‘lazy initialization’.</p><p class="indent">Lazy initialization helps limit resource consumption peaks at startup and save overall system resources. Lazy initialization can be particularly relevant for POJOs that perform heavyweight operations (e.g., network connections, file operations). To mark a bean with lazy initialization you set the <span class="FontName">lazy-init</span> attribute to <span class="FontName">true</span> in a <span class="FontName">&lt;bean&gt;</span> element.</p><pre class="calibre11"><span class="FontName">&lt;bean id="shoppingCart" lazy-init="true" class="com.apress.springrecipes.shop.ShoppingCart"       scope="prototype" /&gt;</span></pre><p class="indent">In the previous declaration because <span class="FontName">lazy-init="true"</span>, if the POJO is never required by the application or referenced by another POJO, it’s never instantiated.</p><p id="Sec56" class="Heading2">Define Initialization of POJOs Before Other POJOs</p><p class="noindent">As an application’s POJOs grow, so does the number of POJO initializations. This can create race conditions if POJOs reference one another and are spread out in different configuration files. What happens if bean ‘C’ requires the logic in bean ‘B’ and bean ‘F’? If bean ‘C’ is detected first and Spring hasn’t initialized bean ‘B’ and bean ‘F’, you’ll get an error which can be hard to detect.</p><p class="indent">To ensure that certain POJOs are initialized before other POJOs and to get a more descriptive error in case of a failed initialization process, Spring offers the <span class="FontName">depends-on</span> attribute. The <span class="FontName">depends-on</span> attribute ensures a given bean is initialized before another bean.</p><pre class="calibre11"><span class="FontName">&lt;bean id="sequenceGenerator"</span><br class="calibre10"/>      <span class="FontName">class="com.apress.springrecipes.sequence.SequenceGenerator"</span><br class="calibre10"/>      <span class="FontName">autowire="byType" depends-on="datePrefixGenerator"&gt;</span><br class="calibre10"/>      <span class="FontName">&lt;property name="initial" value="100000" /&gt;</span><br class="calibre10"/>      <span class="FontName">&lt;property name="suffix" value="A" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre><p class="indent">In the previous snippet, the declaration <span class="FontName">depends-on="datePrefixGenerator"</span> ensures the <span class="FontName">datePrefixGenerator</span> bean is created before the <span class="FontName">sequenceGenerator</span> bean. The <span class="FontName">depends-on</span> attribute also supports defining multiple dependency beans with a CSV list (e.g., <span class="FontName">depends-on="datePrefixGenerator,numberPrefixGenerator,randomPrefixGenerator"</span>).</p><p id="Sec57" class="Heading">2-9. Create Post Processors to Validate and Modify POJOs</p><p id="Sec58" class="Heading1">Problem</p><p class="noindent"><a id="cXXX.121" class="calibre5"></a>You want to apply tasks to all bean instances or specific types of instances during construction to validate or modify bean properties according to particular criteria.</p><p id="Sec59" class="Heading1">Solution</p><p class="noindent">A bean post processor allows bean processing before and after the initialization callback method (i.e., the one assigned to the <span class="FontName">init-method</span> attribute). <a id="cXXX.122" class="calibre5"></a>The main characteristic of a bean post processor is that it processes all the bean instances in the IoC container, not just a single bean instance. Typically, bean post processors are used to check the validity of bean properties, alter bean properties according to particular criteria or apply certain tasks to all bean instances.</p><p class="indent">The basic requirement of a bean post processor is to implement the <span class="FontName">BeanPostProcessor</span> interface. You can process every bean before and after the initialization callback method by implementing the <span class="FontName">postProcessBeforeInitialization()</span> and <span class="FontName">postProcessAfterInitialization()</span> methods. Then Spring passes each bean instance to these two methods before and after calling the initialization callback method<a id="cXXX.123" class="calibre5"></a>, as illustrated in the following list:</p><ol class="OrderedList"><li value="1" class="calibre17">Create the bean instance either by a constructor or by a factory method.</li>
<li value="2" class="calibre17">Set the values and bean references to the bean properties.</li>
<li value="3" class="calibre17">Pass the bean instance to the <span class="FontName">postProcessBeforeInitialization()</span> method of each bean post processor.</li>
<li value="4" class="calibre17">Call the initialization callback methods.</li>
<li value="5" class="calibre17">Pass the bean instance to the <span class="FontName">postProcessAfterInitialization()</span> method of each bean post processor.</li>
<li value="6" class="calibre17">The bean is ready to be used.</li>
<li value="7" class="calibre17">When the container is shut down, call the destruction callback methods.</li></ol><p class="indent">When using a bean factory as your IoC container, bean post processors<a id="cXXX.2011" class="calibre5"></a> can only be registered programmatically, or more accurately, via the <span class="FontName">addBeanPostProcessor()</span> method<a id="cXXX.124" class="calibre5"></a>. However, if you are using an application context, the registration is as simple as declaring an instance of the processor in the bean configuration file, and then it gets registered automatically.</p><p id="Sec60" class="Heading1">How It Works</p><p class="noindent">Suppose you want to audit the creation the every bean. You may want to do this to debug an application, verify the properties of every bean or some other scenario. A bean post processor is an ideal choice to implement this feature, because you don’t have to modify any pre-existing POJO code.</p><p id="Sec61" class="Heading2">Create POJO to Process Every Bean Instance</p><p class="noindent">To write a bean post processor a class has to implement <span class="FontName">BeanPostProcessor</span>. When Spring detects a bean that implements this class, it applies the <span class="FontName">postProcessBeforeInitialization()</span> and <span class="FontName">postProcessAfterInitialization()</span> methods<a id="cXXX.125" class="calibre5"></a> to all bean instances managed by Spring. You can implement any logic you wish in these methods, to either inspect, modify or verify the status of a bean.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.BeansException;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class AuditCheckBeanPostProcessor implements BeanPostProcessor {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Object postProcessBeforeInitialization(Object bean, String beanName)</span><br class="calibre10"/>            <span class="FontName">throws BeansException {</span><br class="calibre10"/>        <span class="FontName">System.out.println("In AuditCheckBeanPostProcessor.postProcessBeforeInitialization, processing bean type: " + bean.getClass());</span><br class="calibre10"/>        <span class="FontName">return bean;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Object postProcessAfterInitialization(Object bean, String beanName)</span><br class="calibre10"/>            <span class="FontName">throws BeansException {</span><br class="calibre10"/>        <span class="FontName">return bean;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">Notice the <span class="FontName">postProcessBeforeInitialization()</span> and <span class="FontName">postProcessAfterInitialization()</span> methods must return the original bean instance even if you don’t do anything in the method.</p><p class="indent">To register a bean post processor in an application context, just declare an instance of it in the bean configuration file. The application context is able to detect which bean implement the <span class="FontName">BeanPostProcessor</span> interface and register it to process all other bean instances in the container.</p><pre class="calibre11"><span class="FontName">&lt;bean class="com.apress.springrecipes.shop.ProductCheckBeanPostProcessor"/&gt;</span></pre><p id="Sec62" class="Heading2">Create POJO to Process Selected Bean Instances</p><p class="noindent">During bean construction, the Spring IoC container passes all the bean instances to the bean post processor one by one. This means if you only want to apply a bean post processor to certain types of beans, you must filter the beans by checking their instance type. This allows you to apply logic more selectively across beans.</p><p class="indent"><a id="cXXX.126" class="calibre5"></a>Suppose you want to apply a bean post processor but just to <span class="FontName">Product</span> bean instances. The following example is another bean post processor that does just this.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.BeansException;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class ProductCheckBeanPostProcessor implements BeanPostProcessor {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Object postProcessBeforeInitialization(Object bean, String beanName)</span><br class="calibre10"/>            <span class="FontName">throws BeansException {</span><br class="calibre10"/>        <span class="FontName">if (bean instanceof Product) {</span><br class="calibre10"/>            <span class="FontName">String productName = ((Product) bean).getName();</span><br class="calibre10"/>            <span class="FontName">System.out.println("In ProductCheckBeanPostProcessor.postProcessBeforeInitialization, processing Product: " + productName);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return bean;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Object postProcessAfterInitialization(Object bean, String beanName)</span><br class="calibre10"/>            <span class="FontName">throws BeansException {</span><br class="calibre10"/>        <span class="FontName">if (bean instanceof Product) {</span><br class="calibre10"/>            <span class="FontName">String productName = ((Product) bean).getName();</span><br class="calibre10"/>            <span class="FontName">System.out.println("In ProductCheckBeanPostProcessor.postProcessAfterInitialization, processing Product: " + productName);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return bean;</span><br class="calibre10"/>    <span class="FontName">}</span></pre><p class="indent">Both the <span class="FontName">postProcessBeforeInitialization()</span> and <span class="FontName">postProcessAfterInitialization()</span> methods must return an instance of the bean being processed. However, this also means you can even replace the original bean instance with a brand-new instance in your bean post processor.</p><p id="Sec63" class="Heading">2-10. Create POJOs with a Factory (Static Method, Instance Method, Spring’s FactoryBean)</p><p id="Sec64" class="Heading1">Problem</p><p class="noindent">You want to create a POJO instance in the Spring IoC container by invoking a static factory method or instance factory method. The purpose of this approach is to encapsulate the object-creation process<a id="cXXX.127" class="calibre5"></a> in either a static method or in a method of another object instance, respectively. The client who requests an object can simply make a call to this method without knowing about the creation details.</p><p class="indent">You want to create a POJO instance in the Spring IoC container using Spring’s factory bean<a id="cXXX.128" class="calibre5"></a>. A factory bean is a bean that serves as a factory for creating other beans within the IoC container. Conceptually, a factory bean is very similar to a factory method, but it’s a Spring-specific bean that can be identified by the Spring IoC container during bean construction.</p><p id="Sec65" class="Heading1">Solution</p><p class="noindent">To support the creation of a POJO by invoking a static factory method you use the <span class="FontName">factory-method</span> attribute of the <span class="FontName">&lt;bean&gt;</span> element. The support the creation of a POJO by invoking an instance factory method, the POJO instance is specified in the <span class="FontName">factory-bean</span> attribute of the <span class="FontName">&lt;bean&gt;</span> element.</p><p class="indent">As a convenience, Spring provides an abstract template class called <span class="FontName">AbstractFactoryBean</span><a id="cXXX.129" class="calibre5"></a><a id="cXXX.130" class="calibre5"></a> to extend Spring’s <span class="FontName">FactoryBean</span> interface. However, Spring Factory beans are mostly used to implement framework facilities, so you’ll seldom have to write custom factory beans. In addition, Spring already includes the most common factory implementations required by applications (e.g., <span class="FontName">JndiObjectFactoryBean</span> to lookup an object from JNDI, <span class="FontName">ProxyFactoryBean</span> to create an AOP proxy for a bean and <span class="FontName">LocalSessionFactoryBean</span> to create a Hibernate session factory).</p><p id="Sec66" class="Heading1">How It Works</p><p id="Sec67" class="Heading2">Create POJOs by Invoking a Static Factory Method<a id="cXXX.2020" class="calibre6"></a></p><p class="noindent"><a id="cXXX.131" class="calibre5"></a><a id="cXXX.132" class="calibre5"></a>For example, you can write the following <span class="FontName">createProduct</span> static factory method to create a product from a predefined product ID. According to the product ID, this method decides which concrete product class to instantiate. If there is no product matching this ID, Spring throws an <span class="FontName">IllegalArgumentException</span>.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class ProductCreator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static Product createProduct(String productId) {</span><br class="calibre10"/>        <span class="FontName">if ("aaa".equals(productId)) {</span><br class="calibre10"/>            <span class="FontName">return new Battery("AAA", 2.5);</span><br class="calibre10"/>        <span class="FontName">} else if ("cdrw".equals(productId)) {</span><br class="calibre10"/>            <span class="FontName">return new Disc("CD-RW", 1.5);</span><br class="calibre10"/>        <span class="FontName">} else if ("dvdrw".equals(productId)) {</span><br class="calibre10"/>            <span class="FontName">return new Disc("DVD-RW", 3.0);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">throw new IllegalArgumentException("Unknown product");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">To declare a bean created by a static factory method, you specify the class hosting the factory method in the <span class="FontName">class</span> attribute and the factory method’s name in the <span class="FontName">factory-method</span> attribute. Finally, you pass the method arguments by using the <span class="FontName">&lt;constructor-arg&gt;</span> elements.</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="aaa" class="com.apress.springrecipes.shop.ProductCreator"</span><br class="calibre10"/>        <span class="FontName">factory-method="createProduct"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;constructor-arg value="aaa" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="cdrw" class="com.apress.springrecipes.shop.ProductCreator"</span><br class="calibre10"/>        <span class="FontName">factory-method="createProduct"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;constructor-arg value="cdrw" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="dvdrw" class="com.apress.springrecipes.shop.ProductCreator"</span><br class="calibre10"/>        <span class="FontName">factory-method="createProduct"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;constructor-arg value="dvdrw" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">In case of any exception thrown by the factory method, Spring wraps it with a <span class="FontName">BeanCreationException</span>. The equivalent code snippet for the preceding bean configuration is :</p><pre class="calibre11"><span class="FontName">Product aaa = ProductCreator.createProduct("aaa");</span><br class="calibre10"/><span class="FontName">Product cdrw = ProductCreator.createProduct("cdrw");</span><br class="calibre10"/><span class="FontName">Product dvdrw = ProductCreator.createProduct("dvdrw");</span></pre><p id="Sec68" class="Heading2">Create POJOs by Invoking an Instance Factory Method</p><p class="noindent"><a id="cXXX.133" class="calibre5"></a>For example, you can write the following <span class="FontName">ProductCreator</span> class by using<a id="cXXX.134" class="calibre5"></a> a configurable map to store predefined products. The <span class="FontName">createProduct()</span> instance factory method finds a product by looking up the supplied <span class="FontName">productId</span> in the map. If there is no product matching this ID, it will throw an <span class="FontName">IllegalArgumentException</span>.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class ProductCreator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Map&lt;String, Product&gt; products;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setProducts(Map&lt;String, Product&gt; products) {</span><br class="calibre10"/>        <span class="FontName">this.products = products;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Product createProduct(String productId) {</span><br class="calibre10"/>        <span class="FontName">Product product = products.get(productId);</span><br class="calibre10"/>        <span class="FontName">if (product != null) {</span><br class="calibre10"/>            <span class="FontName">return product;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">throw new IllegalArgumentException("Unknown product");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">To create products from this <span class="FontName">ProductCreator</span>, you first declare an instance of it in the IoC container and configure its product map. You can declare the products in the map as inner beans. To declare a bean created by an instance factory method, you specify the bean hosting the factory method in the <span class="FontName">factory-bean</span> attribute, and the factory method’s name in the <span class="FontName">factory-method</span> attribute. Finally, you pass the method arguments by using the <span class="FontName">&lt;construtor-arg&gt;</span> elements.</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="productCreator"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.shop.ProductCreator"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="products"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;map&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;entry key="aaa"&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;bean class="com.apress.springrecipes.shop.Battery"&gt;</span><br class="calibre10"/>                        <span class="FontName">&lt;property name="name" value="AAA" /&gt;</span><br class="calibre10"/>                        <span class="FontName">&lt;property name="price" value="2.5" /&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;/entry&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;entry key="cdrw"&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;bean class="com.apress.springrecipes.shop.Disc"&gt;</span><br class="calibre10"/>                        <span class="FontName">&lt;property name="name" value="CD-RW" /&gt;</span><br class="calibre10"/>                        <span class="FontName">&lt;property name="price" value="1.5" /&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;/entry&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;entry key="dvdrw"&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;bean class="com.apress.springrecipes.shop.Disc"&gt;</span><br class="calibre10"/>                        <span class="FontName">&lt;property name="name" value="DVD-RW" /&gt;</span><br class="calibre10"/>                        <span class="FontName">&lt;property name="price" value="3.0" /&gt;</span><br class="calibre10"/>                    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;/entry&gt;</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">&lt;/map&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="aaa" factory-bean="productCreator"</span><br class="calibre10"/>        <span class="FontName">factory-method="createProduct"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;constructor-arg value="aaa" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="cdrw" factory-bean="productCreator"</span><br class="calibre10"/>        <span class="FontName">factory-method="createProduct"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;constructor-arg value="cdrw" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="dvdrw" factory-bean="productCreator"</span><br class="calibre10"/>        <span class="FontName">factory-method="createProduct"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;constructor-arg value="dvdrw" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">If any exception is thrown by the factory method, Spring wraps it with a <span class="FontName">BeanCreateException</span>. The equivalent code snippet for the preceding bean configuration is</p><pre class="calibre11"><span class="FontName">ProductCreator productCreator = new ProductCreator();</span><br class="calibre10"/><span class="FontName">productCreator.setProducts(...);</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">Product aaa = productCreator.createProduct("aaa");</span><br class="calibre10"/><span class="FontName">Product cdrw = productCreator.createProduct("cdrw");</span><br class="calibre10"/><span class="FontName">Product cdrw = productCreator.createProduct("dvdrw");</span></pre><p id="Sec69" class="Heading2">Create POJOs using Spring’s Factory bean</p><p class="noindent"><a id="cXXX.135" class="calibre5"></a><a id="cXXX.136" class="calibre5"></a>Although you’ll seldom have to write custom factory beans, you may find it helpful to understand their internal mechanisms through an example. For example, you can write a factory bean for creating a product with a discount applied to the price. It accepts a product property and a discount property to apply the discount to the product and return it as a new bean.</p><pre class="calibre11"><span class="FontName">package com.apress.springrecipes.shop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.config.AbstractFactoryBean;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class DiscountFactoryBean extends AbstractFactoryBean {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Product product;</span><br class="calibre10"/>    <span class="FontName">private double discount;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setProduct(Product product) {</span><br class="calibre10"/>        <span class="FontName">this.product = product;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setDiscount(double discount) {</span><br class="calibre10"/>        <span class="FontName">this.discount = discount;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Class getObjectType() {</span><br class="calibre10"/>        <span class="FontName">return product.getClass();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">protected Object createInstance() throws Exception {</span><br class="calibre10"/>        <span class="FontName">product.setPrice(product.getPrice() * (1 - discount));</span><br class="calibre10"/>        <span class="FontName">return product;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre><p class="indent">By extending the <span class="FontName">AbstractFactoryBean</span> class, the factory bean can simply override the <span class="FontName">createInstance()</span>method to create the target bean instance. In addition, you have to return the target bean’s type in the <span class="FontName">getObjectType()</span> method for the auto-wiring feature to work properly.</p><p class="indent">Next, you can declare product instances with <span class="FontName">DiscountFactoryBean</span>. Each time you request a bean that implements the <span class="FontName">FactoryBean</span> interface, the Spring IoC container uses this factory bean to create the target bean. If you are sure that you want to get the factory bean instance itself, you can use the bean name preceded by <span class="FontName">&amp;</span>.</p><pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="aaa"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.shop.DiscountFactoryBean"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="product"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;bean class="com.apress.springrecipes.shop.Battery"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="AAA" /&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="2.5" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="discount" value="0.2" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="cdrw"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.shop.DiscountFactoryBean"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="product"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;bean class="com.apress.springrecipes.shop.Disc"&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="CD-RW" /&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;constructor-arg value="1.5" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="discount" value="0.1" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre><p class="indent">The preceding factory bean configuration works in a similar way to the following code snippet:</p><pre class="calibre11"><span class="FontName">DiscountFactoryBean aaa = new DiscountFactoryBean();</span><br class="calibre10"/><span class="FontName">aaa.setProduct(new Battery("AAA", 2.5));</span><br class="calibre10"/><span class="FontName">aaa.setDiscount(0.2);</span><br class="calibre10"/><span class="FontName">Product aaa = (Product) aaa.createInstance();</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">DiscountFactoryBean cdrw = new DiscountFactoryBean();</span><br class="calibre10"/><span class="FontName">cdrw.setProduct(new Disc("CD-RW", 1.5));</span><br class="calibre10"/><span class="FontName">cdrw.setDiscount(0.1);</span><br class="calibre10"/><span class="FontName">Product cdrw = (Product) cdrw.createInstance();</span><br class="calibre10"/><span class="FontName">DiscountFactoryBean dvdrw = new DiscountFactoryBean();</span><br class="calibre10"/><span class="FontName">dvdrw.setProduct(new Disc("DVD-RW", 1.5));</span><br class="calibre10"/><span class="FontName">dvdrw.setDiscount(0.1);</span><br class="calibre10"/><span class="FontName">Product dvdrw = (Product) dvdrw.createInstance();</span></pre><p id="Sec70" class="Heading">2-11. Use Spring Environments and Profiles to Load Different Sets of POJOs</p><p id="Sec71" class="Heading1">Problem</p><p class="noindent"><a id="cXXX.137" class="calibre5"></a>You want to use the same set of POJO instances or beans but with different instantiation values for different application scenarios (e.g., ‘production’, ‘development’ &amp; ‘testing’ ). In addition, you want to use a single XML configuration<a id="cXXX.2270" class="calibre5"></a> file to define all beans.</p><p id="Sec72" class="Heading1">Solution</p><p class="noindent">Create a single XML configuration file and group POJOs instances or beans into multiple <span class="FontName">&lt;beans&gt;</span> sections. Assign a profile name to each <span class="FontName">&lt;beans&gt;</span> section based on the purpose of the group. Get the environment for an application’s context and set the profile to load a specific group of POJOs.</p><p id="Sec73" class="Heading1">How It Works</p><p class="noindent">POJO instantiation values can vary depending on different application scenarios. For example, a common scenario can occur when an application goes from development, to testing and on to production. In each of these scenarios, the properties for certain beans can vary slightly to accommodate environment changes (e.g., database username/password, file paths, etc.).</p><p class="indent">Prior to Spring Environments and Profiles, a common approach was to create multiple XML files with separate beans for each scenario. For example, <span class="FontName">beans-dev.xml</span>, <span class="FontName">beans-test.xml</span> and <span class="FontName">beans-prod.xml</span> and in the application context only load a given configuration file based on the scenario. Even though this last approach works, it’s error prone and can become unmanageable if you start to declare dozens of beans that can change often.</p><p id="Sec74" class="Heading2">Assign POJOs to Profile</p><p class="noindent">Let’s create multiple profiles for the shopping application presented in previous recipes. To illustrate the flexibility of Spring environments and profiles, we’ll classify the shopping application’s products into five profiles: spring, summer, autumn, winter, and global. Profiles are set on groups of beans and can’t be set on individual beans. You use the <span class="FontName">profile</span> attribute inside the <span class="FontName">&lt;beans&gt;</span> tag to define profiles.</p></div>
</body></html>
