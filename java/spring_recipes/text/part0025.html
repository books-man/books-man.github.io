<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Chapter 15 Spring Messaging</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre"><p class="ChapterNumber"><a id="b9781430259084_15" class="calibre6"></a>CHAPTER 15</p>
<p class="Chapimage"><img src="../images/00008.jpeg" alt="image" class="calibre3"/></p>
<p class="ChapterTitle">Spring Messaging</p>
<div class="calibre10"><p class="noindent">In this chapter, you will learn about Spring’s support for Java Message Service (JMS)<a id="cXXX.2081" class="calibre5"></a><a id="cXXX.1093" class="calibre5"></a>. JMS defines<a id="cXXX.1094" class="calibre5"></a> a set of standard APIs for message-oriented communication (using message-oriented middleware, a.k.a. MOM).</p>
<p class="indent">With JMS, different applications<a id="cXXX.1095" class="calibre5"></a> can communicate in a loosely coupled way compared with other remoting technologies such as RMI. However, when using the JMS API to send and receive messages, you have to manage the JMS resources yourself and handle the JMS API’s exceptions, which results in many lines of JMS-specific code. Spring simplifies JMS’s usage with a template-based approach. Moreover, Spring enables beans declared in its IoC container to listen for JMS messages and react to them.</p>
<p class="indent">Messaging is a very powerful technique for scaling applications. It allows work that would otherwise overwhelm a service to be queued up. It also encourages a decoupled architecture. A component, for example, might only consume messages with a single <span class="FontName">java.util.Map-</span>based key/value pair. This loose contract makes it a viable hub of communication for multiple, disparate systems.</p>
<p class="indent">In this chapter, we’ll refer quite a bit to “topics” and “queues”<a id="cXXX.2085" class="calibre5"></a><a id="cXXX.1096" class="calibre5"></a>. Messaging solutions are designed to solve two types of architecture requirements: messaging from one point in an application to another known point, and messaging from one point in an application to many other unknown points. These patterns are the middleware equivalents of telling somebody something face to face and saying something over a loud speaker to a room of people, respectively.</p>
<p class="indent">If you want messages sent on a message queue to be broadcast to an unknown set of clients who are “listening” for the message (as in the loud speaker analogy), send the message on a “topic”. If you want the message sent to a single, known client, then you send it over a “queue”.</p>
<p class="indent">By the end of this chapter, you will be able to create and access message-based middleware using Spring and JMS. This chapter will also provide you with a working knowledge of messaging in general, which will help you when we discuss Spring Integration. You will also know how to use Spring’s JMS support to simplify sending, receiving, and listening for JMS messages.</p>
<p id="Sec1" class="Heading">15-1. Send and Receive JMS Messages with Spring</p>
<p id="Sec2" class="Heading1">Problem</p>
<p class="noindent">To send or receive a JMS message, you have to perform the following tasks<a id="cXXX.1097" class="calibre5"></a>:</p>
<ol class="OrderedList">
<li value="1" class="calibre17">Create a JMS connection factory on a message broker.</li>
<li value="2" class="calibre17">Create a JMS destination, which can be either a queue or a topic.</li>
<li value="3" class="calibre17">Open a JMS connection from the connection factory.</li>
<li value="4" class="calibre17">Obtain a JMS session from the connection.</li>
<li value="5" class="calibre17">Send or receive the JMS message with a message producer or consumer.</li>
<li value="6" class="calibre17">Handle <span class="FontName">JMSException</span>, which is a checked exception that must be handled.</li>
<li value="7" class="calibre17">Close the JMS session and connection.</li></ol>
<p class="indent">As you can see, a lot of coding is required to send or receive a simple JMS message. In fact, most of these tasks are boilerplate and require you to repeat them each time when dealing with JMS.</p>
<p id="Sec3" class="Heading1">Solution</p>
<p class="noindent">Spring offers a template-based solution<a id="cXXX.1098" class="calibre5"></a> to simplify JMS code. With a JMS template (Spring framework class <span class="FontName">JmsTemplate</span>), you can send and receive JMS messages with much less code. The template handles the boilerplate tasks and also converts the JMS API’s <span class="FontName">JMSException</span> hierarchy into Spring’s runtime exception <span class="FontName">org.springframework.jms.JmsException</span> hierarchy.</p>
<p class="indent">This chapter focuses on Spring support for JMS 1.1<a id="cXXX.1099" class="calibre5"></a>, which is the most stable JMS release and is available through the Spring <span class="FontName">JmsTemplate</span> class. JMS 1.0.2 is deprecated -- although it’s supported in Spring through the legacy <span class="FontName">JmsTemplate102</span> class. The JMS 2.0 specification is being finalized at the time of this writing, so there’s no stable implementation for it.</p>
<p id="Sec4" class="Heading1">How It Works</p>
<p class="noindent">Suppose that you are developing a post office system that includes two subsystems: the front desk subsystem and the back office subsystem<a id="cXXX.1100" class="calibre5"></a>. When the front desk receives mail, it passes the mail to the back office for categorizing and delivering. At the same time, the front desk subsystem sends a JMS message to the back office subsystem, notifying it of new mail. The mail information is represented by the following class:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><span class="FontName">public class Mail {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private String mailId;</span><br class="calibre10"/>    <span class="FontName">private String country;</span><br class="calibre10"/>    <span class="FontName">private double weight;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Constructors, Getters and Setters</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The methods for sending and receiving mail information are defined in the <span class="FontName">FrontDesk</span> and <span class="FontName">BackOffice</span> interfaces as follows:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface FrontDesk {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void sendMail(Mail mail);</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface BackOffice {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Mail receiveMail();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Before you can send and receive JMS messages, you need to install a JMS message broker. For simplicity’s sake, we have chosen Apache ActiveMQ<a id="cXXX.1101" class="calibre5"></a> (<span class="FontName"><a href="http://activemq.apache.org/" class="calibre5">http://activemq.apache.org/</a></span>) as our message broker, which is very easy to install and configure. ActiveMQ is an open source message broker that fully supports JMS 1.1.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  You can download ActiveMQ (e.g., v5.9.1) from the ActiveMQ web site and extract it to a directory of your choice to complete the installation.</p></div>
<p id="Sec5" class="Heading2">Send and Receive Messages without Spring’s<a id="cXXX.2086" class="calibre6"></a> JMS template Support</p>
<p class="noindent">First, let’s look at how to send and receive JMS messages without Spring’s JMS template support. The following <span class="FontName">FrontDeskImpl</span> class<a id="cXXX.1102" class="calibre5"></a> sends JMS messages with the JMS API directly.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.jms.Connection;</span><br class="calibre10"/><span class="FontName">import javax.jms.ConnectionFactory;</span><br class="calibre10"/><span class="FontName">import javax.jms.Destination;</span><br class="calibre10"/><span class="FontName">import javax.jms.JMSException;</span><br class="calibre10"/><span class="FontName">import javax.jms.MapMessage;</span><br class="calibre10"/><span class="FontName">import javax.jms.MessageProducer;</span><br class="calibre10"/><span class="FontName">import javax.jms.Session;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.apache.activemq.ActiveMQConnectionFactory;</span><br class="calibre10"/><span class="FontName">import org.apache.activemq.command.ActiveMQQueue;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class FrontDeskImpl implements FrontDesk {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void sendMail(Mail mail) {</span><br class="calibre10"/>        <span class="FontName">ConnectionFactory cf =</span><br class="calibre10"/>            <span class="FontName">new ActiveMQConnectionFactory("tcp://localhost:61616");</span><br class="calibre10"/>        <span class="FontName">Destination destination = new ActiveMQQueue("mail.queue");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Connection conn = null;</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">conn = cf.createConnection();</span><br class="calibre10"/>            <span class="FontName">Session session =</span><br class="calibre10"/>                <span class="FontName">conn.createSession(false, Session.AUTO_ACKNOWLEDGE);</span><br class="calibre10"/>            <span class="FontName">MessageProducer producer = session.createProducer(destination);</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">MapMessage message = session.createMapMessage();</span><br class="calibre10"/>            <span class="FontName">message.setString("mailId", mail.getMailId());</span><br class="calibre10"/>            <span class="FontName">message.setString("country", mail.getCountry());</span><br class="calibre10"/>            <span class="FontName">message.setDouble("weight", mail.getWeight());</span><br class="calibre10"/>            <span class="FontName">producer.send(message);</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">session.close();</span><br class="calibre10"/>        <span class="FontName">} catch (JMSException e) {</span><br class="calibre10"/>            <span class="FontName">throw new RuntimeException(e);</span><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">if (conn != null) {</span><br class="calibre10"/>                <span class="FontName">try {</span><br class="calibre10"/>                    <span class="FontName">conn.close();</span><br class="calibre10"/>                <span class="FontName">} catch (JMSException e) {</span><br class="calibre10"/>                <span class="FontName">}</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In the preceding <span class="FontName">sendMail()</span> method<a id="cXXX.1103" class="calibre5"></a>, you first create JMS-specific <span class="FontName">ConnectionFactory</span> and <span class="FontName">Destination</span> objects with the classes provided by ActiveMQ. The message broker URL is the default for ActiveMQ if you run it on localhost. In JMS, there are two types of destinations: queue and topic.</p>
<p class="indent">As explained at the start of the chapter, a queue is for the point-to-point communication model<a id="cXXX.1104" class="calibre5"></a>, while topic is for the publish-subscribe communication model. Because you are sending JMS messages point to point from front desk to back office, you should use a message queue. You can easily create a topic as a destination using the <span class="FontName">ActiveMQTopic</span> class.</p>
<p class="indent">Next, you have to create a connection, session, and message producer before you can send your message. There are several types of messages defined in the JMS API, including <span class="FontName">TextMessage</span>, <span class="FontName">MapMessage</span>, <span class="FontName">BytesMessage</span>, <span class="FontName">ObjectMessage</span>, and <span class="FontName">StreamMessage. MapMessage</span> contains message content in key/value pairs like a map. All of them are interfaces, whose super class is simply <span class="FontName">Message</span>. In the meantime, you have to handle <span class="FontName">JMSException</span>, which may be thrown by the JMS API. Finally, you must remember to close the session and connection to release system resources. Every time a JMS connection is closed, all its opened sessions will be closed automatically. So you only have to ensure that the JMS connection is closed properly in the <span class="FontName">finally</span> block.</p>
<p class="indent">On the other hand, the following <span class="FontName">BackOfficeImpl</span> class<a id="cXXX.1105" class="calibre5"></a> receives JMS messages with the JMS API directly:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.jms.Connection;</span><br class="calibre10"/><span class="FontName">import javax.jms.ConnectionFactory;</span><br class="calibre10"/><span class="FontName">import javax.jms.Destination;</span><br class="calibre10"/><span class="FontName">import javax.jms.JMSException;</span><br class="calibre10"/><span class="FontName">import javax.jms.MapMessage;</span><br class="calibre10"/><span class="FontName">import javax.jms.MessageConsumer;</span><br class="calibre10"/><span class="FontName">import javax.jms.Session;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.apache.activemq.ActiveMQConnectionFactory;</span><br class="calibre10"/><span class="FontName">import org.apache.activemq.command.ActiveMQQueue;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class BackOfficeImpl implements BackOffice {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Mail receiveMail() {</span><br class="calibre10"/>        <span class="FontName">ConnectionFactory cf =</span><br class="calibre10"/>            <span class="FontName">new ActiveMQConnectionFactory("tcp://localhost:61616");</span><br class="calibre10"/>        <span class="FontName">Destination destination = new ActiveMQQueue("mail.queue");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Connection conn = null;</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">conn = cf.createConnection();</span><br class="calibre10"/>            <span class="FontName">Session session =</span><br class="calibre10"/>                <span class="FontName">conn.createSession(false, Session.AUTO_ACKNOWLEDGE);</span><br class="calibre10"/>            <span class="FontName">MessageConsumer consumer = session.createConsumer(destination);</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">conn.start();</span><br class="calibre10"/>            <span class="FontName">MapMessage message = (MapMessage) consumer.receive();</span><br class="calibre10"/>            <span class="FontName">Mail mail = new Mail();</span><br class="calibre10"/>            <span class="FontName">mail.setMailId(message.getString("mailId"));</span><br class="calibre10"/>            <span class="FontName">mail.setCountry(message.getString("country"));</span><br class="calibre10"/>            <span class="FontName">mail.setWeight(message.getDouble("weight"));</span><br class="calibre10"/>            <span class="FontName">session.close();</span><br class="calibre10"/>            <span class="FontName">return mail;</span><br class="calibre10"/>        <span class="FontName">} catch (JMSException e) {</span><br class="calibre10"/>            <span class="FontName">throw new RuntimeException(e);</span><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">if (conn != null) {</span><br class="calibre10"/>                <span class="FontName">try {</span><br class="calibre10"/>                    <span class="FontName">conn.close();</span><br class="calibre10"/>                <span class="FontName">} catch (JMSException e) {</span><br class="calibre10"/>                <span class="FontName">}</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Most of the code in this method is similar to that for sending JMS messages, except that you create a message consumer and receive a JMS message from it. Note that we used the connection’s <span class="FontName">start()</span> method here, although we didn’t in the <span class="FontName">FrontDeskImpl</span> example before.</p>
<p class="indent">When using a <span class="FontName">Connection</span> to receive messages, you can add listeners to the connection that are invoked on receipt of a message, or you can block synchronously, waiting for a message to arrive. The container has no way of knowing which approach you will take and so it doesn’t start polling for messages until you’ve explicitly called <span class="FontName">start()</span>. If you add listeners or do any kind of configuration, you do so before you invoke <span class="FontName">start()</span>.</p>
<p class="indent">Finally, lets create two POJO configuration files<a id="cXXX.1106" class="calibre5"></a>—one for the front desk subsystem (e.g., <span class="FontName">beans-front.xml</span>), and one for the back office subsystem (e.g., <span class="FontName">beans-back.xml</span>)—in the root of the classpath.</p>
<pre class="calibre11"><span class="FontName">&lt;beans  xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="frontDesk"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.post.FrontDeskImpl" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/beans&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans  xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="backOffice"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.post.BackOfficeImpl" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">Now, the front desk and back office subsystems are almost ready to send and receive JMS messages. But before moving on to the final step, start up the ActiveMQ message broker<a id="cXXX.1107" class="calibre5"></a>.</p>
<p class="indent">To start ActiveMQ, just execute one of the ActiveMQ startup scripts for your operating system. The script itself is called <span class="FontName">activemq.sh</span> or <span class="FontName">activemq.bat</span> for Unix variants or Windows, respectively, and is located in the <span class="FontName">bin</span> directory.</p>
<p class="indent">You can easily monitor the ActiveMQ messaging broker’s activity. In a default installation, you can open <span class="FontName">http://localhost:8161/admin/queueGraph.jsp</span> to see what’s happening with <span class="FontName">mail.queue</span>, the queue used in these examples. Alternatively, ActiveMQ exposes very useful beans and statistics from JMX. Simply run <span class="FontName">jconsole</span>, and drill down to <span class="FontName">org.apache.activemq</span> in the MBeans tab.</p>
<p class="indent">Next, let’s create a couple of main classes to run the message system. One for the FrontDesk subsystem -- <span class="FontName">FrontDeskMain</span> class -- and another for the BackOffice subsystem -- <span class="FontName">BackOfficeMain --</span>class.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class FrontDeskMain {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context = new GenericXmlApplicationContext("beans-front.xml");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">FrontDesk frontDesk = context.getBean("FrontDesk.class);</span><br class="calibre10"/>        <span class="FontName">frontDesk.sendMail(new Mail("1234", "US", 1.5));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class BackOfficeMain {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context = new GenericXmlApplicationContext("beans-back.xml");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">BackOffice backOffice = context.getBean(BackOffice.class);</span><br class="calibre10"/>        <span class="FontName">Mail mail = backOffice.receiveMail();</span><br class="calibre10"/>        <span class="FontName">System.out.println("Mail #" + mail.getMailId() + " received");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Every time you run the FrontDesk application with the previous <span class="FontName">FrontDeskMain</span> class a message is sent to the broker and every time you run the BackOffice application with the previous <span class="FontName">BackOfficeMain</span> class an attempt is made pick a message from the broker.</p>
<p id="Sec6" class="Heading2">Send and Receive Messages with Spring’s JMS Template</p>
<p class="noindent">Spring offers a JMS template that can significantly simplify your JMS code. To send a JMS message with<a id="cXXX.2086a" class="calibre5"></a> this template, you simply call the <span class="FontName">send()</span> method and provide a message destination, as well as a <span class="FontName">MessageCreator</span> object, which creates the JMS message you are going to send. The <span class="FontName">MessageCreator</span> object<a id="cXXX.1108" class="calibre5"></a> is usually implemented as an anonymous inner class.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.jms.Destination;</span><br class="calibre10"/><span class="FontName">import javax.jms.JMSException;</span><br class="calibre10"/><span class="FontName">import javax.jms.MapMessage;</span><br class="calibre10"/><span class="FontName">import javax.jms.Message;</span><br class="calibre10"/><span class="FontName">import javax.jms.Session;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.jms.core.JmsTemplate;</span><br class="calibre10"/><span class="FontName">import org.springframework.jms.core.MessageCreator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class FrontDeskImpl implements FrontDesk {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private JmsTemplate jmsTemplate;</span><br class="calibre10"/>    <span class="FontName">private Destination destination;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setJmsTemplate(JmsTemplate jmsTemplate) {</span><br class="calibre10"/>        <span class="FontName">this.jmsTemplate = jmsTemplate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setDestination(Destination destination) {</span><br class="calibre10"/>        <span class="FontName">this.destination = destination;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void sendMail(final Mail mail) {</span><br class="calibre10"/>        <span class="FontName">jmsTemplate.send(destination, new MessageCreator() {</span><br class="calibre10"/>            <span class="FontName">public Message createMessage(Session session) throws JMSException {</span><br class="calibre10"/>                <span class="FontName">MapMessage message = session.createMapMessage();</span><br class="calibre10"/>                <span class="FontName">message.setString("mailId", mail.getMailId());</span><br class="calibre10"/>                <span class="FontName">message.setString("country", mail.getCountry());</span><br class="calibre10"/>                <span class="FontName">message.setDouble("weight", mail.getWeight());</span><br class="calibre10"/>                <span class="FontName">return message;</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">});</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Note that an inner class can only access arguments or variables of the enclosing method that are declared as final. The <span class="FontName">MessageCreator</span> interface declares only a <span class="FontName">createMessage()</span> method<a id="cXXX.1109" class="calibre5"></a> for you to implement. In this method, you create and return your JMS message with the provided JMS session.</p>
<p class="indent">A JMS template helps you to obtain and release the JMS connection and session, and it sends the JMS message created by your <span class="FontName">MessageCreator</span> object. Moreover, it converts the JMS API’s <span class="FontName">JMSException</span> hierarchy into Spring’s JMS runtime exception hierarchy, whose base exception class is <span class="FontName">org.springframework.jms.JmsException</span>. You can catch the <span class="FontName">JmsException</span> thrown from send and the other send variants and then take action in the catch block if you want.</p>
<p class="indent">In the front desk subsystem’s bean configuration file, you declare a JMS template that refers to the JMS connection factory for opening connections. Then, you inject this template as well as the message destination into your front desk bean<a id="cXXX.1110" class="calibre5"></a>.</p>
<pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="connectionFactory"</span><br class="calibre10"/>        <span class="FontName">class="org.apache.activemq.ActiveMQConnectionFactory"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="mailDestination"</span><br class="calibre10"/>        <span class="FontName">class="org.apache.activemq.command.ActiveMQQueue"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;constructor-arg value="mail.queue" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="jmsTemplate"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jms.core.JmsTemplate"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="connectionFactory" ref="connectionFactory" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="frontDesk"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.post.FrontDeskImpl"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="destination" ref="mailDestination" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="jmsTemplate" ref="jmsTemplate" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">We could also use Java based configuration to express the same configuration.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.post.FrontDeskImpl;</span><br class="calibre10"/><span class="FontName">import org.apache.activemq.ActiveMQConnectionFactory;</span><br class="calibre10"/><span class="FontName">import org.apache.activemq.command.ActiveMQQueue;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.jms.core.JmsTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.jms.ConnectionFactory;</span><br class="calibre10"/><span class="FontName">import javax.jms.Queue;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class FrontOfficeConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public ConnectionFactory connectionFactory() {</span><br class="calibre10"/>        <span class="FontName">return new ActiveMQConnectionFactory("tcp://localhost:61616");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public Queue destination() {</span><br class="calibre10"/>        <span class="FontName">return new ActiveMQQueue("mail.queue");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public JmsTemplate jmsTemplate() {</span><br class="calibre10"/>        <span class="FontName">JmsTemplate jmsTemplate = new JmsTemplate();</span><br class="calibre10"/>        <span class="FontName">jmsTemplate.setConnectionFactory(connectionFactory());</span><br class="calibre10"/>        <span class="FontName">return jmsTemplate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public FrontDeskImpl frontDesk() {</span><br class="calibre10"/>        <span class="FontName">FrontDeskImpl frontDesk = new FrontDeskImpl();</span><br class="calibre10"/>        <span class="FontName">frontDesk.setJmsTemplate(jmsTemplate());</span><br class="calibre10"/>        <span class="FontName">frontDesk.setDestination(destination());</span><br class="calibre10"/>        <span class="FontName">return frontDesk;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">To receive a JMS message with a JMS template, you call the <span class="FontName">receive()</span> method<a id="cXXX.1111" class="calibre5"></a> by providing a message destination. This method returns a JMS message, <span class="FontName">javax.jms.Message</span>, whose type is the base JMS message type (that is, an interface), so you have to cast it into proper type before further processing.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.jms.Destination;</span><br class="calibre10"/><span class="FontName">import javax.jms.JMSException;</span><br class="calibre10"/><span class="FontName">import javax.jms.MapMessage;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.jms.core.JmsTemplate;</span><br class="calibre10"/><span class="FontName">import org.springframework.jms.support.JmsUtils;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class BackOfficeImpl implements BackOffice {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private JmsTemplate jmsTemplate;</span><br class="calibre10"/>    <span class="FontName">private Destination destination;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setJmsTemplate(JmsTemplate jmsTemplate) {</span><br class="calibre10"/>        <span class="FontName">this.jmsTemplate = jmsTemplate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setDestination(Destination destination) {</span><br class="calibre10"/>        <span class="FontName">this.destination = destination;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Mail receiveMail() {</span><br class="calibre10"/>        <span class="FontName">MapMessage message = (MapMessage) jmsTemplate.receive(destination);</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">if (message == null) {</span><br class="calibre10"/>                <span class="FontName">return null;</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>            <span class="FontName">Mail mail = new Mail();</span><br class="calibre10"/>            <span class="FontName">mail.setMailId(message.getString("mailId"));</span><br class="calibre10"/>            <span class="FontName">mail.setCountry(message.getString("country"));</span><br class="calibre10"/>            <span class="FontName">mail.setWeight(message.getDouble("weight"));</span><br class="calibre10"/>            <span class="FontName">return mail;</span><br class="calibre10"/>        <span class="FontName">} catch (JMSException e) {</span><br class="calibre10"/>            <span class="FontName">throw JmsUtils.convertJmsAccessException(e);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">However, when extracting information from the received <span class="FontName">MapMessage</span> object, you still have to handle the JMS API’s <span class="FontName">JMSException</span>. This is in stark contrast to the default behavior of the framework, where it automatically maps exceptions for you when invoking methods on the <span class="FontName">JmsTemplate</span><a id="cXXX.2091" class="calibre5"></a>. To make the type of the exception thrown by this method consistent, you have to make a call to <span class="FontName">JmsUtils.convertJmsAccessException()</span> to convert the JMS API’s <span class="FontName">JMSException</span> into Spring’s <span class="FontName">JmsException</span>.</p>
<p class="indent">In the back office subsystem’s bean configuration file, you declare a JMS template and inject it together with the message destination into your back office bean<a id="cXXX.1112" class="calibre5"></a>.</p>
<pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="connectionFactory"</span><br class="calibre10"/>        <span class="FontName">class="org.apache.activemq.ActiveMQConnectionFactory"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="mailDestination"</span><br class="calibre10"/>        <span class="FontName">class="org.apache.activemq.command.ActiveMQQueue"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;constructor-arg value="mail.queue" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="jmsTemplate"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jms.core.JmsTemplate"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="connectionFactory" ref="connectionFactory" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="receiveTimeout" value="10000" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="backOffice"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.post.BackOfficeImpl"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="destination" ref="mailDestination" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="jmsTemplate" ref="jmsTemplate" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">Pay special attention to the JMS template <span class="FontName">receiveTimeout</span> property, it specifies how long to wait in milliseconds. By default, this template waits for a JMS message at the destination forever, and the calling thread is blocked in the meantime. To avoid waiting for a message so long, you should specify a receive timeout for this template. If there’s no message available at the destination in the duration, the JMS template’s <span class="FontName">receive()</span> method will return a <span class="FontName">null</span> message.<a id="cXXX.1113" class="calibre5"></a></p>
<p class="indent">Of course we can express this as Java based configuration</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.post.BackOfficeImpl;</span><br class="calibre10"/><span class="FontName">import org.apache.activemq.ActiveMQConnectionFactory;</span><br class="calibre10"/><span class="FontName">import org.apache.activemq.command.ActiveMQQueue;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.jms.core.JmsTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.jms.ConnectionFactory;</span><br class="calibre10"/><span class="FontName">import javax.jms.Queue;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class BackOfficeConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public ConnectionFactory connectionFactory() {</span><br class="calibre10"/>        <span class="FontName">return new ActiveMQConnectionFactory("tcp://localhost:61616");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public Queue destination() {</span><br class="calibre10"/>        <span class="FontName">return new ActiveMQQueue("mail.queue");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public JmsTemplate jmsTemplate() {</span><br class="calibre10"/>        <span class="FontName">JmsTemplate jmsTemplate = new JmsTemplate();</span><br class="calibre10"/>        <span class="FontName">jmsTemplate.setConnectionFactory(connectionFactory());</span><br class="calibre10"/>        <b class="calibre4">jmsTemplate.setReceiveTimeout(10000);</b><br class="calibre10"/>        <span class="FontName">return jmsTemplate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public BackOfficeImpl backOffice() {</span><br class="calibre10"/>        <span class="FontName">BackOfficeImpl backOffice = new BackOfficeImpl();</span><br class="calibre10"/>        <span class="FontName">backOffice.setDestination(destination());</span><br class="calibre10"/>        <span class="FontName">backOffice.setJmsTemplate(jmsTemplate());</span><br class="calibre10"/>        <span class="FontName">return backOffice;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In your applications, the main use of receiving a message might be because you’re expecting a response to something or want to check for messages at an interval, handling the messages and then spinning down until the next interval. If you intend to receive messages and respond to them as a service, you’re likely going to want to use the message-driven POJO functionality described later in this chapter. There, we discuss a mechanism that will constantly sit and wait for messages, handling them by calling back into your application as the messages arrive.</p>
<p id="Sec7" class="Heading2">Send and Receive Messages to and from a Default Destination<a id="cXXX.1114" class="calibre6"></a></p>
<p class="noindent">Instead of specifying a message destination for each JMS template’s <span class="FontName">send()</span> and <span class="FontName">receive()</span> method call, you can specify a default destination for a JMS template. Then, you no longer need to inject it into your message sender and receiver beans again.</p>
<pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="jmsTemplate"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jms.core.JmsTemplate"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="connectionFactory" ref="connectionFactory" /&gt;</span><br class="calibre10"/>        <b class="calibre4">&lt;property name="defaultDestination" ref="mailDestination" /&gt;</b><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="frontDesk"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.post.FrontDeskImpl"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="jmsTemplate" ref="jmsTemplate" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">In Java config:</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class FrontOfficeConfiguration {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public JmsTemplate jmsTemplate() {</span><br class="calibre10"/>        <span class="FontName">JmsTemplate jmsTemplate = new JmsTemplate();</span><br class="calibre10"/>        <span class="FontName">jmsTemplate.setConnectionFactory(connectionFactory());</span><br class="calibre10"/>        <b class="calibre4">jmsTemplate.setDefaultDestination(mailDestination());</b><br class="calibre10"/>        <span class="FontName">return jmsTemplate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public FrontDeskImpl frontDesk() {</span><br class="calibre10"/>        <span class="FontName">FrontDeskImpl frontDesk = new FrontDeskImpl();</span><br class="calibre10"/>        <span class="FontName">frontDesk.setJmsTemplate(jmsTemplate());</span><br class="calibre10"/>        <span class="FontName">return frontDesk;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">For the back office the configuration would look like this.</p>
<pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="jmsTemplate"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jms.core.JmsTemplate"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="receiveTimeout" value ="10000"/&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="connectionFactory" ref="connectionFactory" /&gt;</span><br class="calibre10"/>        <b class="calibre4">&lt;property name="defaultDestination" ref="mailDestination" /&gt;</b><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="backOffice"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.post.BackOfficeImpl"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="jmsTemplate" ref="jmsTemplate" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">In Java based configuration</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class BackOfficeConfiguration {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public JmsTemplate jmsTemplate() {</span><br class="calibre10"/>        <span class="FontName">JmsTemplate jmsTemplate = new JmsTemplate();</span><br class="calibre10"/>        <span class="FontName">jmsTemplate.setConnectionFactory(connectionFactory());</span><br class="calibre10"/>        <b class="calibre4">jmsTemplate.setDefaultDestination(mailDestination());</b><br class="calibre10"/>        <span class="FontName">jmsTemplate.setReceiveTimeout(10000);</span><br class="calibre10"/>        <span class="FontName">return jmsTemplate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public BackOfficeImpl backOffice() {</span><br class="calibre10"/>        <span class="FontName">BackOfficeImpl backOffice = new BackOfficeImpl();</span><br class="calibre10"/>        <span class="FontName">backOffice.setJmsTemplate(jmsTemplate());</span><br class="calibre10"/>        <span class="FontName">return backOffice;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">With the default destination specified for a JMS template, you can delete the setter method for a message destination from your message sender and receiver classes. Now, when you call the <span class="FontName">send()</span> and <span class="FontName">receive()</span> methods, you no longer need to specify a message destination.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jms.core.MessageCreator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class FrontDeskImpl implements FrontDesk {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public void sendMail(final Mail mail) {</span><br class="calibre10"/>        <span class="FontName">jmsTemplate.send(new MessageCreator() {</span><br class="calibre10"/>            <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">});</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import javax.jms.MapMessage;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class BackOfficeImpl implements BackOffice {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public Mail receiveMail() {</span><br class="calibre10"/>        <span class="FontName">MapMessage message = (MapMessage) jmsTemplate.receive();</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In addition, instead of specifying an instance of the <span class="FontName">Destination</span> interface for a JMS template, you can specify the destination name to let the JMS template resolve it for you, so you can delete the <span class="FontName">destination</span> property declaration from both bean configuration files. This is done by adding the <span class="FontName">defaultDestinationName</span> property.</p>
<pre class="calibre11"><span class="FontName">&lt;bean id="jmsTemplate"</span><br class="calibre10"/>    <span class="FontName">class="org.springframework.jms.core.JmsTemplate"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;property name="defaultDestinationName" value="mail.queue" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre>
<p class="indent">And in Java based configuration style.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public JmsTemplate jmsTemplate() {</span><br class="calibre10"/>        <span class="FontName">JmsTemplate jmsTemplate = new JmsTemplate();</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <b class="calibre4">jmsTemplate.setDefaultDestinationName("mail.queue");</b><br class="calibre10"/>        <span class="FontName">return jmsTemplate;</span><br class="calibre10"/>    <span class="FontName">}</span></pre>
<p id="Sec8" class="Heading2">Extend the JmsGatewaySupport Class</p>
<p class="noindent"><a id="cXXX.1115" class="calibre5"></a>JMS sender and receiver classes can also extend <span class="FontName">JmsGatewaySupport</span> to retrieve a JMS template. You have the following two options for classes that extend <span class="FontName">JmsGatewaySupport</span> to create their JMS template:</p>
<ul class="bulleted">
<li class="calibre17">Inject a JMS connection factory for <span class="FontName">JmsGatewaySupport</span> to create a JMS template on it automatically. However, if you do it this way, you won’t be able to configure the details of the JMS template.</li>
<li class="calibre17">Inject a JMS template for <span class="FontName">JmsGatewaySupport</span> that is created and configured by you.</li></ul>
<p class="indent">Of them, the second approach is more suitable if you have to configure the JMS template yourself. You can delete the private field <span class="FontName">jmsTemplate</span> and its setter method from both your sender and receiver classes. When you need access to the JMS template, you just make a call to <span class="FontName">getJmsTemplate()</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.jms.core.support.JmsGatewaySupport;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class FrontDeskImpl extends JmsGatewaySupport implements FrontDesk {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public void sendMail(final Mail mail) {</span><br class="calibre10"/>        <span class="FontName">getJmsTemplate().send(new MessageCreator() {</span><br class="calibre10"/>            <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">});</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.jms.core.support.JmsGatewaySupport;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class BackOfficeImpl extends JmsGatewaySupport implements BackOffice {</span><br class="calibre10"/>    <span class="FontName">public Mail receiveMail() {</span><br class="calibre10"/>        <span class="FontName">MapMessage message = (MapMessage) getJmsTemplate().receive();</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec9" class="Heading">15-2. Convert JMS Messages</p>
<p id="Sec10" class="Heading1">Problem<a id="cXXX.1116" class="calibre6"></a></p>
<p class="noindent">Your application receives messages from your message queue but needs to transform those messages from the JMS-specific type to a business-specific class.</p>
<p id="Sec11" class="Heading1">Solution</p>
<p class="noindent">Spring provides an implementation of <span class="FontName">SimpleMessageConvertor</span> to handle the translation of a JMS message received to a business object and the translation of a business object to a JMS message. You can leverage the default or provide your own.</p>
<p id="Sec12" class="Heading1">How It Works</p>
<p class="noindent">The previous recipes handled the raw JMS messages. Spring’s JMS template can help you convert JMS messages to and from Java objects using a message converter. By default, the JMS template uses <span class="FontName">SimpleMessageConverter</span> for converting <span class="FontName">TextMessage</span> to or from a string, <span class="FontName">BytesMessage</span> to or from a byte array, <span class="FontName">MapMessage</span> to or from a map, and <span class="FontName">ObjectMessage</span> to or from a serializable object.</p>
<p class="indent">For the front desk and back office classes of the past recipe, you can send and receive a map using the <span class="FontName">convertAndSend()</span> and <span class="FontName">receiveAndConvert()</span> methods, where the map is converted to/from <span class="FontName">MapMessage</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class FrontDeskImpl extends JmsGatewaySupport implements FrontDesk {</span><br class="calibre10"/>    <span class="FontName">public void sendMail(Mail mail) {</span><br class="calibre10"/>        <span class="FontName">Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br class="calibre10"/>        <span class="FontName">map.put("mailId", mail.getMailId());</span><br class="calibre10"/>        <span class="FontName">map.put("country", mail.getCountry());</span><br class="calibre10"/>        <span class="FontName">map.put("weight", mail.getWeight());</span><br class="calibre10"/>        <span class="FontName">getJmsTemplate().convertAndSend(map);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class BackOfficeImpl extends JmsGatewaySupport implements BackOffice {</span><br class="calibre10"/>    <span class="FontName">public Mail receiveMail() {</span><br class="calibre10"/>        <span class="FontName">Map map = (Map) getJmsTemplate().receiveAndConvert();</span><br class="calibre10"/>        <span class="FontName">Mail mail = new Mail();</span><br class="calibre10"/>        <span class="FontName">mail.setMailId((String) map.get("mailId"));</span><br class="calibre10"/>        <span class="FontName">mail.setCountry((String) map.get("country"));</span><br class="calibre10"/>        <span class="FontName">mail.setWeight((Double) map.get("weight"));</span><br class="calibre10"/>        <span class="FontName">return mail;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You can also create a custom message converter by implementing the <span class="FontName">MessageConverter</span> interface for converting mail objects.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.jms.JMSException;</span><br class="calibre10"/><span class="FontName">import javax.jms.MapMessage;</span><br class="calibre10"/><span class="FontName">import javax.jms.Message;</span><br class="calibre10"/><span class="FontName">import javax.jms.Session;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.jms.support.converter.MessageConversionException;</span><br class="calibre10"/><span class="FontName">import org.springframework.jms.support.converter.MessageConverter;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class MailMessageConverter implements MessageConverter {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Object fromMessage(Message message) throws JMSException,</span><br class="calibre10"/>            <span class="FontName">MessageConversionException {</span><br class="calibre10"/>        <span class="FontName">MapMessage mapMessage = (MapMessage) message;</span><br class="calibre10"/>        <span class="FontName">Mail mail = new Mail();</span><br class="calibre10"/>        <span class="FontName">mail.setMailId(mapMessage.getString("mailId"));</span><br class="calibre10"/>        <span class="FontName">mail.setCountry(mapMessage.getString("country"));</span><br class="calibre10"/>        <span class="FontName">mail.setWeight(mapMessage.getDouble("weight"));</span><br class="calibre10"/>        <span class="FontName">return mail;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Message toMessage(Object object, Session session) throws JMSException,</span><br class="calibre10"/>            <span class="FontName">MessageConversionException {</span><br class="calibre10"/>        <span class="FontName">Mail mail = (Mail) object;</span><br class="calibre10"/>        <span class="FontName">MapMessage message = session.createMapMessage();</span><br class="calibre10"/>        <span class="FontName">message.setString("mailId", mail.getMailId());</span><br class="calibre10"/>        <span class="FontName">message.setString("country", mail.getCountry());</span><br class="calibre10"/>        <span class="FontName">message.setDouble("weight", mail.getWeight());</span><br class="calibre10"/>        <span class="FontName">return message;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">To apply this message converter, you have to declare it in both bean configuration files and inject it into the JMS template.</p>
<pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="mailMessageConverter"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.post.MailMessageConverter" /&gt;</span>  <br class="calibre10"/>    <span class="FontName">&lt;bean id="jmsTemplate"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jms.core.JmsTemplate"&gt;</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">&lt;property name="messageConverter" ref="mailMessageConverter" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">Of course this can be expressed in Java configuration.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class BackOfficeConfiguration {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public JmsTemplate jmsTemplate() {</span><br class="calibre10"/>        <span class="FontName">JmsTemplate jmsTemplate = new JmsTemplate();</span><br class="calibre10"/>        <b class="calibre4">jmsTemplate.setMessageConverter(mailMessageConverter());</b><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">return jmsTemplate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public MailMessageConverter mailMessageConverter() {</span><br class="calibre10"/>        <span class="FontName">return new MailMessageConverter();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">When you set a message converter for a JMS template explicitly, it will override the default <span class="FontName">SimpleMessageConverter</span>. Now, you can call the JMS template’s <span class="FontName">convertAndSend()</span> and <span class="FontName">receiveAndConvert()</span> methods to send and receive mail objects.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class FrontDeskImpl extends JmsGatewaySupport implements FrontDesk {</span><br class="calibre10"/>    <span class="FontName">public void sendMail(Mail mail) {</span><br class="calibre10"/>        <span class="FontName">getJmsTemplate().convertAndSend(mail);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class BackOfficeImpl extends JmsGatewaySupport implements BackOffice {</span><br class="calibre10"/>    <span class="FontName">public Mail receiveMail() {</span><br class="calibre10"/>        <span class="FontName">return (Mail) getJmsTemplate().receiveAndConvert();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec13" class="Heading">15-3. Manage JMS Transactions<a id="cXXX.1117" class="calibre6"></a></p>
<p id="Sec14" class="Heading1">Problem</p>
<p class="noindent">You want to participate in transactions with JMS so that the receipt and sending of messages are transactional.</p>
<p id="Sec15" class="Heading1">Approach</p>
<p class="noindent">You can use the same transactions strategy as you would for any Spring component. Leverage Spring’s <span class="FontName">TransactionManager</span> implementations as needed and wire the behavior into beans.</p>
<p id="Sec16" class="Heading1">Solution</p>
<p class="noindent">When producing or consuming multiple JMS messages in a single method, if an error occurs in the middle, the JMS messages produced or consumed at the destination may be left in an inconsistent state. You have to surround the method with a transaction to avoid this problem.</p>
<p class="indent">In Spring, JMS transaction management is consistent with other data access strategies. For example, you can annotate the methods that require transaction management with the <span class="FontName">@Transactional</span> annotation.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.jms.core.support.JmsGatewaySupport;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class FrontDeskImpl extends JmsGatewaySupport implements FrontDesk {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional</span><br class="calibre10"/>    <span class="FontName">public void sendMail(Mail mail) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.jms.core.support.JmsGatewaySupport;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class BackOfficeImpl extends JmsGatewaySupport implements BackOffice {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional</span><br class="calibre10"/>    <span class="FontName">public Mail receiveMail() {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Then, in both bean configuration files, you add the <span class="FontName">&lt;tx:annotation-driven /&gt;</span> element (for Java based configuration add the <span class="FontName">@EnableTransactionManagement</span> annotation) and declare a transaction manager. The corresponding transaction manager for local JMS transactions is <span class="FontName">JmsTransactionManager</span>, which requires a reference to the JMS connection factory.</p>
<pre class="calibre11"><span class="FontName">&lt;beans  xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:tx="</span><span class="FontName"><a href="http://www.springframework.org/schema/tx" class="calibre5">http://www.springframework.org/schema/tx</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans.xsd</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/tx" class="calibre5">http://www.springframework.org/schema/tx</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/tx/spring-tx.xsd" class="calibre5">http://www.springframework.org/schema/tx/spring-tx.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;tx:annotation-driven /&gt;</span>  <br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="transactionManager"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jms.connection.JmsTransactionManager"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="connectionFactory"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;ref bean="connectionFactory" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">In the situation where one is using Java based configuration use the <span class="FontName">@EnableTransactionManagement</span> annotation and add the <span class="FontName">JmsTransactionManager</span> as a <span class="FontName">@Bean</span> annotated method.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post.config;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jms.connection.JmsTransactionManager;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.EnableTransactionManagement;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.jms.ConnectionFactory;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><b class="calibre4">@EnableTransactionManagement</b><br class="calibre10"/><span class="FontName">public class BackOfficeConfiguration {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public ConnectionFactory connectionFactory() { ... }</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Bean</b><br class="calibre10"/>    <b class="calibre4">public PlatformTransactionManager transactionManager() {</b><br class="calibre10"/>        <b class="calibre4">return new JmsTransactionManager(connectionFactory());</b><br class="calibre10"/>    <b class="calibre4">}</b><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you require transaction management across multiple resources, such as a data source and an ORM resource factory, or if you need distributed transaction management, you have to configure JTA transaction in your app server and use <span class="FontName">JtaTransactionManager</span>. Note that for multiple resource transactions support, the JMS connection factory must be XA compliant (i.e., it must support distributed transactions).</p>
<p id="Sec17" class="Heading">15-4. Create Message-Driven POJOs in Spring</p>
<p id="Sec18" class="Heading1">Problem</p>
<p class="noindent">When you call the <span class="FontName">receive()</span> method on a JMS message consumer to receive a message, the calling thread is blocked until a message is available. The thread can do nothing but wait. This type of message reception is called synchronous reception<a id="cXXX.1118" class="calibre5"></a>, because an application must wait for the message to arrive before it can finish its work.</p>
<p class="indent">You can create a message-driven POJO (MDP)<a id="cXXX.1119" class="calibre5"></a> to support asynchronous reception of JMS messages. A MDP is decorated with the <span class="FontName">@MessageDriven</span> annotation.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  A message driven POJO or MDP in the context of this recipe refers to a POJO that can listen for JMS messages without any particular run-time requirements. It does not refer to message driven beans (MDBs) aligned to the EJB specification that require an EJB container.</p></div>
<p id="Sec19" class="Heading1">Solution</p>
<p class="noindent">Spring allows beans declared in its IoC container to listen for JMS messages in the same way as MDBs which are based on the EJB spec. Because Spring adds message-listening capabilities to POJOs, they are called message-driven POJOs (MDPs).</p>
<p id="Sec20" class="Heading1">How It Works</p>
<p class="noindent">Suppose you want to add an electronic board to the post office’s back office to display mail information in real time as it arrives from the front desk. As the front desk sends a JMS message along with mail, the back office subsystem can listen for these messages and display them on the electronic board. For better system performance, you should apply the asynchronous JMS reception approach to avoid blocking the thread that receives these JMS messages.</p>
<p id="Sec21" class="Heading2">Listen for JMS Messages with Message Listeners<a id="cXXX.1120" class="calibre6"></a></p>
<p class="noindent">First, you create a message listener to listen for JMS messages. The message listener provides an alternative to the approach taken in <span class="FontName">BackOfficeImpl</span> in previous recipes with the <span class="FontName">JMSTemplate</span>. A listener can also consume messages from a broker. For example, the following <span class="FontName">MailListener</span> listens for JMS messages that contain mail information:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.jms.JMSException;</span><br class="calibre10"/><span class="FontName">import javax.jms.MapMessage;</span><br class="calibre10"/><span class="FontName">import javax.jms.Message;</span><br class="calibre10"/><span class="FontName">import javax.jms.MessageListener;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.jms.support.JmsUtils;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class MailListener implements MessageListener {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void onMessage(Message message) {</span><br class="calibre10"/>        <span class="FontName">MapMessage mapMessage = (MapMessage) message;</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">Mail mail = new Mail();</span><br class="calibre10"/>            <span class="FontName">mail.setMailId(mapMessage.getString("mailId"));</span><br class="calibre10"/>            <span class="FontName">mail.setCountry(mapMessage.getString("country"));</span><br class="calibre10"/>            <span class="FontName">mail.setWeight(mapMessage.getDouble("weight"));</span><br class="calibre10"/>            <span class="FontName">displayMail(mail);</span><br class="calibre10"/>        <span class="FontName">} catch (JMSException e) {</span><br class="calibre10"/>            <span class="FontName">throw JmsUtils.convertJmsAccessException(e);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private void displayMail(Mail mail) {</span><br class="calibre10"/>        <span class="FontName">System.out.println("Mail #" + mail.getMailId() + " received");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">A message listener must implement the <span class="FontName">javax.jms.MessageListener</span> interface. When a JMS message arrives, the <span class="FontName">onMessage()</span> method will be called with the message as the method argument. In this sample, you simply display the mail information to the console. Note that when extracting message information from a <span class="FontName">MapMessage</span> object, you need to handle the JMS API’s <span class="FontName">JMSException</span>. You can make a call to <span class="FontName">JmsUtils.convertJmsAccessException()</span> to convert it into Spring’s runtime exception <span class="FontName">JmsException</span>.</p>
<p class="indent">Next, you have to configure this listener in the back office’s bean configuration file. Declaring this listener alone is not enough to listen for JMS messages. You need a message listener container to monitor JMS messages at a message destination and trigger your message listener on message arrival.</p>
<pre class="calibre11"><span class="FontName">&lt;beans  xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="connectionFactory"</span><br class="calibre10"/>        <span class="FontName">class="org.apache.activemq.ActiveMQConnectionFactory"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="mailListener"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.post.MailListener" /&gt;</span>  <br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jms.listener.SimpleMessageListenerContainer"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="connectionFactory" ref="connectionFactory" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="destinationName" value="mail.queue" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="messageListener" ref="mailListener" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">Spring provides several types of message listener containers for you to choose from in the <span class="FontName">org.springframework.jms.listener</span> package, of which <span class="FontName">SimpleMessageListenerContainer</span> and <span class="FontName">DefaultMessageListenerContainer</span> are the most commonly used. <span class="FontName">SimpleMessageListenerContainer</span> is the simplest one that doesn’t support transactions. If you have a transaction requirement in receiving messages, you have to use <span class="FontName">DefaultMessageListenerContainer</span>.</p>
<p class="indent">Now, you can start the message listener. Since we won’t need to invoke a bean to trigger message consumption -- the listener will do it for us -- the following main class which only starts the Spring IoC container is enough:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class BackOfficeMain {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">new GenericXmlApplicationContext("beans-back.xml");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">When you start this BackOffice application it will listen for messages on the message broker (i.e., ActiveMQ). As soon as the FrontDesk application sends a message to the broker, the BackOffice application will react and display the message to the console.</p>
<p class="indent">You can use Java based configuration to configure a <i class="calibre8">SimpleMessageListenerContainer</i> it looks quite similar to the xml based version:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.post.MailListener;</span><br class="calibre10"/><span class="FontName">import org.apache.activemq.ActiveMQConnectionFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.jms.listener.SimpleMessageListenerContainer;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.jms.ConnectionFactory;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class BackOfficeConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public ConnectionFactory connectionFactory() { ... }</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public MailListener mailListener() {</span><br class="calibre10"/>        <span class="FontName">return new MailListener();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public Object container() {</span><br class="calibre10"/>        <span class="FontName">SimpleMessageListenerContainer smlc = new SimpleMessageListenerContainer();</span><br class="calibre10"/>        <span class="FontName">smlc.setConnectionFactory(connectionFactory());</span><br class="calibre10"/>        <span class="FontName">smlc.setDestinationName("mail.queue");</span><br class="calibre10"/>        <span class="FontName">smlc.setMessageListener(mailListener());</span><br class="calibre10"/>        <span class="FontName">return smlc;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec22" class="Heading2">Listen for JMS Messages with POJOs</p>
<p class="noindent">While a listener that implements the <span class="FontName">MessageListener</span> interface can listen for messages, so can an arbitrary bean declared in the Spring IoC container. Doing so means that beans are decoupled from the Spring framework interfaces as well as the JMS <span class="FontName">MessageListener</span> interface. For a method of this bean to be triggered on message arrival, it must accept one of the following types as its sole method argument:</p>
<ul class="bulleted1"><li class="calibre17">Raw JMS message type: For <span class="FontName">TextMessage</span>, <span class="FontName">MapMessage</span>, <span class="FontName">BytesMessage</span>, and <span class="FontName">ObjectMessage</span></li>
<li class="calibre17"><span class="FontName">String</span>: For <span class="FontName">TextMessage</span> only</li>
<li class="calibre17"><span class="FontName">Map</span>: For <span class="FontName">MapMessage</span> only</li>
<li class="calibre17"><span class="FontName">byte[]</span>: For <span class="FontName">BytesMessage</span> only</li>
<li class="calibre17"><span class="FontName">Serializable</span>: For <span class="FontName">ObjectMessage</span> only</li></ul>
<p class="indent">For example, to listen for <span class="FontName">MapMessage</span>, you declare a method that accepts a map as its argument. This listener no longer needs to implement the <span class="FontName">MessageListener</span> interface.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class MailListener {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void displayMail(Map map) {</span><br class="calibre10"/>        <span class="FontName">Mail mail = new Mail();</span><br class="calibre10"/>        <span class="FontName">mail.setMailId((String) map.get("mailId"));</span><br class="calibre10"/>        <span class="FontName">mail.setCountry((String) map.get("country"));</span><br class="calibre10"/>        <span class="FontName">mail.setWeight((Double) map.get("weight"));</span><br class="calibre10"/>        <span class="FontName">System.out.println("Mail #" + mail.getMailId() + " received");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">A POJO is registered to a listener container through a <span class="FontName">MessageListenerAdapter</span> instance. This adapter implements the <span class="FontName">MessageListener</span> interface and will delegate message handling to the target bean’s method via reflection.</p>
<pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="mailListener"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.post.MailListener" /&gt;</span>  <br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="mailListenerAdapter"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="delegate" ref="mailListener" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="defaultListenerMethod" value="displayMail" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jms.listener.SimpleMessageListenerContainer"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="connectionFactory" ref="connectionFactory" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="destinationName" value="mail.queue" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="messageListener" ref="mailListenerAdapter" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">You have to set the <span class="FontName">delegate</span> property of <span class="FontName">MessageListenerAdapter</span> to your target bean. By default, this adapter will call the method whose name is <span class="FontName">handleMessage</span> on that bean. If you want to call another method, you can specify it in the <span class="FontName">defaultListenerMethod</span> property. Finally, notice that you have to register the listener adapter, not the target bean, with the listener container.</p>
<p id="Sec23" class="Heading2">Convert JMS Messages<a id="cXXX.1121" class="calibre6"></a></p>
<p class="noindent">You can also create a message converter for converting mail objects from JMS messages that contain mail information. Because message listeners receive messages only, the method <span class="FontName">toMessage()</span> will not be called, so you can simply return <span class="FontName">null</span> for it. However, if you use this message converter for sending messages too, you have to implement this method. The following example reprints the <span class="FontName">MailMessageConvertor</span> class written earlier:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.jms.JMSException;</span><br class="calibre10"/><span class="FontName">import javax.jms.MapMessage;</span><br class="calibre10"/><span class="FontName">import javax.jms.Message;</span><br class="calibre10"/><span class="FontName">import javax.jms.Session;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.jms.support.converter.MessageConversionException;</span><br class="calibre10"/><span class="FontName">import org.springframework.jms.support.converter.MessageConverter;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class MailMessageConverter implements MessageConverter {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Object fromMessage(Message message) throws JMSException,</span><br class="calibre10"/>            <span class="FontName">MessageConversionException {</span><br class="calibre10"/>        <span class="FontName">MapMessage mapMessage = (MapMessage) message;</span><br class="calibre10"/>        <span class="FontName">Mail mail = new Mail();</span><br class="calibre10"/>        <span class="FontName">mail.setMailId(mapMessage.getString("mailId"));</span><br class="calibre10"/>        <span class="FontName">mail.setCountry(mapMessage.getString("country"));</span><br class="calibre10"/>        <span class="FontName">mail.setWeight(mapMessage.getDouble("weight"));</span><br class="calibre10"/>        <span class="FontName">return mail;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Message toMessage(Object object, Session session) throws JMSException,</span><br class="calibre10"/>            <span class="FontName">MessageConversionException {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">A message converter should be applied to a listener adapter for it to convert messages into objects before calling your POJO’s methods.</p>
<pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="mailMessageConverter"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.post.MailMessageConverter" /&gt;</span>  <br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="mailListenerAdapter"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="delegate" ref="mailListener" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="defaultListenerMethod" value="displayMail" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="messageConverter" ref="mailMessageConverter" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">With this message converter, the listener method of your POJO can accept a mail object as the method argument.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class MailListener {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void displayMail(Mail mail) {</span><br class="calibre10"/>        <span class="FontName">System.out.println("Mail #" + mail.getMailId() + " received");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>When using Java based configuration the configuration looks like the following:<br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.post.config;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.post.MailListener;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.post.MailMessageConverter;</span><br class="calibre10"/><span class="FontName">import org.springframework.jms.listener.adapter.MessageListenerAdapter;</span><br class="calibre10"/><span class="FontName">import org.springframework.jms.support.converter.MessageConverter;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class BackOfficeConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public ConnectionFactory connectionFactory() { ... }</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public MailListener mailListener() {</span><br class="calibre10"/>        <span class="FontName">return new MailListener();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public Object container() {</span><br class="calibre10"/>        <span class="FontName">SimpleMessageListenerContainer smlc = new SimpleMessageListenerContainer();</span><br class="calibre10"/>        <span class="FontName">smlc.setConnectionFactory(connectionFactory());</span><br class="calibre10"/>        <span class="FontName">smlc.setDestinationName("mail.queue");</span><br class="calibre10"/>        <span class="FontName">smlc.setMessageListener(mailListenerAdapter());</span><br class="calibre10"/>        <span class="FontName">return smlc;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public MessageConverter mailMessageConverter() {</span><br class="calibre10"/>        <span class="FontName">return new MailMessageConverter();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public MessageListenerAdapter mailListenerAdapter() {</span><br class="calibre10"/>        <span class="FontName">MessageListenerAdapter mailListenerAdapter = new MessageListenerAdapter();</span><br class="calibre10"/>        <span class="FontName">mailListenerAdapter.setDelegate(mailListener());</span><br class="calibre10"/>        <span class="FontName">mailListenerAdapter.setDefaultListenerMethod("displayMail");</span><br class="calibre10"/>        <span class="FontName">mailListenerAdapter.setMessageConverter(mailMessageConverter());</span><br class="calibre10"/>        <span class="FontName">return mailListenerAdapter;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec24" class="Heading2">Manage JMS Transactions<a id="cXXX.1122" class="calibre6"></a></p>
<p class="noindent">As mentioned before, <span class="FontName">SimpleMessageListenerContainer</span> doesn’t support transactions. So, if you need transaction management for your message listener method, you have to use <span class="FontName">DefaultMessageListenerContainer</span> instead. For local JMS transactions, you can simply enable its <span class="FontName">sessionTransacted</span> property, and your listener method will run within a local JMS transaction (as opposed to XA transactions).</p>
<pre class="calibre11"><span class="FontName">&lt;bean</span><br class="calibre10"/>    <span class="FontName">class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="connectionFactory" ref="connectionFactory" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="destinationName" value="mail.queue" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="messageListener" ref="mailListenerAdapter" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="sessionTransacted" value="true" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre>
<p class="indent">The equivalent in Java based configuration:</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public DefaultMessageListenerContainer container() {</span><br class="calibre10"/>    <span class="FontName">DefaultMessageListenerContainer dmlc = new DefaultMessageListenerContainer();</span><br class="calibre10"/>    <span class="FontName">dmlc.setConnectionFactory(connectionFactory());</span><br class="calibre10"/>    <span class="FontName">dmlc.setDestinationName("mail.queue");</span><br class="calibre10"/>    <span class="FontName">dmlc.setMessageListener(mailListenerAdapter());</span><br class="calibre10"/>    <b class="calibre4">dmlc.setSessionTransacted(true);</b><br class="calibre10"/>    <span class="FontName">return dmlc;</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">However, if you want your listener to participate in a JTA transaction, you need to declare a <span class="FontName">JtaTransactionManager</span> instance and inject it into your listener container.</p>
<p id="Sec25" class="Heading2">Use Spring’s JMS Schema</p>
<p class="noindent">Spring offers a JMS schema to simplify the JMS listener configurations. You must add the <span class="FontName">jms</span> schema definition to the <span class="FontName">&lt;beans&gt;</span> root element to achieve this.</p>
<pre class="calibre11"><span class="FontName">&lt;beans  xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:jms="</span><span class="FontName"><a href="http://www.springframework.org/schema/jms" class="calibre5">http://www.springframework.org/schema/jms</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.2.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/jms" class="calibre5">http://www.springframework.org/schema/jms</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/jms/spring-jms-3.2.xsd" class="calibre5">http://www.springframework.org/schema/jms/spring-jms-3.2.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="connectionFactory"</span><br class="calibre10"/>        <span class="FontName">class="org.apache.activemq.ActiveMQConnectionFactory"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="transactionManager"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jms.connection.JmsTransactionManager"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="connectionFactory"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;ref bean="connectionFactory" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="mailMessageConverter"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.post.MailMessageConverter" /&gt;</span>  <br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="mailListener"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.post.MailListener" /&gt;</span>  <br class="calibre10"/>    <span class="FontName">&lt;jms:listener-container</span><br class="calibre10"/>        <span class="FontName">connection-factory="connectionFactory"</span><br class="calibre10"/>        <span class="FontName">transaction-manager="transactionManager"</span><br class="calibre10"/>        <span class="FontName">message-converter="mailMessageConverter"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;jms:listener</span><br class="calibre10"/>            <span class="FontName">destination="mail.queue"</span><br class="calibre10"/>            <span class="FontName">ref="mailListener" method="displayMail" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/jms:listener-container&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">Note, you don’t need to specify the <span class="FontName">connection-factory</span> attribute for a listener container explicitly if your JMS connection factory’s name is <span class="FontName">connectionFactory</span>, in which case it’s located by default.</p>
<p id="Sec26" class="Heading">15-5. Cache and pool<a id="cXXX.1123" class="calibre6"></a> JMS connections</p>
<p id="Sec27" class="Heading1">Problem</p>
<p class="noindent">Throughout this chapter, for the sake of simplicity, we’ve explored Spring’s JMS support with a very simple instance of <span class="FontName">org.apache.activemq.ActiveMQConnectionFactory</span> as the connection factory. This isn’t the best choice in practice. As with all things, there are performance considerations.</p>
<p class="indent">The crux of the issue it is that <span class="FontName">JmsTemplate</span> closes sessions and consumers on each invocation. This means that it tears down all those objects and restores frees the memory. This is “safe,” but not performant, as some of the objects created—like Consumers—are meant to be long lived. This behavior stems from the use of the <span class="FontName">JmsTemplate</span> in application server environments, where typically the application server’s Connection Factory is used, and it, internally, provides connection pooling. In this environment, restoring all the objects simply returns it to the pool, which is the desirable behavior.</p>
<p id="Sec28" class="Heading1">Solution</p>
<p class="noindent">There’s no “one size fits all” solution to this. You need to weigh the qualities you’re looking for and react appropriately.</p>
<p id="Sec29" class="Heading1">How It Works</p>
<p class="noindent">Generally, you want a connection factory that provides pooling and caching of some sort when publishing messages using <span class="FontName">JmsTemplate</span>. The first place to look for a pooled connection factory might be your application server. It may very well provide one by default.</p>
<p class="indent">In the examples in this chapter, we use ActiveMQ in a stand-alone configuration. ActiveMQ, like many vendors, provides a pooled connection factory class alternative (ActiveMQ provides two, actually: one for use consuming messages with a JCA connector and another one for use outside of a JCA container), we can use these instead to handle caching producers and sessions when sending messages. The following configuration pools a connection factory in a stand-alone configuration. It’s a drop-in replacement for the previous examples when publishing messages.</p>
<pre class="calibre11"><span class="FontName">&lt;bean id="connectionFactory" class="org.apache.activemq.pool.PooledConnectionFactory"</span> <br class="calibre10"/>     <span class="FontName">destroy-method="stop"&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;property name="connectionFactory"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt;</span><br class="calibre10"/>      <span class="FontName">&lt;property name="brokerURL"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;value&gt;tcp://localhost:61616&lt;/value&gt;</span><br class="calibre10"/>      <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span></pre>
<p class="indent">The equivalent in Java based configuration:</p>
<pre class="calibre11"><span class="FontName">@Bean(destroyMethod = "stop")</span><br class="calibre10"/><span class="FontName">public ConnectionFactory connectionFactory() {</span><br class="calibre10"/>    <span class="FontName">ActiveMQConnectionFactory connectionFactoryToUse =</span> <br class="calibre10"/>        <span class="FontName">new ActiveMQConnectionFactory("tcp://localhost:61616");</span><br class="calibre10"/>    <b class="calibre4">PooledConnectionFactory connectionFactory = new PooledConnectionFactory();</b><br class="calibre10"/>    <span class="FontName">connectionFactory.setConnectionFactory(connectionFactoryToUse);</span><br class="calibre10"/>    <span class="FontName">return connectionFactory;</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you are receiving messages, you could still stand some more efficiency, because the <span class="FontName">JmsTemplate</span> constructs a new <span class="FontName">MessageConsumer</span> each time as well. In this situation, you have a few alternatives: use Spring’s various <span class="FontName">*MessageListenerContainer</span> implementations mechanism (MDPs), because it caches consumers correctly, or use Spring’s <span class="FontName">ConnectionFactory</span> implementations. The first implementation, <span class="FontName">org.springframework.jms.connection.SingleConnectionFactory</span>, returns the same underlying JMS connection each time (which is thread-safe according to the JMS API) and ignores calls to the <span class="FontName">close()</span> method. Generally, this implementation works well with the JMS 1.1 API. A newer alternative is the <span class="FontName">org.springframework.jms.connection.CachingConnectionFactory</span>. First, the obvious advantage is that it provides the ability to cache multiple instances. And second, it caches sessions, <span class="FontName">MessageProducer</span>s, and <span class="FontName">MessageConsumer</span>s.</p>
<p id="Sec30" class="Heading">15-6 Send and Receive AMQP Messages<a id="cXXX.1124" class="calibre6"></a> with Spring</p>
<p id="Sec31" class="Heading1">Problem</p>
<p class="noindent">You want to use RabbitMQ to send and receive messages.</p>
<p id="Sec32" class="Heading1">Solution</p>
<p class="noindent">The Spring AMQP project (<span class="FontName"><a href="http://projects.spring.io/spring-amqp/" class="calibre5">http://projects.spring.io/spring-amqp/</a></span>) which provides easy access and use of the AMQP protocol. It has support similar to that of Spring JMS. It comes with a <span class="FontName">RabbitTemplate</span> which provides basic send and receive options, it also comes with a <span class="FontName">MessageListenerContainer</span> option which mimics Spring JMS.</p>
<p id="Sec33" class="Heading1">How It Works</p>
<p class="noindent">First look at how we can send a message using the <span class="FontName">RabbitTemplate</span>, to get access to the <span class="FontName">RabbitTemplate</span><a id="cXXX.1125" class="calibre5"></a> it is the simplest to extend <span class="FontName">RabbitGatewaySupport</span>. Below is the <span class="FontName">FrontDeskImpl</span> which uses the RabbitTemplate.</p>
<p id="Sec34" class="Heading2">Send Messages with Spring’s template Support<a id="cXXX.2082" class="calibre6"></a><a id="cXXX.1126" class="calibre6"></a></p>
<p class="noindent">The <span class="FontName">FrontDeskImpl</span> class extends <span class="FontName">RabbitGatewaySupport</span>, this class configures a <span class="FontName">RabbitTemplate</span> based on the configuration we pass in. To send a message we use the <span class="FontName">getRabbitTemplate</span> method to get the template and next to convert and send the message, for this you use the <span class="FontName">convertAndSend</span> method. This method will first use a <span class="FontName">MessageConverter</span> to convert the message into JSON and then send it to the queue we have configured.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.amqp.rabbit.core.support.RabbitGatewaySupport;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class FrontDeskImpl extends</span> <b class="calibre4">RabbitGatewaySupport</b> <span class="FontName">implements FrontDesk {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void sendMail(final Mail mail) {</span><br class="calibre10"/>        <span class="FontName">getRabbitTemplate().convertAndSend(mail);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Let’s take a look at the configuration:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.post.FrontDeskImpl;</span><br class="calibre10"/><span class="FontName">import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.amqp.rabbit.connection.ConnectionFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br class="calibre10"/><span class="FontName">import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class FrontOfficeConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public ConnectionFactory connectionFactory() {</span><br class="calibre10"/>        <span class="FontName">CachingConnectionFactory connectionFactory = new CachingConnectionFactory("127.0.0.1");</span><br class="calibre10"/>        <span class="FontName">connectionFactory.setUsername("guest");</span><br class="calibre10"/>        <span class="FontName">connectionFactory.setPassword("guest");</span><br class="calibre10"/>        <span class="FontName">connectionFactory.setPort(5672);</span><br class="calibre10"/>        <span class="FontName">return connectionFactory;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public RabbitTemplate rabbitTemplate() {</span><br class="calibre10"/>        <span class="FontName">RabbitTemplate rabbitTemplate = new RabbitTemplate();</span><br class="calibre10"/>        <span class="FontName">rabbitTemplate.setConnectionFactory(connectionFactory());</span><br class="calibre10"/>        <span class="FontName">rabbitTemplate.setMessageConverter(new Jackson2JsonMessageConverter());</span><br class="calibre10"/>        <span class="FontName">rabbitTemplate.setRoutingKey("mail.queue");</span><br class="calibre10"/>        <span class="FontName">return rabbitTemplate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public FrontDeskImpl frontDesk() {</span><br class="calibre10"/>        <span class="FontName">FrontDeskImpl frontDesk = new FrontDeskImpl();</span><br class="calibre10"/>        <span class="FontName">frontDesk.setRabbitTemplate(rabbitTemplate());</span><br class="calibre10"/>        <span class="FontName">return frontDesk;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The configuration is quite similar to the JMS configuration. We need a ConnectionFactory to connect to our RabbitMQ broker. We use a <span class="FontName">CachingConnectionFactory</span> so that we can reuse our connections. Next there is the <span class="FontName">RabbitTemplate</span> which uses the connection and has a <span class="FontName">MessageConverter</span> to convert the message. The message is being converted into JSON using the Jackson2 library hence the configuration of the <span class="FontName">Jackson2JsonMessageConverter</span>.</p>
<p class="indent">Finally the <span class="FontName">RabbitTemplate</span> is passed into the <span class="FontName">FrontDeskImpl</span> so that it is available for usage.</p>
<p class="indent">Before you can send and receive AMQP messages, you need to install a AMQP message broker. For simplicity’s sake, we have chosen RabbitMQ (<span class="FontName"><a href="http://www.rabbitmq.org/" class="calibre5">http://www.rabbitmq.org/</a></span>) as our broker, which is very easy to install and configure. RabbitMQ is an open source broker that fully supports AMQP 0.9.1.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  You can download RabbitMQ (e.g., v3.3.3) from the RabbitMQ web site and extract it to a directory of your choice to complete the installation.</p></div>
<p class="indent">When your AMQP broker is setup you can use the following main class to run the frontdesk application.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ConfigurableApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class FrontDeskMain {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) throws Exception {</span><br class="calibre10"/>        <span class="FontName">ConfigurableApplicationContext context =</span><br class="calibre10"/>            <span class="FontName">new AnnotationConfigApplicationContext("com.apress.springrecipes.post.config");</span><br class="calibre10"/>        <span class="FontName">context.registerShutdownHook();</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">FrontDesk frontDesk = context.getBean(FrontDesk.class);</span><br class="calibre10"/>        <span class="FontName">frontDesk.sendMail(new Mail("1234", "US", 1.5));</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">System.in.read();</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec35" class="Heading2">Listen for AMQP Messages with Message Listeners<a id="cXXX.1127" class="calibre6"></a></p>
<p class="noindent">Spring AMQP supports <span class="FontName">MessageListenerContainer</span>s for retrieving messages in the same way as it Spring JMS does for JMS. Spring AMQP has a <span class="FontName">SimpleMessageListenerContainer</span> which can be used to retrieve messages. To be able to receive messages we need a <span class="FontName">MessageListener</span> which we can pass into <span class="FontName">SimpleMessageListenerContainer</span>, this listener will be invoked for each incoming message.</p>
<p class="indent">Let’s take a look at the MessageListener which is used.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class MailListener {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void displayMail(Mail mail) {</span><br class="calibre10"/>        <span class="FontName">System.out.println("Mail #" + mail.getMailId() + " received");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The <span class="FontName">MailListener</span> is exactly the same as the one created in Recipe 15-4 for receiving JMS messages. The difference is in the configuration.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.post.MailListener;</span><br class="calibre10"/><b class="calibre4">import org.springframework.amqp.core.AmqpAdmin;</b><br class="calibre10"/><b class="calibre4">import org.springframework.amqp.core.Queue;</b><br class="calibre10"/><b class="calibre4">import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;</b><br class="calibre10"/><b class="calibre4">import org.springframework.amqp.rabbit.connection.ConnectionFactory;</b><br class="calibre10"/><b class="calibre4">import org.springframework.amqp.rabbit.core.RabbitAdmin;</b><br class="calibre10"/><b class="calibre4">import org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;</b><br class="calibre10"/><b class="calibre4">import org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter;</b><br class="calibre10"/><b class="calibre4">import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</b><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class BackOfficeConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public ConnectionFactory connectionFactory() {</span><br class="calibre10"/>        <span class="FontName">CachingConnectionFactory connectionFactory = new CachingConnectionFactory("127.0.0.1");</span><br class="calibre10"/>        <span class="FontName">connectionFactory.setUsername("guest");</span><br class="calibre10"/>        <span class="FontName">connectionFactory.setPassword("guest");</span><br class="calibre10"/>        <span class="FontName">connectionFactory.setPort(5672);</span><br class="calibre10"/>        <span class="FontName">return connectionFactory;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public AmqpAdmin amqpAdmin() {</span><br class="calibre10"/>        <span class="FontName">return new RabbitAdmin(connectionFactory());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public Queue mailQueue() {</span><br class="calibre10"/>        <span class="FontName">return new Queue("mail.queue");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public SimpleMessageListenerContainer messageListenerContainer() {</span><br class="calibre10"/>        <span class="FontName">SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();</span><br class="calibre10"/>        <span class="FontName">container.setConnectionFactory(connectionFactory());</span><br class="calibre10"/>        <span class="FontName">container.setMessageListener(mailListenerAdapter());</span><br class="calibre10"/>        <span class="FontName">container.setQueues(mailQueue());</span><br class="calibre10"/>        <span class="FontName">return container;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public MessageListenerAdapter mailListenerAdapter() {</span><br class="calibre10"/>        <span class="FontName">MessageListenerAdapter adapter = new MessageListenerAdapter();</span><br class="calibre10"/>        <span class="FontName">adapter.setDelegate(mailListener());</span><br class="calibre10"/>        <span class="FontName">adapter.setDefaultListenerMethod("displayMail");</span><br class="calibre10"/>        <span class="FontName">adapter.setMessageConverter(new Jackson2JsonMessageConverter());</span><br class="calibre10"/>        <span class="FontName">return adapter;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public MailListener mailListener() {</span><br class="calibre10"/>        <span class="FontName">return new MailListener();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The <span class="FontName">SimpleMessageListenerContainer</span> needs a <span class="FontName">ConnectionFactory</span> for this we are using the <span class="FontName">CachingConnectionFactory</span>. We also need to pass in the <span class="FontName">Queue</span> that is used to listen on. The <span class="FontName">MailListener</span> is invoked by a <span class="FontName">MessageListenerAdapter</span> which will invoke the <span class="FontName">displayMail</span> method after converting the incoming JSON message into a <span class="FontName">Mail</span> object using the <span class="FontName">Jackon2JsonMessageConverter</span>.</p>
<p class="indent">Finally there is the <span class="FontName">RabbitAdmin</span> bean this will auto register the configured queue(s) with our message broker.</p>
<p class="indent">To listen to messages create a class with a main method that only needs to construct the application context. The <span class="FontName">SimpleMessageListenerContainer</span> will be automatically started and starts to listen for messages.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.post;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.GenericXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class BackOfficeMain {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span> <br class="calibre10"/>            <span class="FontName">new AnnotationConfigApplicationContext("com.apress.springrecipes.post.config");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec36" class="Heading">Summary</p>
<p class="noindent">This chapter explored Spring’s support for JMS: how JMS fits in an architecture and how to use Spring to build message-oriented architectures. You learned how to both produce and consume messages using a message queue. You worked with Active MQ, a reliable open source message queue. You learned how to build message-driven POJOs<a id="cXXX.2110" class="calibre5"></a><a id="cXXX.2109" class="calibre5"></a> using a <span class="FontName">MessageListenerContainer</span>.</p>
<p class="indent">Finally you explored Spring AMQP to send messages using the AMQP protocol using the Spring AMQP project.</p>
<p class="indent">The next chapter will explore Spring Integration, which is an ESB-like framework for building application integration solutions, similar to Mule ESB and ServiceMix. You will be able to leverage the knowledge gained in this chapter to take your message-oriented applications to new heights with Spring integration.</p></div>
</body></html>
