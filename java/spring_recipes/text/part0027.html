<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Chapter 17 Spring Testing</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre"><p class="ChapterNumber"><a id="b9781430259084_17" class="calibre6"></a>CHAPTER 17</p>
<p class="Chapimage"><img src="../images/00008.jpeg" alt="image" class="calibre3"/></p>
<p class="ChapterTitle">Spring Testing</p>
<div class="calibre10"><p class="noindent">In this chapter<a id="cXXX.2225" class="calibre5"></a>, you will learn about basic techniques<a id="cXXX.1189" class="calibre5"></a> you can use to test Java applications, and the testing support features offered by the Spring framework. These features can make your testing tasks easier and lead you to better application design. In general, applications developed with the Spring framework and the dependency injection pattern are easy to test.</p>
<p class="indent">Testing is a key activity for ensuring quality in software development. There are many types of testing, including unit testing, integration testing, functional testing, system testing, performance testing, and acceptance testing. Spring’s testing support focuses on unit and integration testing, but it can also help with other types of testing. Testing can be performed either manually or automatically. However, since automated tests can be run repeatedly and continuously at different phases of a development process, they are highly recommended, especially in agile development processes. The Spring framework is an agile framework that fits these kinds of processes.</p>
<p class="indent">Many testing frameworks<a id="cXXX.1190" class="calibre5"></a> are available on the Java platform. Currently, JUnit and TestNG are the most popular. JUnit has a long history and a large user group in the Java community. TestNG is another popular Java testing framework. Compared to JUnit, TestNG offers additional powerful features such as test grouping, dependent test methods, and data-driven tests.</p>
<p class="indent">Springs testing support features have been offered by the Spring TestContext framework, which requires Java 1.5 or higher. This framework abstracts the underlying testing framework with the following concepts:</p>
<ul class="bulleted"><li class="calibre17"><i class="calibre8">Test context</i>:<a id="cXXX.1191" class="calibre5"></a> This encapsulates the context of a test’s execution, including the application context, test class, current test instance, current test method, and current test exception.</li>
<li class="calibre17"><i class="calibre8">Test context manager</i>: This manages a test context for<a id="cXXX.1192" class="calibre5"></a> a test and triggers test execution listeners at predefined test execution points, including when preparing a test instance, before executing a test method (before any framework-specific initialization methods), and after executing a test method (after any framework-specific cleanup methods).</li>
<li class="calibre17"><i class="calibre8">Test execution listener</i><a id="cXXX.1193" class="calibre5"></a>: This defines a listener interface; by implementing this, you can listen to test execution events. The TestContext framework provides several test execution listeners for common testing features, but you are free to create your own.</li></ul>
<p class="indent">Spring provides convenient TestContext support classes for JUnit 4 and TestNG, with particular test execution listeners preregistered. You can simply extend these support classes to use the TestContext framework without having to know much about the framework details.</p>
<p class="indent">After finishing this chapter, you will understand the basic concepts and techniques of testing and the popular Java testing frameworks JUnit and TestNG. You will also be able to create unit tests and integration tests<a id="cXXX.2254" class="calibre5"></a> using the Spring TestContext framework.</p>
<p id="Sec1" class="Heading">17-1. Creating Tests with JUnit and TestNG<a id="cXXX.2098" class="calibre6"></a><a id="cXXX.1194" class="calibre6"></a></p>
<p id="Sec2" class="Heading1">Problem</p>
<p class="noindent">You would like to create automated tests for your Java application<a id="cXXX.1195" class="calibre5"></a> so that they can be run repeatedly to ensure the correctness of your application.</p>
<p id="Sec3" class="Heading1">Solution<a id="cXXX.1196" class="calibre6"></a></p>
<p class="noindent">The most popular testing frameworks on the Java platform are JUnit and TestNG. JUnit 4 incorporates several major improvements over JUnit 3, which relies on the base class (i.e., <span class="FontName">TestCase</span>)<a id="cXXX.1197" class="calibre5"></a> and the method signature (i.e., methods whose names begin with <span class="FontName">test</span>) to identify test cases—an approach that lacks flexibility. JUnit 4 allows you to annotate your test methods with JUnit’s <span class="FontName">@Test</span> annotation, so an arbitrary public method can be run as a test case. TestNG is another powerful testing framework that makes use of annotations. It also provides a <span class="FontName">@Test</span> annotation<a id="cXXX.1198" class="calibre5"></a> type for you to identify test cases.</p>
<p id="Sec4" class="Heading1">How It Works</p>
<p class="noindent">Suppose you are going to develop a system for a bank. To ensure the system’s quality, you have to test every part of it. First, let’s consider an interest calculator, whose interface is defined as follows:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface InterestCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setRate(double rate);</span><br class="calibre10"/>    <span class="FontName">public double calculate(double amount, double year);</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Each interest calculator requires a fixed interest rate to be set. Now, you can implement this calculator with a simple interest formula:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SimpleInterestCalculator implements InterestCalculator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private double rate;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setRate(double rate) {</span><br class="calibre10"/>        <span class="FontName">this.rate = rate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double calculate(double amount, double year) {</span><br class="calibre10"/>        <span class="FontName">if (amount &lt; 0 || year &lt; 0) {</span><br class="calibre10"/>            <span class="FontName">throw new IllegalArgumentException("Amount or year must be positive");</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return amount * year * rate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Next, you will test this simple interest calculator with the popular testing frameworks JUnit and TestNG (version 5).</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Tip</b>  Usually, a test and its target class are located in the same package, but the source files of tests are stored in a separate directory (e.g., <span class="FontName">test</span>) from the source files of other classes (e.g., <span class="FontName">src</span>).</p></div>
<p id="Sec5" class="Heading2">Testing with JUnit 4<a id="cXXX.1199" class="calibre6"></a></p>
<p class="noindent">In JUnit 4, a class that contains test cases no longer needs to extend the <span class="FontName">TestCase</span> class. It can be an arbitrary class. A test case is simply a public method with the <span class="FontName">@Test</span> annotation. Similarly, you no longer need to override the <span class="FontName">setUp()</span> and <span class="FontName">tearDown()</span> methods<a id="cXXX.1200" class="calibre5"></a>, but rather annotate a public method with the <span class="FontName">@Before</span> or <span class="FontName">@After</span> annotation. You can also annotate a public static method with <span class="FontName">@BeforeClass</span> or <span class="FontName">@AfterClass</span><a id="cXXX.1201" class="calibre5"></a> to have it run once before or after all test cases in the class.</p>
<p class="indent">Since your class doesn’t extend <span class="FontName">TestCase</span><a id="cXXX.1202" class="calibre5"></a>, it doesn’t inherit the assert methods. So, you have to call the static assert methods declared in the <span class="FontName">org.junit.Assert</span> class directly. However, you can import all assert methods via a static import statement in Java 1.5. You can create the following JUnit 4 test cases to test your simple interest calculator.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To compile and run test cases created for JUnit 4, you have to include JUnit 4 on your CLASSPATH. If you are using Maven, add the following dependency to your project:</p>
<pre class="calibre19"><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br class="calibre2"/>   <span class="FontName1">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;4.11&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span></pre></div>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import static org.junit.Assert.*;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.junit.Before;</span><br class="calibre10"/><span class="FontName">import org.junit.Test;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SimpleInterestCalculatorJUnit4Tests {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private InterestCalculator interestCalculator;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Before</b><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">interestCalculator = new SimpleInterestCalculator();</span><br class="calibre10"/>        <span class="FontName">interestCalculator.setRate(0.05);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Test</b><br class="calibre10"/>    <span class="FontName">public void calculate() {</span><br class="calibre10"/>        <span class="FontName">double interest = interestCalculator.calculate(10000, 2);</span><br class="calibre10"/>        <span class="FontName">assertEquals(interest, 1000.0, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Test(expected = IllegalArgumentException.class)</b><br class="calibre10"/>    <span class="FontName">public void illegalCalculate() {</span><br class="calibre10"/>        <span class="FontName">interestCalculator.calculate(-10000, 2);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">JUnit 4 offers a powerful feature that allows you to expect an exception to be thrown in a test case. You can simply specify the exception type in the <span class="FontName">expected</span> attribute of the <span class="FontName">@Test</span> annotation.</p>
<p id="Sec6" class="Heading2">Testing with TestNG</p>
<p class="noindent">A TestNG test<a id="cXXX.1203" class="calibre5"></a> looks very similar to a JUnit 4 one, except that you have to use the classes and annotation types defined by the TestNG framework.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To compile and run test cases created for TestNG, you have to add TestNG to your CLASSPATH. If you are using Maven, add the following dependency to your project.</p>
<pre class="calibre19"><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.testng&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;testng&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;6.6.8&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span></pre></div>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import static org.testng.Assert.*;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.testng.annotations.BeforeMethod;</span><br class="calibre10"/><span class="FontName">import org.testng.annotations.Test;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SimpleInterestCalculatorTestNGTests {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private InterestCalculator interestCalculator;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@BeforeMethod</b><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">interestCalculator = new SimpleInterestCalculator();</span><br class="calibre10"/>        <span class="FontName">interestCalculator.setRate(0.05);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Test</b><br class="calibre10"/>    <span class="FontName">public void calculate() {</span><br class="calibre10"/>        <span class="FontName">double interest = interestCalculator.calculate(10000, 2);</span><br class="calibre10"/>        <span class="FontName">assertEquals(interest, 1000.0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Test(expectedExceptions = IllegalArgumentException.class)</b><br class="calibre10"/>    <span class="FontName">public void illegalCalculate() {</span><br class="calibre10"/>        <span class="FontName">interestCalculator.calculate(-10000, 2);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  If you are using Eclipse for development, you can download and install the TestNG Eclipse plug-in from <span class="FontName"><a href="http://testng.org/doc/eclipse.html" class="calibre5">http://testng.org/doc/eclipse.html</a></span> to run TestNG tests in Eclipse. Again, you will see a green bar if all your tests pass and a red bar otherwise.</p></div>
<p class="indent">One of the powerful features of TestNG is its built-in support for data-driven testing. TestNG cleanly separates test data from test logic so that you can run a test method multiple times for different data sets. In TestNG, test data sets are provided by data providers, which are methods with the <span class="FontName">@DataProvider</span> annotation.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import static org.testng.Assert.*;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.testng.annotations.BeforeMethod;</span><br class="calibre10"/><span class="FontName">import org.testng.annotations.DataProvider;</span><br class="calibre10"/><span class="FontName">import org.testng.annotations.Test;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class SimpleInterestCalculatorTestNGTests {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private InterestCalculator interestCalculator;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@BeforeMethod</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">interestCalculator = new SimpleInterestCalculator();</span><br class="calibre10"/>        <span class="FontName">interestCalculator.setRate(0.05);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@DataProvider(name = "legal")</b><br class="calibre10"/>    <span class="FontName">public Object[][] createLegalInterestParameters() {</span><br class="calibre10"/>        <span class="FontName">return new Object[][] { new Object</span><span class="FontName">[] { 10000, 2, 1000.0 } };</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@DataProvider(name = "illegal")</b><br class="calibre10"/>    <span class="FontName">public Object[][] createIllegalInterestParameters() {</span><br class="calibre10"/>        <span class="FontName">return new Object[][] {new Object[] { -10000, 2 },</span><br class="calibre10"/>                <span class="FontName">new Object[] { 10000, -2 }, new Object[] { -10000, -2 }};</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test(dataProvider = "legal")</span><br class="calibre10"/>    <span class="FontName">public void calculate(double amount, double year, double result) {</span><br class="calibre10"/>        <span class="FontName">double interest = interestCalculator.calculate(amount, year);</span><br class="calibre10"/>        <span class="FontName">assertEquals(interest, result);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test(</span><br class="calibre10"/>    <b class="calibre4">dataProvider = "illegal",</b><br class="calibre10"/>        <span class="FontName">expectedExceptions = IllegalArgumentException.class)</span><br class="calibre10"/>    <span class="FontName">public void illegalCalculate(double amount, double year) {</span><br class="calibre10"/>        <span class="FontName">interestCalculator.calculate(amount, year);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you run the preceding test with TestNG, the <span class="FontName">calculate()</span> method will be executed once, while the <span class="FontName">illegalCalculate()</span> method will be executed three times, as there are three data sets returned by the <span class="FontName">illegal</span> data provider.</p>
<p id="Sec7" class="Heading">17-2. Creating Unit Tests and Integration Tests<a id="cXXX.1204" class="calibre6"></a></p>
<p id="Sec8" class="Heading1">Problem</p>
<p class="noindent">A common testing technique is to test each module of your application in isolation and then test them in combination. You would like to apply this skill in testing your Java applications.</p>
<p id="Sec9" class="Heading1">Solution</p>
<p class="noindent"><i class="calibre8">Unit tests</i> are used to test a single programming unit. In object-oriented languages, a <i class="calibre8">unit</i> is usually a class or a method. The scope of a unit test is a single unit, but in the real world, most units won’t work in isolation. They often need to cooperate with others to complete their tasks. When testing a unit that depends on other units, a common technique you can apply is to simulate the unit’s dependencies with stubs and mock objects, both of which can reduce complexity of your unit tests caused by dependencies.</p>
<p class="indent">A <i class="calibre8">stub</i> is an object that simulates a dependent object with the minimum number of methods required for a test. The methods are implemented in a predetermined way, usually with hard-coded data. A stub also exposes methods for a test to verify the stub’s internal states. In contrast to a stub, a <i class="calibre8">mock object</i> usually knows how its methods are expected to be called in a test. The mock object<a id="cXXX.1205" class="calibre5"></a> then verifies the methods actually called against the expected ones. In Java, there are several libraries that can help create mock objects, including EasyMock and jMock. The main difference between a stub and a mock object is that a stub is usually used for <i class="calibre8">state verification</i><a id="cXXX.1206" class="calibre5"></a>, while a mock object is used for <i class="calibre8">behavior verification</i><a id="cXXX.1207" class="calibre5"></a>.</p>
<p class="indent"><i class="calibre8">Integration tests</i>, in contrast, are used to test several units in combination as a whole. They test if the integration and interaction between units are correct. Each of these units should already have been tested with unit tests, so integration testing is usually performed after unit testing.</p>
<p class="indent">Finally, note that applications developed using the principle of “separating interface from implementation” and the dependency injection pattern are easy to test, both for unit testing and integration testing. This is because that principle and pattern can reduce coupling between different units of your application.</p>
<p id="Sec10" class="Heading1">How It Works</p>
<p id="Sec11" class="Heading2">Creating Unit Tests for Isolated Classes<a id="cXXX.2256" class="calibre6"></a></p>
<p class="noindent">The core functions of your bank system should be designed around customer accounts. First, you create the following domain class, <span class="FontName">Accoun</span><a id="cXXX.1208" class="calibre5"></a><span class="FontName">t</span>, with a custom <span class="FontName">equals()</span><a id="cXXX.1209" class="calibre5"></a> method:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Account {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private String accountNo;</span><br class="calibre10"/>    <span class="FontName">private double balance;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Constructors, Getters and Setters</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public boolean equals(Object obj) {</span><br class="calibre10"/>        <span class="FontName">if (!(obj instanceof Account)) {</span><br class="calibre10"/>            <span class="FontName">return false;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">Account account = (Account) obj;</span><br class="calibre10"/>        <span class="FontName">return account.accountNo.equals(accountNo) &amp;&amp; account.balance == balance;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Next, you define the following DAO interface for persisting account objects in your bank system’s persistence layer:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface AccountDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void createAccount(Account account);</span><br class="calibre10"/>    <span class="FontName">public void updateAccount(Account account);</span><br class="calibre10"/>    <span class="FontName">public void removeAccount(Account account);</span><br class="calibre10"/>    <span class="FontName">public Account findAccount(String accountNo);</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">To demonstrate the unit testing concept, let’s implement this interface by using a map to store account objects. The <span class="FontName">AccountNotFoundException</span><a id="cXXX.1210" class="calibre5"></a> and <span class="FontName">DuplicateAccountException</span> classes are subclasses of <span class="FontName">RuntimeException</span><a id="cXXX.1211" class="calibre5"></a> that you should be able to create yourself.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class InMemoryAccountDao implements AccountDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Map&lt;String, Account&gt; accounts;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public InMemoryAccountDao() {</span><br class="calibre10"/>        <span class="FontName">accounts = Collections.synchronizedMap(new HashMap&lt;String, Account&gt;());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public boolean accountExists(String accountNo) {</span><br class="calibre10"/>        <span class="FontName">return accounts.containsKey(accountNo);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void createAccount(Account account) {</span><br class="calibre10"/>        <span class="FontName">if (accountExists(account.getAccountNo())) {</span><br class="calibre10"/>            <span class="FontName">throw new DuplicateAccountException();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">accounts.put(account.getAccountNo(), account);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void updateAccount(Account account) {</span><br class="calibre10"/>        <span class="FontName">if (!accountExists(account.getAccountNo())) {</span><br class="calibre10"/>            <span class="FontName">throw new AccountNotFoundException();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">accounts.put(account.getAccountNo(), account);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void removeAccount(Account account) {</span><br class="calibre10"/>        <span class="FontName">if (!accountExists(account.getAccountNo())) {</span><br class="calibre10"/>            <span class="FontName">throw new AccountNotFoundException();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">accounts.remove(account.getAccountNo());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Account findAccount(String accountNo) {</span><br class="calibre10"/>        <span class="FontName">Account account = accounts.get(accountNo);</span><br class="calibre10"/>        <span class="FontName">if (account == null) {</span><br class="calibre10"/>            <span class="FontName">throw new AccountNotFoundException();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return account;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Obviously, this simple DAO implementation<a id="cXXX.1212" class="calibre5"></a> doesn’t support transactions. However, to make it thread-safe, you can wrap the map storing accounts with a synchronized map so that it will be accessed serially.</p>
<p class="indent">Now, let’s create unit tests for this DAO implementation with JUnit 4. As this class doesn’t depend directly on other classes, it’s easy to test. To ensure that this class works properly for exceptional cases as well as normal cases, you should also create exceptional test cases for it. Typically, exceptional test cases expect an exception to be thrown.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import static org.junit.Assert.*;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.junit.Before;</span><br class="calibre10"/><span class="FontName">import org.junit.Test;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class InMemoryAccountDaoTests {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String EXISTING_ACCOUNT_NO = "1234";</span><br class="calibre10"/>    <span class="FontName">private static final String NEW_ACCOUNT_NO = "5678";</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Account existingAccount;</span><br class="calibre10"/>    <span class="FontName">private Account newAccount;</span><br class="calibre10"/>    <span class="FontName">private InMemoryAccountDao accountDao;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">existingAccount = new Account(EXISTING_ACCOUNT_NO, 100);</span><br class="calibre10"/>        <span class="FontName">newAccount = new Account(NEW_ACCOUNT_NO, 200);</span><br class="calibre10"/>        <span class="FontName">accountDao = new InMemoryAccountDao();</span><br class="calibre10"/>        <span class="FontName">accountDao.createAccount(existingAccount);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void accountExists() {</span><br class="calibre10"/>        <span class="FontName">assertTrue(accountDao.accountExists(EXISTING_ACCOUNT_NO));</span><br class="calibre10"/>        <span class="FontName">assertFalse(accountDao.accountExists(NEW_ACCOUNT_NO));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void createNewAccount() {</span><br class="calibre10"/>        <span class="FontName">accountDao.createAccount(newAccount);</span><br class="calibre10"/>        <span class="FontName">assertEquals(accountDao.findAccount(NEW_ACCOUNT_NO), newAccount);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test(expected = DuplicateAccountException.class)</span><br class="calibre10"/>    <span class="FontName">public void createDuplicateAccount() {</span><br class="calibre10"/>        <span class="FontName">accountDao.createAccount(existingAccount);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void updateExistedAccount() {</span><br class="calibre10"/>        <span class="FontName">existingAccount.setBalance(150);</span><br class="calibre10"/>        <span class="FontName">accountDao.updateAccount(existingAccount);</span><br class="calibre10"/>        <span class="FontName">assertEquals(accountDao.findAccount(EXISTING_ACCOUNT_NO), existingAccount);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test(expected = AccountNotFoundEx</span><span class="FontName">ception.class)</span><br class="calibre10"/>    <span class="FontName">public void updateNotExistedAccount() {</span><br class="calibre10"/>        <span class="FontName">accountDao.updateAccount(newAccount);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void removeExistedAccount() {</span><br class="calibre10"/>        <span class="FontName">accountDao.removeAccount(existingAccount);</span><br class="calibre10"/>        <span class="FontName">assertFalse(accountDao.accountExists(EXISTING_ACCOUNT_NO));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test(expected = AccountNotFoundException.class)</span><br class="calibre10"/>    <span class="FontName">public void removeNotExistedAccount() {</span><br class="calibre10"/>        <span class="FontName">accountDao.removeAccount(newAccount);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void findExistedAccount() {</span><br class="calibre10"/>        <span class="FontName">Account account = accountDao.findAccount(EXISTING_ACCOUNT_NO);</span><br class="calibre10"/>        <span class="FontName">assertEquals(account, existingAccount);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test(expected = AccountNotFoundException.class)</span><br class="calibre10"/>    <span class="FontName">public void findNotExistedAccount() {</span><br class="calibre10"/>        <span class="FontName">accountDao.findAccount(</span><span class="FontName">NEW_ACCOUNT_NO);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec12" class="Heading2">Creating Unit Tests for Dependent Classes <a id="cXXX.2255" class="calibre6"></a>Using Stubs and Mock Objects<a id="cXXX.1213" class="calibre6"></a></p>
<p class="noindent">Testing an independent class is easy, because you needn’t consider how its dependencies work and how to set them up properly. However, testing a class that depends on results of other classes or services (e.g., database services and network services) would be a little bit difficult. For example, let’s consider the following <span class="FontName">AccountService</span><a id="cXXX.1214" class="calibre5"></a> interface in the service layer:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface AccountService {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void createAccount(String accountNo);</span><br class="calibre10"/>    <span class="FontName">public void removeAccount(String accountNo);</span><br class="calibre10"/>    <span class="FontName">public void deposit(String accountNo, double amount);</span><br class="calibre10"/>    <span class="FontName">public void withdraw(String accountNo, double amount);</span><br class="calibre10"/>    <span class="FontName">public double getBalance(String accountNo);</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The implementation of this service interface has to depend on an <span class="FontName">AccountDao</span> object in the persistence layer to persist account objects. The <span class="FontName">InsufficientBalanceException</span><a id="cXXX.1215" class="calibre5"></a> class is also a subclass of <span class="FontName">RuntimeException</span> that you have to create.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class AccountServiceImpl implements AccountService {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private AccountDao accountDao;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public AccountServiceImpl(AccountDao accountDao) {</span><br class="calibre10"/>        <span class="FontName">this.accountDao = accountDao;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void createAccount(String accountNo) {</span><br class="calibre10"/>        <span class="FontName">accountDao.createAccount(new Account(accountNo, 0));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void removeAccount(String accountNo) {</span><br class="calibre10"/>        <span class="FontName">Account account = accountDao.findAccount(accountNo);</span><br class="calibre10"/>        <span class="FontName">accountDao.removeAccount(account);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void deposit(String accountNo, double amount) {</span><br class="calibre10"/>        <span class="FontName">Account account = accountDao.findAccount(accountNo);</span><br class="calibre10"/>        <span class="FontName">account.setBalance(account.getBalance() + amount);</span><br class="calibre10"/>        <span class="FontName">accountDao.updateAccount(account);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void withdraw(String accountNo, double amount) {</span><br class="calibre10"/>        <span class="FontName">Account account = accountDao.findAccount(accountNo);</span><br class="calibre10"/>        <span class="FontName">if (account.getBalance() &lt; amount) {</span><br class="calibre10"/>            <span class="FontName">throw new InsufficientBalanceException();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">account.setBalance(account.getBalance() - amount);</span><br class="calibre10"/>        <span class="FontName">accountDao.updateAccount(account);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public double getBalance(String accountNo) {</span><br class="calibre10"/>        <span class="FontName">return accountDao.findAccount(accountNo).getBalance();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">A common technique used in unit testing to reduce complexity caused by dependencies is using stubs. A stub must implement the same interface as the target object so that it can substitute for the target object. For example, you can create a stub for <span class="FontName">AccountDao</span> that stores a single customer account and implements only the <span class="FontName">findAccount()</span> and <span class="FontName">updateAccount()</span><a id="cXXX.1216" class="calibre5"></a> methods, as they are required for <span class="FontName">deposit()</span> and <span class="FontName">withdraw()</span>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import static org.junit.Assert.*;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.junit.Before;</span><br class="calibre10"/><span class="FontName">import org.junit.Test;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class AccountServiceImplStubTests {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/>    <span class="FontName">private AccountDaoStub accountDaoStub;</span><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private class AccountDaoStub implements AccountDao {</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">private String accountNo;</span><br class="calibre10"/>        <span class="FontName">private double balance;</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">public void createAccount(Account account) {}</span><br class="calibre10"/>        <span class="FontName">public void removeAccount(Account account) {}</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">public Account findAccount(String accountNo) {</span><br class="calibre10"/>            <span class="FontName">return new Account(this.accountNo, this.balance);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">public void updateAccount(Account account) {</span><br class="calibre10"/>            <span class="FontName">this.accountNo = account.getAccountNo();</span><br class="calibre10"/>            <span class="FontName">this.balance = account.getBalance();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">accountDaoStub = new AccountDaoStub();</span><br class="calibre10"/>        <span class="FontName">accountDaoStub.accountNo = TEST_ACCOUNT_NO;</span><br class="calibre10"/>        <span class="FontName">accountDaoStub.balance = 100;</span><br class="calibre10"/>        <span class="FontName">accountService = new AccountServiceImpl</span><a id="cXXX.1217" class="calibre5"></a><span class="FontName">(accountDaoStub);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void deposit() {</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/>        <span class="FontName">assertEquals(accountDaoStub.accountNo, TEST_ACCOUNT_NO);</span><br class="calibre10"/>        <span class="FontName">assertEquals(accountDaoStub.balance, 150, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void withdrawWithSufficientBalance() {</span><br class="calibre10"/>        <span class="FontName">accountService.withdraw(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/>        <span class="FontName">assertEquals(accountDaoStub.accountNo, TEST_ACCOUNT_NO);</span><br class="calibre10"/>        <span class="FontName">assertEquals(accountDaoStub.balance, 50, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test(expected = InsufficientBalanceException.class)</span><br class="calibre10"/>    <span class="FontName">public void withdrawWithInsufficientBalance() {</span><br class="calibre10"/>        <span class="FontName">accountService.withdraw(TEST_ACCOUNT_NO, 150);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">However, writing stubs yourself requires a lot of coding. A more efficient technique is to use mock objects. The Mockito library is able to dynamically create mock objects that work in a record/playback mechanism.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To use Mockito for testing, you have to add it to your CLASSPATH. If you are using Maven, add the following dependency to your project.</p>
<pre class="calibre19"><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.mockito&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;mockito-core&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;1.9.5&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span></pre></div>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.junit.Before;</span><br class="calibre10"/><span class="FontName">import org.junit.Test;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import static org.mockito.Mockito.*;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class AccountServiceImplMockTests {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private AccountDao accountDao;</span><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">accountDao = mock(AccountDao.class);</span><br class="calibre10"/>        <span class="FontName">accountService = new AccountServiceImpl(accountDao);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void deposit() {</span><br class="calibre10"/>        <span class="FontName">// Setup</span><br class="calibre10"/>        <span class="FontName">Account account = new Account(TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>        <span class="FontName">when(accountDao.findAccount(TEST_ACCOUNT_NO)).thenReturn(account);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">// Execute</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">// Verify</span><br class="calibre10"/>        <span class="FontName">verify(accountDao, times(1)).findAccount(any(String.class));</span><br class="calibre10"/>        <span class="FontName">verify(accountDao, times(1)).updateAccount(account);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void withdrawWithSufficientBalance() {</span><br class="calibre10"/>        <span class="FontName">// Setup</span><br class="calibre10"/>        <span class="FontName">Account account = new Account(TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>        <span class="FontName">when(accountDao.findAccount(TEST_ACCOUNT_NO)).thenReturn(account);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">// Execute</span><br class="calibre10"/>        <span class="FontName">accountService.withdraw(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">// Verify</span><br class="calibre10"/>        <span class="FontName">verify(accountDao, times(1)).findAccount(any(String.class));</span><br class="calibre10"/>        <span class="FontName">verify(accountDao, times(1)).updateAccount(account);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test(expected = InsufficientBalanceException.class)</span><br class="calibre10"/>    <span class="FontName">public void testWithdrawWithInsufficientBalance() {</span><br class="calibre10"/>        <span class="FontName">// Setup</span><br class="calibre10"/>        <span class="FontName">Account account = new Account(TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>        <span class="FontName">when(accountDao.findAccount(TEST_ACCOUNT_NO)).thenReturn(account);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">// Execute</span><br class="calibre10"/>        <span class="FontName">accountService.withdraw(TEST_ACCOUNT_NO, 150);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">With Mockito, you can create a mock object dynamically for an arbitrary interface or class. This mock can be instructed to have certain behavior for method calls and you can use it to selectively verify if something has happened. In your test you want that in the <span class="FontName">findAccount</span> method that a certain <span class="FontName">Account</span> object is returned. You use the <span class="FontName">Mockito</span><a id="cXXX.1218" class="calibre5"></a><span class="FontName">.when</span> method for this and you can then either return a value, throw an exception, or do more elaborate things with an <span class="FontName">Answer</span>. The default behavior for the mock is to return <span class="FontName">null</span><a id="cXXX.1219" class="calibre5"></a>.</p>
<p class="indent">You use the <span class="FontName">Mockito.verify</span><a id="cXXX.1220" class="calibre5"></a> method to do selective verification of things that have happened. You want to make sure that our <span class="FontName">findAccount</span> method is called and that the account gets updated.</p>
<p id="Sec13" class="Heading2">Creating Integration T<a id="cXXX.1221" class="calibre6"></a>ests</p>
<p class="noindent">Integration tests are used to test several units in combination to ensure that the units are properly integrated and can interact correctly. For example, you can create an integration test to test <span class="FontName">AccountServiceImpl</span><a id="cXXX.1222" class="calibre5"></a> using <span class="FontName">InMemoryAccountDao</span> as the DAO implementation:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import static org.junit.Assert.*;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.junit.After;</span><br class="calibre10"/><span class="FontName">import org.junit.Before;</span><br class="calibre10"/><span class="FontName">import org.junit.Test;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class AccountServiceTests {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">accountService = new AccountServiceImpl(new InMemoryAccountDao());</span><br class="calibre10"/>        <span class="FontName">accountService.createAccount(TEST_ACCOUNT_NO);</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void deposit() {</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/>        <span class="FontName">assertEquals(accountService.getBalance(TEST_ACCOUNT_NO), 150, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void withDraw() {</span><br class="calibre10"/>        <span class="FontName">accountService.withdraw(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/>        <span class="FontName">assertEquals(accountService.getBalance(TEST_ACCOUNT_NO), 50, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@After</span><br class="calibre10"/>    <span class="FontName">public void cleanup() {</span><br class="calibre10"/>        <span class="FontName">accountService.removeAccount(TEST_ACCOUNT_NO);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec14" class="Heading">17-3. Unit Testing Spring MVC Controllers<a id="cXXX.1223" class="calibre6"></a></p>
<p id="Sec15" class="Heading1">Problem</p>
<p class="noindent">In a web application, you would like to test the web controllers<a id="cXXX.1224" class="calibre5"></a> developed with the Spring MVC framework.</p>
<p id="Sec16" class="Heading1">Solution</p>
<p class="noindent">A Spring MVC controller is invoked by <span class="FontName">DispatcherServlet</span><a id="cXXX.1225" class="calibre5"></a> with an HTTP request object and an HTTP response object. After processing a request, the controller returns it to <span class="FontName">DispatcherServlet</span> for rendering the view. The main challenge of unit testing Spring MVC controllers, as well as web controllers in other web application frameworks, is simulating HTTP request objects and response objects in a unit testing environment. Fortunately, Spring supports web controller testing by providing a set of mock objects for the Servlet API (including <span class="FontName">MockHttpServletRequest</span>, <span class="FontName">MockHttpServletResponse</span>, and <span class="FontName">MockHttpSession</span>).</p>
<p class="indent">To test a Spring MVC controller’s output, you need to check if the object returned to <span class="FontName">DispatcherServlet</span> is correct. Spring also provides a set of assertion utilities for checking the contents of an object.</p>
<p id="Sec17" class="Heading1">How It Works</p>
<p class="noindent">In your bank system, suppose you are going to develop a web interface for bank staff to input the account number and amount of a deposit. You create a controller named <span class="FontName">DepositController</span><a id="cXXX.1226" class="calibre5"></a> using the techniques you already know from Spring MVC:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank.web;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Controller;</span><br class="calibre10"/><span class="FontName">import org.springframework.ui.ModelMap;</span><br class="calibre10"/><span class="FontName">import org.springframework.web.bind.annotation.RequestMapping;</span><br class="calibre10"/><span class="FontName">import org.springframework.web.bind.annotation.RequestParam;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Controller</span><br class="calibre10"/><span class="FontName">public class DepositController {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">public DepositController(AccountSe</span><span class="FontName">rvice accountService) {</span><br class="calibre10"/>        <span class="FontName">this.accountService = accountService;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@RequestMapping("/deposit.do")</span><br class="calibre10"/>    <span class="FontName">public String deposit(</span><br class="calibre10"/>            <span class="FontName">@RequestParam("accountNo") String accountNo,</span><br class="calibre10"/>            <span class="FontName">@RequestParam("amount") double amount,</span><br class="calibre10"/>            <span class="FontName">ModelMap model) {</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(accountNo, amount);</span><br class="calibre10"/>        <span class="FontName">model.addAttribute("accountNo", accountNo);</span><br class="calibre10"/>        <span class="FontName">model.addAttribute("balance", accountService.getBalance(accountNo));</span><br class="calibre10"/>        <span class="FontName">return "success";</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Because this controller doesn’t deal with the Servlet API, testing it is very easy. You can test it just like a simple Java class:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank.web;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import static org.junit.Assert.*;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.bank.AccountService;</span><br class="calibre10"/><span class="FontName">import org.junit.Before;</span><br class="calibre10"/><span class="FontName">import org.junit.Test;</span><br class="calibre10"/><span class="FontName">import org.mockito.Mockito;</span><br class="calibre10"/><span class="FontName">import org.springframework.ui.ModelMap;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class DepositControllerTests {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/>    <span class="FontName">private static final double TEST_AMOUNT = 50;</span><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/>    <span class="FontName">private DepositController depositController;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">accountService = Mockito.mock(AccountService.class);</span><br class="calibre10"/>        <span class="FontName">depositController = new DepositController(accountService);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void deposit() {</span><br class="calibre10"/>        <span class="FontName">//Setup</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Mockito.when(accountService.getBalance(TEST_ACCOUNT_NO)).thenReturn(150.0);</span><br class="calibre10"/>        <span class="FontName">ModelMap model = new ModelMap();</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">//Execute</span><br class="calibre10"/>        <span class="FontName">String viewName =</span><br class="calibre10"/>            <span class="FontName">depositController.deposit(TEST_ACCOUNT_NO,</span> <span class="FontName">TEST_AMOUNT, model);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">assertEquals(viewName, "success");</span><br class="calibre10"/>        <span class="FontName">assertEquals(model.get("accountNo"), TEST_ACCOUNT_NO);</span><br class="calibre10"/>        <span class="FontName">assertEquals(model.get("balance"), 150.0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec18" class="Heading">17-4. Managing Application Contexts in Integration Tests</p>
<p id="Sec19" class="Heading1">Problem</p>
<p class="noindent">When creating integration tests for a Spring application, you have to access beans declared in the application context. Without Spring’s testing support, you have to load the application context manually in an initialization method of your tests, a method with <span class="FontName">@Before</span> or <span class="FontName">@BeforeClass</span> in JUnit 4. However, as an initialization method is called before each test method or test class, the same application context may be reloaded many times. In a large application with many beans, loading an application context may require a lot of time, which causes your tests to run slowly.</p>
<p id="Sec20" class="Heading1">Solution</p>
<p class="noindent">Spring’s testing support facilities can help you manage the application context for your tests, including loading it from one or more bean configuration files and caching it across multiple test executions. An application context will be cached across all tests within a single JVM, using the configuration file locations as the key. As a result, your tests can run much faster without reloading the same application context many times.</p>
<p class="indent">Starting from Spring 2.5, the TestContext framework provides two test execution listeners related to context management. They will be registered with a test context manager by default if you don’t specify your own explicitly.</p>
<ul class="bulleted"><li class="calibre17"><span class="FontName">DependencyInjectionTestExecutionListener</span>: This injects dependencies, including the managed application context, into your tests.</li>
<li class="calibre17"><span class="FontName">DirtiesContextTestExecutionListener</span>: This handles the <span class="FontName">@DirtiesContext</span> annotation and reloads the application context when necessary.</li></ul>
<p class="indent">To have the TestContext framework<a id="cXXX.1227" class="calibre5"></a> manage the application context, your test class has to integrate with a test context manager internally. For your convenience, the TestContext framework provides support classes that do this, as shown in <a id="_Tab1" href="part0027.html#Tab1" class="calibre5">Table 17-1</a>. These classes integrate with a test context manager and implement the <span class="FontName">ApplicationContextAware</span> interface, so they can provide access to the managed application context through the protected field <span class="FontName">applicationContext</span>. Your test class can simply extend the corresponding TestContext support class for your testing framework.</p>
<div class="Table" id="Tab1">
<p class="TabCapt"><span class="calibre4"><a href="part0027.html#_Tab1" class="calibre5">Table 17-1</a>.</span> TestContext Support Classes for Context Management</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">Testing Framework</p></th><th valign="top" class="calibre14">
<p class="tab-left">TestContext Support Class*</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">JUnit 4</p></td><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">AbstractJUnit4SpringContextTests</span></p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">TestNG</p></td><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">AbstractTestNGSpringContextTests</span></p></td></tr></tbody></table>
<p class="noindent"><i class="calibre8">*These TestContext support classes have only</i> <span class="FontName">DependencyInjectionTestExecutionListener</span> <i class="calibre8">and</i> <span class="FontName">DirtiesContextTestExecutionListener</span> <i class="calibre8">enabled.</i></p></div>
<p class="indent">If you are using JUnit 4 or TestNG, you can integrate your test class with a test context manager by yourself and implement the <span class="FontName">ApplicationContextAware</span> interface directly, without extending a TestContext support class. In this way, your test class doesn’t bind to the TestContext framework class hierarchy, so you can extend your own base class. In JUnit 4, you can simply run your test with the test runner <span class="FontName">SpringJUnit4ClassRunner</span> to have a test context manager integrated. However, in TestNG<a id="cXXX.1228" class="calibre5"></a>, you have to integrate with a test context manager manually.</p>
<p id="Sec21" class="Heading1">How It Works</p>
<p class="noindent">First, let’s declare an <span class="FontName">AccountService</span><a id="cXXX.1229" class="calibre5"></a> instance and an <span class="FontName">AccountDao</span> instance in the bean configuration class as follows. Later, you will create integration tests<a id="cXXX.2063" class="calibre5"></a> for them.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank.config;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.bank.AccountDao;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.bank.AccountService;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.bank.AccountServiceImpl;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.bank.InMemoryAccountDao;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class BankConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><span class="FontName"></span><span class="FontName"></span><br class="calibre10"/>    <span class="FontName">public AccountDao accountDao() {</span><br class="calibre10"/>        <span class="FontName">return new InMemoryAccountDao();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public AccountService accountService() {</span><br class="calibre10"/>        <span class="FontName">return new AccountServiceImpl(accountDao());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec22" class="Heading2">Accessing the Context with the TestContext Framework <a id="cXXX.2246" class="calibre6"></a>in JUnit 4<a id="cXXX.1230" class="calibre6"></a></p>
<p class="noindent">If you are using JUnit 4 to create tests with the TestContext framework, you will have two options to access the managed application context. The first option is by implementing the <span class="FontName">ApplicationContextAware</span> interface. For this option, you have to explicitly specify a Spring-specific test runner for running your test—<span class="FontName">SpringJUnit4ClassRunner</span>. You can specify this in the <span class="FontName">@RunWith</span> annotation at the class level.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.bank.config.BankConfiguration;</span><br class="calibre10"/><span class="FontName">import org.junit.After;</span><br class="calibre10"/><span class="FontName">import org.junit.Before;</span><br class="calibre10"/><span class="FontName">import org.junit.Test;</span><br class="calibre10"/><span class="FontName">import org.junit.runner.RunWith;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import static org.junit.Assert.assertEquals;</span><br class="calibre10"/><br class="calibre10"/><b class="calibre4">@RunWith(SpringJUnit4ClassRunner.class)</b><br class="calibre10"/><b class="calibre4">@ContextConfiguration(classes = BankConfiguration.class)</b><br class="calibre10"/><span class="FontName">public class AccountServiceJUnit4ContextTests implements ApplicationContextAware {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/>    <span class="FontName">private ApplicationContext applicationContext;</span><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Override</span><br class="calibre10"/>    <span class="FontName">public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {</span><br class="calibre10"/>        <span class="FontName">this.applicationContext=applicationContext;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">accountService = applicationContext.getBean(AccountService.class);</span><br class="calibre10"/>        <span class="FontName">accountService.createAccount(TEST_ACCOUNT_NO);</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void deposit() {</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/>        <span class="FontName">assertEquals(accountService.getBalance(TEST_ACCOUNT_NO), 150, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void withDraw() {</span><br class="calibre10"/>        <span class="FontName">accountService.withdraw(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/>        <span class="FontName">assertEquals(accountService.getBalance(TEST_ACCOUNT_NO), 50, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@After</span><br class="calibre10"/>    <span class="FontName">public void cleanup() {</span><br class="calibre10"/>        <span class="FontName">accountService.removeAccount(TEST_ACCOUNT_NO);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You can specify the configuration classes in the <span class="FontName">classes</span> attribute of the <span class="FontName">@ContextConfiguration</span> annotation at the class level, when using xml based configuration you can use the <span class="FontName">locations</span> attribute instead. If you don’t specify any test configuration the TestContext will try to detect one. It will first try to load a file by joining the test class name with <span class="FontName">-context.xml</span> as the suffix (i.e., <span class="FontName">AccountServiceJUnit4Tests-context.xml</span>) from the same package as the test class. Next it will scan the test class for any <span class="FontName">public static</span> inner classes that are annotated with <span class="FontName">@Configuration</span>. If a file or classes are detected those will be used to load the test configuration.</p>
<p class="indent">By default, the application context will be cached and reused for each test method, but if you want it to be reloaded after a particular test method, you can annotate the test method with the <span class="FontName">@DirtiesContext</span> annotation so that the application context will be reloaded for the next test method.</p>
<p class="indent">The second option to access the managed application context is by extending the TestContext support class specific to JUnit 4: <span class="FontName">AbstractJUnit4SpringContextTests</span>. This class implements the <span class="FontName">ApplicationContextAware</span> interface, so you can extend it to get access to the managed application context via the protected field <span class="FontName">applicationContext</span>. However, you first have to delete the private field <span class="FontName">applicationContext</span> and its setter method. Note that if you extend this support class, you don’t need to specify <span class="FontName">SpringJUnit4ClassRunner</span> in the <span class="FontName">@RunWith</span> annotation, because this annotation is inherited from the parent.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;</span><br class="calibre10"/><br class="calibre10"/><b class="calibre4">@ContextConfiguration(classes = BankConfiguration.class)</b><br class="calibre10"/><span class="FontName">public class AccountServiceJUnit4ContextTests</span> <span class="FontName">extends</span> <b class="calibre4">AbstractJUnit4SpringContextTests</b> <span class="FontName">{</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">accountService =</span><br class="calibre10"/>            <span class="FontName">(AccountService) applicationContext.getBean("accountService");</span><br class="calibre10"/>        <span class="FontName">accountService.createAccount(TEST_ACCOUNT_NO);</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec23" class="Heading2">Accessing the Context with the TestContext Framework in TestNG</p>
<p class="noindent">To access the managed application context with the TestContext framework in TestNG, you can extend the TestContext support class <span class="FontName">AbstractTestNGSpringContextTests</span>. This class also implements the <span class="FontName">ApplicationContextAware</span> interface.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.bank.config.BankConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.testng.AbstractTestNGSpringContextTests;</span><br class="calibre10"/><span class="FontName">import org.testng.annotations.AfterMethod;</span><br class="calibre10"/><span class="FontName">import org.testng.annotations.BeforeMethod;</span><br class="calibre10"/><span class="FontName">import org.testng.annotations.Test;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import static org.testng.Assert.assertEquals;</span><br class="calibre10"/><br class="calibre10"/><b class="calibre4">@ContextConfiguration(classes = BankConfiguration.class)</b><br class="calibre10"/><span class="FontName">public class AccountServiceTestNGContextTests extends</span> <b class="calibre4">AbstractTestNGSpringContextTests</b> <span class="FontName">{</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@BeforeMethod</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">accountService =</span><br class="calibre10"/>                <span class="FontName">(AccountService) applicationContext.getBean("accountService");</span><br class="calibre10"/>        <span class="FontName">accountService.createAccount(TEST_ACCOUNT_NO);</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void deposit() {</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/>        <span class="FontName">assertEquals(accountService.getBalance(TEST_ACCOUNT_NO), 150, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void withDraw() {</span><br class="calibre10"/>        <span class="FontName">accountService.withdraw(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/>        <span class="FontName">assertEquals(accountService.getBalance(TEST_ACCOUNT_NO), 50, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@AfterMethod</span><br class="calibre10"/>    <span class="FontName">public void cleanup() {</span><br class="calibre10"/>        <span class="FontName">accountService.removeAccount(TEST_ACCOUNT_NO);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you don’t want your TestNG test class to extend a TestContext support class, you can implement the <span class="FontName">ApplicationContextAware</span> interface just as you did for JUnit 4. However, you have to integrate with a test context manager by yourself. Please refer to the source code of <span class="FontName">AbstractTestNGSpringContextTests</span> for details.</p>
<p id="Sec24" class="Heading">17-5. Injecting Test Fixtures into Integration Tests</p>
<p id="Sec25" class="Heading1">Problem</p>
<p class="noindent">The test fixtures<a id="cXXX.1231" class="calibre5"></a> of an integration test for a Spring application are mostly beans declared in the application context. You might wish to have the test fixtures automatically injected by Spring via dependency injection, which saves you the trouble of retrieving them from the application context manually.</p>
<p id="Sec26" class="Heading1">Solution</p>
<p class="noindent">Spring’s testing<a id="cXXX.2244" class="calibre5"></a> support facilities can inject beans automatically from the managed application context into your tests as test fixtures.</p>
<p class="indent">Starting in Spring 2.5’s TestContext framework, <span class="FontName">DependencyInjectionTestExecutionListener</span> can automatically inject dependencies into your tests. If you have this listener registered, you can simply annotate a setter method or field of your test with Spring’s <span class="FontName">@Autowired</span> annotation or JSR-250’s <span class="FontName">@Resource</span> annotation to have a fixture injected automatically. For <span class="FontName">@Autowired</span>, the fixture will be injected by type, and for <span class="FontName">@Resource</span>, it will be injected by name.</p>
<p id="Sec27" class="Heading1">How It Works</p>
<p id="Sec28" class="Heading2">Injecting Test Fixtures with the TestContext Framework in JUnit 4</p>
<p class="noindent">When using the TestContext framework<a id="cXXX.1232" class="calibre5"></a> to create tests, you can have their test fixtures injected from the managed application context by annotating a field or setter method with the <span class="FontName">@Autowired</span> or <span class="FontName">@Resource</span> annotations. In JUnit 4, you can specify <span class="FontName">SpringJUnit4ClassRunner</span> as your test runner without extending a support class.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br class="calibre10"/><br class="calibre10"/><b class="calibre4">@RunWith(SpringJUnit4ClassRunner.class)</b><br class="calibre10"/><b class="calibre4">@ContextConfiguration(classes = BankConfiguration.class)</b><br class="calibre10"/><span class="FontName">public class AccountServiceJUnit4ContextTests {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Autowired</b><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">accountService.createAccount(TEST_ACCOUNT_NO);</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="noindent">If you annotate a field or setter method of a test with <span class="FontName">@Autowired</span><a id="cXXX.1233" class="calibre5"></a>, it will be injected using auto-wiring by type. You can further specify a candidate bean for auto-wiring by providing its name in the <span class="FontName">@Qualifier</span> annotation. However, if you want a field or setter method to be auto-wired by name, you can annotate it with <span class="FontName">@Resource</span>.</p>
<p class="indent">By extending the TestContext support class <span class="FontName">AbstractJUnit4SpringContextTests</span><a id="cXXX.1234" class="calibre5"></a>, you can also have test fixtures injected from the managed application context. In this case, you don’t need to specify <span class="FontName">SpringJUnit4ClassRunner</span> for your test, as it is inherited from the parent.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;</span><br class="calibre10"/><br class="calibre10"/><b class="calibre4">@ContextConfiguration(classes = BankConfiguration.class)</b><br class="calibre10"/><span class="FontName">public class AccountServiceJUnit4ContextTests extends</span> <b class="calibre4">AbstractJUnit4SpringContextTests</b> <span class="FontName">{</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Autowired</b><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec29" class="Heading2">Injecting Test Fixtures with the TestContext Framework in TestNG</p>
<p class="noindent">In TestNG, you can extend the TestContext support class <span class="FontName">AbstractTestNGSpringContextTests</span><a id="cXXX.1235" class="calibre5"></a> to have test fixtures injected from the managed application context:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.testng.AbstractTestNGSpringContextTests;</span><br class="calibre10"/><br class="calibre10"/><b class="calibre4">@ContextConfiguration(classes = BankConfiguration.class)</b><br class="calibre10"/><span class="FontName">public class AccountServiceTestNGContextTests extends</span> <b class="calibre4">AbstractTestNGSpringContextTests</b> <span class="FontName">{</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Autowired</b><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@BeforeMethod</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">accountService.createAccount(TEST_ACCOUNT_NO);</span><br class="calibre10"/>        <span class="FontName">accountServic</span><span class="FontName">e.deposit(TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec30" class="Heading">17-6. Managing Transactions<a id="cXXX.2251" class="calibre6"></a> in Integration Tests</p>
<p id="Sec31" class="Heading1">Problem</p>
<p class="noindent">When creating integration tests for an application that accesses a database, you usually prepare the test data in the initialization method. After each test method runs, it may have modified the data in the database. So, you have to clean up the database to ensure that the next test method will run from a consistent state. As a result, you have to develop many database cleanup tasks.</p>
<p id="Sec32" class="Heading1">Solution</p>
<p class="noindent">Spring’s testing support facilities can create and roll back a transaction for each test method, so the changes you make in a test method won’t affect the next one. This can also save you the trouble of developing cleanup tasks to clean up the database.</p>
<p class="indent">Starting from Spring 2.5, the TestContext framework provides a test execution listener related to transaction management. It will be registered with a test context manager by default if you don’t specify your own explicitly.</p>
<ul class="bulleted"><li class="calibre17"><span class="FontName">TransactionalTestExecutionListener</span><a id="cXXX.1236" class="calibre5"></a>: This handles the <span class="FontName">@Transactional</span> annotation at the class or method level and has the methods run within transactions automatically.</li></ul>
<p class="indent">Your test class can extend the corresponding TestContext support class for your testing framework, as shown in <a id="_Tab2" href="part0027.html#Tab2" class="calibre5">Table 17-2</a>, to have its test methods run within transactions. These classes integrate with a test context manager and have <span class="FontName">@Transactional</span> enabled at the class level. Note that a transaction manager is also required in the bean configuration file.</p>
<div class="Table" id="Tab2">
<p class="TabCapt"><span class="calibre4"><a href="part0027.html#_Tab2" class="calibre5">Table 17-2</a>.</span> TestContext Support Classes for Transaction Management</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">Testing Framework</p></th><th valign="top" class="calibre14">
<p class="tab-left">TestContext Support Class*</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">JUnit 4</p></td><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">AbstractTransactionalJUnit4SpringContextTests</span></p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">TestNG</p></td><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">AbstractTransactionalTestNGSpringContextTests</span></p></td></tr></tbody></table>
<p class="noindent"><i class="calibre8">* These TestContext support classes have</i><i class="calibre8">TransactionalTestExecutionListener</i> <i class="calibre8">enabled in addition to</i><i class="calibre8">DependencyInjectionTestExecutionListener</i> <i class="calibre8">and</i> <i class="calibre8">DirtiesContextTestExecutionListener</i>.</p></div>
<p class="indent">In JUnit 4 and TestNG, you can simply annotate <span class="FontName">@Transactional</span><a id="cXXX.1237" class="calibre5"></a> at the class level or the method level to have the test methods run within transactions, without extending a TestContext support class. However, to integrate with a test context manager, you have to run the JUnit 4 test with the test runner <span class="FontName">SpringJUnit4ClassRunner</span>, and you have to do it manually for a TestNG test.</p>
<p id="Sec33" class="Heading1">How It Works</p>
<p class="noindent">Let’s consider storing your bank system’s accounts in a relational database. You can choose any JDBC-compliant database engine that supports transactions and then execute the following SQL statement on it to create the <span class="FontName">ACCOUNT</span> table. Here, we have chosen Apache Derby as our database engine and created the table in the <span class="FontName">bank</span> instance.</p>
<pre class="calibre11"><span class="FontName">CREATE TABLE ACCOUNT (</span><br class="calibre10"/>    <span class="FontName">ACCOUNT_NO    VARCHAR(10)    NOT NULL,</span><br class="calibre10"/>    <span class="FontName">BALANCE       DOUBLE         NOT NULL,</span><br class="calibre10"/>    <span class="FontName">PRIMARY KEY (ACCOUNT_NO)</span><br class="calibre10"/><span class="FontName">);</span></pre>
<p class="indent">Next, you create a new DAO implementation that uses JDBC to access the database. You can take advantage of <span class="FontName">SimpleJdbcTemplate</span><a id="cXXX.1238" class="calibre5"></a> to simplify your operations.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcAccountDao extends JdbcDaoSupport implements AccountDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void createAccount(Account account) {</span><br class="calibre10"/>        <span class="FontName">String sql = "INSERT INTO ACCOUNT (ACCOUNT_NO, BALANCE) VALUES (?, ?)";</span><br class="calibre10"/>        <span class="FontName">getJdbcTemplate().update(</span><br class="calibre10"/>                <span class="FontName">sql, account.getAccountNo(), account.getBalance());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void updateAccount(Account account) {</span><br class="calibre10"/>        <span class="FontName">String sql = "UPDATE ACCOUNT SET BALANCE = ? WHERE ACCOUNT_NO = ?";</span><br class="calibre10"/>        <span class="FontName">getJdbcTemplate().update(</span><br class="calibre10"/>                <span class="FontName">sql, account.getBalance(), account.getAccountNo());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void removeAccount(Account account) {</span><br class="calibre10"/>        <span class="FontName">String sql = "DELETE FROM ACCOUNT WHERE ACCOUNT_NO = ?";</span><br class="calibre10"/>        <span class="FontName">getJdbcTemplate().update(sql, account.getAccountNo());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Account findAccount(String accountNo) {</span><br class="calibre10"/>        <span class="FontName">String sql = "SELECT BALANCE FROM ACCOUNT WHERE ACCOUNT_NO = ?";</span><br class="calibre10"/>        <span class="FontName">double balance = getJdbcTemplate().queryForObject(</span><br class="calibre10"/>                <span class="FontName">sql, Double.class, accountNo);</span><br class="calibre10"/>        <span class="FontName">return new Account(accountNo, balance);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Before you create integration tests to test the <span class="FontName">AccountService</span> instance that uses this DAO to persist account objects, you have to replace <span class="FontName">InMemoryAccountDao</span> with this DAO in the configuration class, and configure the target data source as well.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To access a database running on the Derby server<a id="cXXX.1239" class="calibre5"></a>, you have to add the client library to the CLASSPATH of your application. If you are using Maven, add the following dependency to your project.</p>
<pre class="calibre19"><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.apache.derby&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;derbyclient&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;10.10.2.0&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span></pre></div>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class BankConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public DataSource dataSource() {</span><br class="calibre10"/>        <span class="FontName">DriverManagerDataSource dataSource = new DriverManagerDataSource();</span><br class="calibre10"/>        <span class="FontName">dataSource.setDriverClassName(ClientDriver.class.getName());</span><br class="calibre10"/>        <span class="FontName">dataSource.setUrl("jdbc:derby://localhost:1527/bank;create=true");</span><br class="calibre10"/>        <span class="FontName">dataSource.setUsername("app");</span><br class="calibre10"/>        <span class="FontName">dataSource.setPassword("app");</span><br class="calibre10"/>        <span class="FontName">return dataSource;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public AccountDao accountDao() {</span><br class="calibre10"/>        <span class="FontName">JdbcAccountDao accountDao = new JdbcAccountDao();</span><br class="calibre10"/>        <b class="calibre4">accountDao.setDataSource(dataSource());</b><br class="calibre10"/>        <span class="FontName">return accountDao;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public AccountService accountService</span><span class="FontName">() {</span><br class="calibre10"/>        <span class="FontName">return new AccountServiceImpl(accountDao());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec34" class="Heading2">Managing Transactions with the TestContext Framework<a id="cXXX.1240" class="calibre6"></a> in JUnit 4</p>
<p class="noindent">When using the TestContext framework to create tests, you can have the tests’ methods run within transactions by annotating <span class="FontName">@Transactional</span> at the class or method level. In JUnit 4, you can specify <span class="FontName">SpringJUnit4ClassRunner</span> for your test class so that it doesn’t need to extend a support class.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><b class="calibre4">@RunWith(SpringJUnit4ClassRunner.class)</b><br class="calibre10"/><span class="FontName">@ContextConfiguration(classes = BankConfiguration.class)</span><br class="calibre10"/><b class="calibre4">@Transactional</b><br class="calibre10"/><span class="FontName">public class AccountServiceJUnit4ContextTests {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">accountService.createAccount(TEST_ACCOUNT_NO);</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Don't need cleanup() anymore</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you annotate a test class with <span class="FontName">@Transactional</span>, all of its test methods will run within transactions. If you would like a particular method not to run within a transaction, you can annotate it with <span class="FontName">@NotTransactional</span>. An alternative is to annotate individual methods with <span class="FontName">@Transactional</span>, not the entire class.</p>
<p class="indent">By default, transactions for test methods will be rolled back at the end. You can alter this behavior by disabling the <span class="FontName">defaultRollback</span> attribute of <span class="FontName">@TransactionConfiguration</span>, which should be applied to the class level. Also, you can override this class-level rollback behavior at the method level with the <span class="FontName">@Rollback</span> annotation, which requires a Boolean value.</p>
<p class="indent">Note that methods with the <span class="FontName">@Before</span> or <span class="FontName">@After</span> annotation will be executed within the same transactions as test methods. If you have methods that need to perform initialization or cleanup tasks before or after a transaction, you have to annotate them with <span class="FontName">@BeforeTransaction</span> or <span class="FontName">@AfterTransaction</span>. Notice that these methods will not be executed for test methods annotated with <span class="FontName">@NotTransactional</span>.</p>
<p class="indent">Finally, you also need a transaction manager configured in the bean configuration file. By default, a bean whose type is <span class="FontName">PlatformTransactionManager</span> will be used, but you can specify another one in the <span class="FontName">transactionManager</span> attribute of the <span class="FontName">@TransactionConfiguration</span> annotation by giving its name.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public PlatformTransactionManager transactionManager() {</span><br class="calibre10"/>  <span class="FontName">return new DataSourceTransactionManager(dataSource());</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In JUnit 4, an alternative to managing transactions for test methods is to extend the transactional TestContext support class <span class="FontName">AbstractTransactionalJUnit4SpringContextTests</span>, which has <span class="FontName">@Transactional</span> enabled at the class level so that you don’t need to enable it again. By extending this support class, you don’t need to specify <span class="FontName">SpringJUnit4ClassRunner</span> for your test, as it is inherited from the parent.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@ContextConfiguration(classes = BankConfi</span><span class="FontName">guration.class)</span><br class="calibre10"/><span class="FontName">public class AccountServiceJUnit4ContextTests extends</span> <b class="calibre4">AbstractTransactionalJUnit4SpringContextTests</b> <span class="FontName">{</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec35" class="Heading2">Managing Transactions with the TestContext Framework in TestNG<a id="cXXX.1241" class="calibre6"></a></p>
<p class="noindent">To create TestNG tests that run within transactions, your test class can extend the TestContext support class <span class="FontName">AbstractTransactionalTestNGSpringContextTests</span> to have its methods run within transactions:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@ContextConfiguration(classes = BankConfiguration.class)</span><br class="calibre10"/><span class="FontName">public class AccountServiceTestNGContextTests extends</span><br class="calibre10"/>        <span class="FontName">AbstractTransactionalTestNGSpringContextTests {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private AccountService accountService;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@BeforeMethod</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">accountService.createAccount(TEST_ACCOUNT_NO);</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Don't need cleanup() anymore</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec36" class="Heading">17-7. Accessing a Database in Integration Tests<a id="cXXX.1242" class="calibre6"></a></p>
<p id="Sec37" class="Heading1">Problem</p>
<p class="noindent">When creating integration tests for an application that accesses a database, especially one developed with an ORM framework, you might wish to access the database directly to prepare test data and validate the data after a test method runs.</p>
<p id="Sec38" class="Heading1">Solution</p>
<p class="noindent">Spring’s testing support facilities can create and provide a JDBC template for you to perform database-related tasks in your tests.</p>
<p class="indent">Starting in Spring 2.5’s TestContext framework, your test class can extend one of the transactional TestContext support classes to access the precreated <span class="FontName">SimpleJdbcTemplate</span> instance. These classes also require a data source and a transaction manager in the bean configuration file.</p>
<p id="Sec39" class="Heading1">How It Works</p>
<p id="Sec40" class="Heading2">Accessing a Database with the TestContext Framework</p>
<p class="noindent">When using the TestContext framework to create tests, you can extend the corresponding TestContext support class to use a <span class="FontName">JdbcTemplate</span> instance via a protected field. For JUnit 4, this class is <span class="FontName">AbstractTransactionalJUnit4SpringContextTests</span>, which provides similar convenient methods for you to count the number of rows in a table, delete rows from a table, and execute a SQL script:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@ContextConfiguration(classes = BankConfiguration.class)</span><br class="calibre10"/><span class="FontName">public class AccountServiceJUnit4ContextTests extends</span> <b class="calibre4">AbstractTransactionalJUnit4SpringContextTests {</b><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Before</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>         <b class="calibre4">executeSqlScript("classpath:/bank.sql",true);</b><br class="calibre10"/>        <b class="calibre4">jdbcTemplate.update(</b><br class="calibre10"/>                <b class="calibre4">"INSERT INTO ACCOUNT (ACCOUNT</b><b class="calibre4">_NO, BALANCE) VALUES (?, ?)",</b><br class="calibre10"/>                <b class="calibre4">TEST_ACCOUNT_NO, 100);</b><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void deposit() {</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/>        <b class="calibre4">double balance = jdbcTemplate.queryForObject(</b><br class="calibre10"/>                <b class="calibre4">"SELECT BALANCE FROM ACCOUNT WHERE ACCOUNT_NO = ?",</b><br class="calibre10"/>                <b class="calibre4">Double.class, TEST_ACCOUNT_NO);</b><br class="calibre10"/>        <span class="FontName">assertEquals(balance, 150.0, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void withDraw() {</span><br class="calibre10"/>        <span class="FontName">accountService.withdraw(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/>        <b class="calibre4">double balance = jdbcTemplate.queryForObject(</b><br class="calibre10"/>                <b class="calibre4">"SELECT BALANCE FROM ACCOUNT WHERE ACCOUNT_NO = ?",</b><br class="calibre10"/>                <b class="calibre4">Double.class, TEST_ACCOUNT_NO);</b><br class="calibre10"/>        <span class="FontName">assertEquals(balance, 50.0, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In TestNG, you can extend <span class="FontName">AbstractTransactionalTestNGSpringContextTests</span> to use a <span class="FontName">JdbcTemplate</span> instance:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@ContextConfiguration(classes = BankConfiguration.class)</span><br class="calibre10"/><span class="FontName">public class AccountServiceTestNGContextTests extends</span> <b class="calibre4">AbstractTransactionalTestNGSpringContextTests</b> <span class="FontName">{</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@BeforeMethod</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>         <span class="FontName">executeSqlScript("classpath:/bank.sql",true);</span><br class="calibre10"/>        <b class="calibre4">jdbcTemplate.update(</b><br class="calibre10"/>                <b class="calibre4">"INSERT INTO ACCOUNT (ACCOUNT_NO, BALANCE) VALUES (?, ?)",</b><br class="calibre10"/>                <b class="calibre4">TEST_ACCOUNT_NO, 100);</b><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void deposit() {</span><br class="calibre10"/>        <span class="FontName">accountService.deposit(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/>        <b class="calibre4">double balance = jdbcTemplate.queryForObject(</b><br class="calibre10"/>                <b class="calibre4">"SELECT BALANCE FROM ACCOUNT WHERE ACCOUNT_NO = ?",</b><br class="calibre10"/>                <b class="calibre4">Double.class, TEST_ACCOUNT_NO);</b><br class="calibre10"/>        <span class="FontName">assertEquals(balance, 150, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void withDraw() {</span><br class="calibre10"/>        <span class="FontName">accountService.withdraw(TEST_ACCOUNT_NO, 50);</span><br class="calibre10"/>        <b class="calibre4">double balance = jdbcTemplate.queryForObject(</b><br class="calibre10"/>                <b class="calibre4">"SELECT BALANCE FROM ACC</b><b class="calibre4">OUNT WHERE ACCOUNT_NO = ?",</b><br class="calibre10"/>                <b class="calibre4">Double.class, TEST_ACCOUNT_NO);</b><br class="calibre10"/>        <span class="FontName">assertEquals(balance, 50, 0);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec41" class="Heading">17-8. Using Spring’s Common Testing Annotations<a id="cXXX.1243" class="calibre6"></a></p>
<p id="Sec42" class="Heading1">Problem</p>
<p class="noindent">You often have to manually implement common testing tasks, such as expecting an exception to be thrown, repeating a test method multiple times, ensuring that a test method will complete in a particular time period, and so on.</p>
<p id="Sec43" class="Heading1">Solution</p>
<p class="noindent">Spring’s testing support provides a common set of testing annotations to simplify your test creation. These annotations are Spring-specific but independent of the underlying testing framework. Of these, the following annotations are very useful for common testing tasks. However, they are only supported for use with JUnit:</p>
<ul class="bulleted"><li class="calibre17"><span class="FontName">@Repeat</span>: This indicates that a test method has to run multiple times. The number of times it will run is specified as the annotation value.</li>
<li class="calibre17"><span class="FontName">@Timed</span>: This indicates that a test method must complete in a specified time period (in milliseconds). Otherwise, the test fails. Note that the time period includes the repetitions of the test method and any initialization and cleanup methods.</li>
<li class="calibre17"><span class="FontName">@IfProfileValue</span>: This indicates that a test method can only run in a specific testing environment. This test method will run only when the actual profile value matches the specified one. You can also specify multiple values so that the test method will run if any of the values is matched. By default, <span class="FontName">SystemProfileValueSource</span> is used to retrieve system properties as profile values, but you can create your own <span class="FontName">ProfileValueSource</span> implementation and specify it in the <span class="FontName">@ProfileValueSourceConfiguration</span> annotation.</li></ul>
<p class="indent">Starting from Spring 2.5’s TestContext framework, you can use Spring’s testing annotations by extending one of the TestContext support classes. If you don’t extend a support class but run your JUnit 4 test with the test runner <span class="FontName">SpringJUnit4ClassRunner</span>, you can also use these annotations.</p>
<p id="Sec44" class="Heading1">How It Works</p>
<p id="Sec45" class="Heading2">Using Common Testing Annotations with the TestContext Framework</p>
<p class="noindent">When using the TestContext framework to create tests for JUnit 4, you can use Spring’s testing annotations if you run your test with <span class="FontName">SpringJUnit4ClassRunner</span> or extend a JUnit 4 TestContext support class:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.test.annotation.Repeat;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.annotation.Timed;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@ContextConfiguration(locations = "/beans.xml")</span><br class="calibre10"/><span class="FontName">public class AccountServiceJUnit4ContextTests extends</span> <b class="calibre4">AbstractTransactionalJUnit4SpringContextTests</b> <span class="FontName">{</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <b class="calibre4">@Timed(millis = 1000)</b><br class="calibre10"/>    <span class="FontName">public void deposit() {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <b class="calibre4">@Repeat(5)</b><br class="calibre10"/>    <span class="FontName">public void withDraw() {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec46" class="Heading">17-9. Integration Testing Spring MVC Controllers<a id="cXXX.1244" class="calibre6"></a></p>
<p id="Sec47" class="Heading1">Problem</p>
<p class="noindent">In a web application, you would like to integration test the web controllers developed with the Spring MVC framework.</p>
<p id="Sec48" class="Heading1">Solution</p>
<p class="noindent">A Spring MVC controller is invoked by <span class="FontName">DispatcherServlet</span> with an HTTP request object and an HTTP response object. After processing a request, the controller returns it to <span class="FontName">DispatcherServlet</span> for rendering the view. The main challenge of integration testing Spring MVC controllers, as well as web controllers in other web application frameworks, is simulating HTTP request objects and response objects in a unit testing environment as well as setting up the mocked environment for a unit test. Fortunately, Spring has the mock MVC part of the Spring Test support. This allows for easy setup of a mocked servlet environment.</p>
<p class="indent">Spring Test Mock MVC will setup a WebApplicationContext according to your configuration. Next you can use the MockMvc API to simulate HTTP requests and verifying the result.</p>
<p id="Sec49" class="Heading1">How It Works</p>
<p class="noindent">In our banking application we want to integration test our <span class="FontName">DepositController</span>. Before we can start testing we need to create a configuration class to configure our web-related beans.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank.web.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.ComponentScan;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.web.servlet.ViewResolver;</span><br class="calibre10"/><span class="FontName">import org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br class="calibre10"/><span class="FontName">import org.springframework.web.servlet.view.InternalResourceViewResolver;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><b class="calibre4">@EnableWebMvc</b><br class="calibre10"/><span class="FontName">@ComponentScan(basePackages = "com.apress.springrecipes.bank.web")</span><br class="calibre10"/><span class="FontName">public class BankWebConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public ViewResolver viewResolver() {</span><br class="calibre10"/>        <span class="FontName">InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();</span><br class="calibre10"/>        <span class="FontName">viewResolver.setPrefix("/WEB-INF/views/");</span><br class="calibre10"/>        <span class="FontName">viewResolver.setSuffix(".jsp");</span><br class="calibre10"/>        <span class="FontName">return viewResolver;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The configuration enables annotation based controllers by using the <span class="FontName">@EnableWebMvc</span> annotation, next you want the @Controller annotated beans to be picked up automatically using the <span class="FontName">@ComponentScan</span> annotation. Finally there is an <span class="FontName">InternalResourceViewResolver</span> which turns the name of the view into a URL which normally would be rendered by the browser, which you will now validate in the controller.</p>
<p class="indent">Now that the web based configuration is in place we can start to create our integration test. This unit test has to load our <span class="FontName">BankWebConfiguration</span> class and also has to be annotated with <span class="FontName">@WebAppConfiguration</span> to inform the TestContext framework we want a <span class="FontName">WebApplicationContext</span> instead of a plain <span class="FontName">ApplicationContext</span>.</p>
<p id="Sec50" class="Heading2">Integration Testing Spring MVC Controllers with JUnit<a id="cXXX.1245" class="calibre6"></a></p>
<p class="noindent">In JUnit it is the easiest to extend one of the base classes, in this case <span class="FontName">AbstractTransactionalJUnit4SpringContextTests</span> as we want to insert some test data and rollback after the tests complete.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bank.web;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.bank.config.BankConfiguration;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.bank.web.config.BankWebConfiguration;</span><br class="calibre10"/><span class="FontName">import org.junit.Before;</span><br class="calibre10"/><span class="FontName">import org.junit.Test;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.ContextConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.context.web.WebAppConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.web.servlet.MockMvc;</span><br class="calibre10"/><span class="FontName">import org.springframework.test.web.servlet.setup.MockMvcBuilders;</span><br class="calibre10"/><span class="FontName">import org.springframework.web.context.WebApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br class="calibre10"/><span class="FontName">import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;</span><br class="calibre10"/><span class="FontName">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.forwardedUrl;</span><br class="calibre10"/><span class="FontName">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br class="calibre10"/><br class="calibre10"/><b class="calibre4">@ContextConfiguration(classes= { BankWebConfiguration.class, BankConfiguration.class})</b><br class="calibre10"/><span class="FontName">@WebAppConfiguration</span><br class="calibre10"/><span class="FontName">public class DepositControllerJUnit4ContextTests extends AbstractTransactionalJUnit4SpringContextTests {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String ACCOUNT_PARAM = "accountNo";</span><br class="calibre10"/>    <span class="FontName">private static final String AMOUNT_PARAM = "amount";</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String TEST_ACCOUNT_NO = "1234";</span><br class="calibre10"/>    <span class="FontName">private static final String TEST_AMOUNT = "50.0";</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private WebApplicationContext webApplicationContext;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">private MockMvc mockMvc;</b><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Before</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">executeSqlScript("classpath:/bank.sql", true);</span><br class="calibre10"/>        <span class="FontName">jdbcTemplate.update(</span><br class="calibre10"/>                <span class="FontName">"INSERT INTO ACCOUNT (ACCOUNT_NO, BALANCE) VALUES (?, ?)",</span><br class="calibre10"/>                <span class="FontName">TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>        <span class="FontName">mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Test</span><br class="calibre10"/>    <span class="FontName">public void deposit() throws Exception {</span><br class="calibre10"/>        <span class="FontName">mockMvc.perform(</span><br class="calibre10"/>                <span class="FontName">get("/deposit.do")</span><br class="calibre10"/>                        <span class="FontName">.param(ACCOUNT_PARAM, TEST_ACCOUNT_NO)</span><br class="calibre10"/>                        <span class="FontName">.param(AMOUNT_PARAM, TEST_AMOUNT))</span><br class="calibre10"/>                <span class="FontName">.andDo(print())</span><br class="calibre10"/>                <span class="FontName">.andExpect(forwardedUrl("/WEB-INF/views/success.jsp"))</span><br class="calibre10"/>                <span class="FontName">.andExpect(status().isOk());</span><br class="calibre10"/>    <span class="FontName">}</span></pre>
<p class="indent">In the init method you prepare the <span class="FontName">MockMvc</span><a id="cXXX.1246" class="calibre5"></a> object by using the convenient <span class="FontName">MockMvcBuilders</span>. Using the factory method <span class="FontName">webAppContextSetup</span> we can use the already loaded <span class="FontName">WebApplicationContext</span> to initialize the <span class="FontName">MockMvc</span> object. The <span class="FontName">MockMvc</span> object basically mimics the behavior of the <span class="FontName">DispatcherServlet</span> which you would use in a Spring MVC based application. It will use the passed in WebApplicationContext to configure the handler mappings, view resolution strategies and will also apply any interceptors that are configured.</p>
<p class="indent">There is also some setup of a test account so that we have something to work with.</p>
<p class="indent">In the <span class="FontName">deposit</span> test method the initialized MockMvc object is used to simulate in incoming request to the <span class="FontName">/deposit.do</span> url with 2 request parameters <span class="FontName">accountNo</span> and <span class="FontName">amount</span>. The <span class="FontName">MockMvcRequestBuilders.get</span> factory method results in a <span class="FontName">RequestBuilder</span> instance that is passed to the <span class="FontName">MockMvc.perform</span> method.</p>
<p class="indent">The perform method returns a <span class="FontName">ResultActions</span> object which can be used to do assertions and certain actions on the return result. The test method prints the information for the created request and returned response using <span class="FontName">andDo(print())</span>, this can be useful while debugging your test. Finally there are two assertions to verify that everything works as expected. The <span class="FontName">DepositController</span> returns <span class="FontName">success</span> as the viewname which should lead to a fo<a id="cXXX.1247" class="calibre5"></a>rward to <span class="FontName">/WEB-INF/views/success.jsp</span> due to the configuration of the ViewResolver. The return code of the request should be 200 (OK) which can be tested with <span class="FontName">status().isOk()</span> or <span class="FontName">status().is(200)</span>.</p>
<p id="Sec51" class="Heading2">Integration Testing Spring MVC Controllers with TestNG</p>
<p class="noindent">Spring Mock MVC can also be used with TestNG extend the appropriate base class <span class="FontName">AbstractTransactionalTestNGSpringContextTests</span> and add the <span class="FontName">@WebAppConfiguration</span> annotation.</p>
<pre class="calibre11"><span class="FontName">@ContextConfiguration(classes= { BankWebConfiguration.class, BankConfiguration.class})</span><br class="calibre10"/><span class="FontName">@WebAppConfiguration</span><br class="calibre10"/><span class="FontName">public class DepositControllerTestNGContextTests</span> <br class="calibre10"/>    <span class="FontName">extends</span> <b class="calibre4">AbstractTransactionalTestNGSpringContextTests</b> <span class="FontName">{</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@BeforeMethod</span><br class="calibre10"/>    <span class="FontName">public void init() {</span><br class="calibre10"/>        <span class="FontName">executeSqlScript("classpath:/bank.sql", true);</span><br class="calibre10"/>        <span class="FontName">jdbcTemplate.update(</span><br class="calibre10"/>                <span class="FontName">"INSERT INTO ACCOUNT (ACCOUNT_NO, BALANCE) VALUES (?, ?)",</span><br class="calibre10"/>                <span class="FontName">TEST_ACCOUNT_NO, 100);</span><br class="calibre10"/>        <span class="FontName">mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec52" class="Heading">Summary</p>
<p class="noindent">In this chapter, you learned about the basic concepts and techniques used in testing Java applications. JUnit and TestNG are the most popular testing frameworks on the Java platform. JUnit 4 introduces several major improvements over JUnit 3. The most important of these is annotation support. TestNG is also a powerful annotation-based testing framework.</p>
<p class="indent">Unit tests are used for testing a single programming unit, which is typically a class or a method in object-oriented languages. When testing a unit that depends on other units, you can use stubs and mock objects to simulate its dependencies, thus making the tests simpler. In contrast, integration tests are used to test several units as a whole.</p>
<p class="indent">In the web layer, controllers are usually hard to test. Spring offers mock objects for the Servlet API so that you can easily simulate web request and response objects to test a web controller. As of Spring 3.2 there is also Spring Mock MVC for easy integration testing of your controllers.</p>
<p class="indent">Spring’s testing support facilities can manage application contexts for your tests by loading them from bean configuration files and caching them across multiple test executions. In releases prior to 4.0, Spring offered testing support specific to JUnit 3, as of Spring 4.0 this support has been removed.</p>
<p class="indent">You can access the managed application context in your tests, as well as have your test fixtures injected from the application context automatically. In addition, if your tests involve database updates, Spring can manage transactions for them so that changes made in one test method will be rolled back and thus won’t affect the next test method. Spring can also create a JDBC template for you to prepare and validate your test data in the database.</p>
<p class="indent">Spring provides a common set of testing annotations to simplify your test creation. These annotations are Spring-specific but independent of the underlying testing framework. However, some of these are only supported for use with JUnit.</p></div>
</body></html>
