<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Chapter 10 Data Access</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre"><p class="ChapterNumber"><a id="b9781430259084_10" class="calibre6"></a>CHAPTER 10</p>
<p class="Chapimage"><img src="../images/00008.jpeg" alt="image" class="calibre3"/></p>
<p class="ChapterTitle">Data Access</p>
<div class="calibre10"><p class="noindent">In chapter, you will learn how Spring can simplify your database access tasks (Spring can also simplify your NoSQL and BigData tasks, which is covered in <a href="part0023.html" class="calibre5">Chapter 13</a>). Data access is a common requirement for most enterprise applications, which usually require accessing data stored in relational databases. As an essential part of Java SE, Java Database Connectivity (JDBC)<a id="cXXX.2078" class="calibre5"></a> defines a set of standard APIs for you to access relational databases in a vendor-independent fashion.</p>
<p class="indent">The purpose of JDBC is to provide APIs<a id="cXXX.646" class="calibre5"></a> through which you can execute SQL statements against a database. However, when using JDBC, you have to manage database-related resources by yourself and handle database exceptions explicitly. To make JDBC easier to use, Spring provides an abstraction framework for interfacing with JDBC. As the heart of the Spring JDBC framework, JDBC templates are designed to provide template methods for different types of JDBC operations. Each template method is responsible for controlling the overall process and allows you to override particular tasks of the process.</p>
<p class="indent">If raw JDBC doesn’t satisfy your requirement or you feel your application would benefit from something slightly higher level, then Spring’s support for ORM solutions will interest you. In this chapter, you will also learn how to integrate <i class="calibre8">object/relational mapping (ORM)</i> frameworks into your Spring applications. Spring supports most of the popular ORM (or data mapper) frameworks, including Hibernate, JDO, iBATIS, and the Java Persistence API (JPA)<a id="cXXX.2087" class="calibre5"></a>. Classic TopLink isn’t supported starting from Spring 3.0 (the JPA implementation’s still supported, of course). However, the JPA support is varied and has support for many implementations of JPA, including the Hibernate and TopLink-based versions. The focus of this chapter will be on Hibernate and JPA. However, Spring’s support for ORM frameworks is consistent, so you can easily apply the techniques in this chapter to other ORM frameworks as well.</p>
<p class="indent">ORM is a modern technology for persisting objects into a relational database. An ORM framework persists your objects according to the mapping metadata you provide (XML- or annotation-based), such as the mappings between classes and tables, properties and columns, and so on. It generates SQL statements for object persistence at runtime, so you needn’t write database-specific SQL statements<a id="cXXX.647" class="calibre5"></a> unless you want to take advantage of database-specific features or provide optimized SQL statements of your own. As a result, your application will be database independent, and it can be easily migrated to another database in the future. Compared to the direct use of JDBC, an ORM framework can significantly reduce the data access effort of your applications.</p>
<p class="indent">Hibernate is a popular open-source and high-performance ORM framework in the Java community. Hibernate supports most JDBC-compliant databases and can use specific dialects to access particular databases. Beyond the basic ORM features, Hibernate supports more advanced features such as caching, cascading, and lazy loading. It also defines a querying language called Hibernate<a id="cXXX.648" class="calibre5"></a> Query Language (HQL<a id="cXXX.649" class="calibre5"></a>) for you to write simple but powerful object queries.</p>
<p class="indent">JPA<a id="cXXX.650" class="calibre5"></a> defines a set of standard annotations and APIs for object persistence in both the Java SE and Java EE platforms. JPA is defined as part of the EJB 3.0 specification in JSR-220. JPA is just a set of standard APIs that require a JPA-compliant engine to provide persistence services. You can compare JPA with the JDBC API and a JPA engine with a JDBC driver. Hibernate can be configured as a JPA-compliant engine through an extension module called Hibernate EntityManager<a id="cXXX.651" class="calibre5"></a>. This chapter will mainly demonstrate JPA with Hibernate as the underlying engine.</p>
<p id="Sec1" class="Heading">Problems with Direct JDBC<a id="cXXX.652" class="calibre6"></a></p>
<p class="noindent">Suppose you are<a id="cXXX.653" class="calibre5"></a> going to develop an application for vehicle registration, whose major functions are the basic create, read, update, and delete (CRUD) operations on vehicle records. These records will be stored in a relational database and accessed with JDBC. First, you design the following <span class="FontName">Vehicle</span> class<a id="cXXX.654" class="calibre5"></a>, which represents a vehicle in Java:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Vehicle {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private String vehicleNo;</span><br class="calibre10"/>    <span class="FontName">private String color;</span><br class="calibre10"/>    <span class="FontName">private int wheel;</span><br class="calibre10"/>    <span class="FontName">private int seat;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Constructors, Getters and Setters</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec2" class="Heading1">Setting Up the Application Database</p>
<p class="noindent">Before developing your vehicle registration application, you have to set up the database for it. For the sake of low memory consumption and easy configuration, I have chosen Apache Derby (<span class="FontName"><a href="http://db.apache.org/derby/" class="calibre5">http://db.apache.org/derby/</a></span>) as my database engine. Derby is an open-source relational database engine provided under the Apache License and implemented in pure Java.</p>
<p class="indent">Derby<a id="cXXX.655" class="calibre5"></a> can run in either the embedded mode or the client/server mode. For testing purposes, the client/server mode is more appropriate because it allows you to inspect and edit data with any visual database tools that support JDBC—for example, the Eclipse Data<a id="cXXX.656" class="calibre5"></a> Tools Platform (DTP<a id="cXXX.657" class="calibre5"></a>).</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To start the Derby server in the client/server mode, just execute the <span class="FontName">startNetworkServer</span> script for your platform (located in the <span class="FontName">bin</span> directory of the Derby installation).</p></div>
<p class="indent">After starting up the Derby network server on localhost, you can connect to it with the JDBC properties shown in <a id="_Tab1" href="part0020.html#Tab1" class="calibre5">Table 10-1</a>.</p>
<div class="Table" id="Tab1">
<p class="TabCapt"><span class="calibre4"><a href="part0020.html#_Tab1" class="calibre5">Table 10-1</a>.</span> JDBC Properties for Connecting to the Application Database<a id="cXXX.658" class="calibre5"></a></p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">Property</p></th><th valign="top" class="calibre14">
<p class="tab-left">Value</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">Driver class</p></td><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">org.apache.derby.jdbc.ClientDriver</span></p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">URL</p></td><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">jdbc:derby://localhost:1527/vehicle;create=true</span></p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">Username</p></td><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">app</span></p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">Password</p></td><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">app</span></p></td></tr></tbody></table>
</div>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  You require Derby’s client JDBC driver. If you are using Maven, add the following dependency to your project.</p>
<pre class="calibre19"><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.apache.derby&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;derbyclient&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;10.10.1.0&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span></pre></div>
<p class="indent">The first time you connect to this database, the database instance <span class="FontName">vehicle</span> will be created, if it did not exist before, because you specified <span class="FontName">create=true</span> in the URL. Note that the specification of this parameter will not cause the re-creation of the database if it already exists.</p>
<p class="indent">Follow these steps to connect to Derby:</p>
<ol class="OrderedList"><li value="1" class="calibre17">Open a shell on your platform.</li>
<li value="2" class="calibre17">Type <span class="FontName">java –jar $DERBY_HOME/lib/derbyrun.jar ij</span> on Unix variants or <span class="FontName">%DERBY_HOME%/lib/derbyrun.jar ij</span> on Windows.</li>
<li value="3" class="calibre17">Issue the command <span class="FontName">CONNECT 'jdbc:derby://localhost:1527/</span><br class="calibre10"/><span class="FontName">vehicle;create=true';</span>.</li></ol><p class="indent">You can provide any values for the username and password because Derby disables authentication by default. Next, you have to create the <span class="FontName">VEHICLE</span> table for storing vehicle records with the following SQL statement. By default, this table will be created in the <span class="FontName">APP</span> database s<span class="FontName">APP</span> database schema.</p>
<pre class="calibre11"><span class="FontName">CREATE TABLE VEHICLE (</span><br class="calibre10"/>    <span class="FontName">VEHICLE_NO    VARCHAR(10)    NOT NULL,</span><br class="calibre10"/>    <span class="FontName">COLOR         VARCHAR(10),</span><br class="calibre10"/>    <span class="FontName">WHEEL         INT,</span><br class="calibre10"/>    <span class="FontName">SEAT          INT,</span><br class="calibre10"/>    <span class="FontName">PRIMARY KEY (VEHICLE_NO)</span><br class="calibre10"/><span class="FontName">);</span></pre>
<p id="Sec3" class="Heading1">Understanding the Data Access Object Design Pattern<a id="cXXX.2025" class="calibre6"></a></p>
<p class="noindent">A typical design mistake made by inexperienced developers is to mix different types of logic (e.g., presentation logic, business logic, and data access logic) in a single large module. This reduces the module’s reusability and maintainability because of the tight coupling it introduces. The general purpose of the Data Access Object (DAO<a id="cXXX.659" class="calibre5"></a>) pattern is to avoid these problems by separating data access logic from business logic and presentation logic. This pattern recommends that data access logic be encapsulated in independent modules called data access objects.</p>
<p class="indent">For your vehicle registration application, you can abstract the data access operations to insert, update, delete, and query a vehicle. These operations should be declared in a DAO interface to allow for different DAO implementation technologies.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface VehicleDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void insert(Vehicle vehicle);</span><br class="calibre10"/>    <span class="FontName">public void update(Vehicle vehicle);</span><br class="calibre10"/>    <span class="FontName">public void delete(Vehicle vehicle);</span><br class="calibre10"/>    <span class="FontName">public Vehicle findByVehicleNo(String vehicleNo);</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Most parts of the JDBC APIs declare throwing <span class="FontName">java.sql.SQLException</span><a id="cXXX.660" class="calibre5"></a>. But because this interface aims to abstract the data access operations only, it should not depend on the implementation technology. So, it’s unwise for this general interface to declare throwing the JDBC-specific <span class="FontName">SQLException</span>. A common practice when implementing a DAO interface is to wrap this kind of exception with a runtime exception (either your own business <span class="FontName">Exception</span> subclass or a generic one).</p>
<p id="Sec4" class="Heading1">Implementing the DAO with JDBC</p>
<p class="noindent">To access the database with JDBC, you create an implementation for this DAO interface (e.g., <span class="FontName">JdbcVehicleDao</span>). Because your DAO implementation<a id="cXXX.661" class="calibre5"></a> has to connect to the database to execute SQL statements, you may establish database connections by specifying the driver class name, database URL, username, and password. However, in JDBC 2.0 or higher, you can obtain database connections from a preconfigured <span class="FontName">javax.sql.DataSource</span><a id="cXXX.662" class="calibre5"></a> object without knowing about the connection details.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.sql.Connection;</span><br class="calibre10"/><span class="FontName">import java.sql.PreparedStatement;</span><br class="calibre10"/><span class="FontName">import java.sql.ResultSet;</span><br class="calibre10"/><span class="FontName">import java.sql.SQLException;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.sql.DataSource;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private DataSource</span> <span class="FontName">dataSource</span><span class="FontName">;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setDataSource(DataSource dataSource) {</span><br class="calibre10"/>        <span class="FontName">this.dataSource = dataSource;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void insert(Vehicle vehicle) {</span><br class="calibre10"/>        <span class="FontName">String sql = "INSERT INTO VEHICLE (VEHICLE_NO, COLOR, WHEEL, SEAT) "</span><br class="calibre10"/>                <span class="FontName">+ "VALUES (?, ?, ?, ?)";</span><br class="calibre10"/>        <span class="FontName">Connection conn = null;</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">conn = dataSource.getConnection();</span><br class="calibre10"/>            <span class="FontName">PreparedStatement ps = conn.prepareStatement(sql);</span><br class="calibre10"/>            <span class="FontName">ps.setString(1, vehicle.getVehicleNo());</span><br class="calibre10"/>            <span class="FontName">ps.setString(2, vehicle.getColor());</span><br class="calibre10"/>            <span class="FontName">ps.setInt(3, vehicle.getWheel());</span><br class="calibre10"/>            <span class="FontName">ps.setInt(4, vehicle.getSeat());</span><br class="calibre10"/>            <span class="FontName">ps.executeUpdate();</span><br class="calibre10"/>            <span class="FontName">ps.close();</span><br class="calibre10"/>        <span class="FontName">} catch (SQLException e) {</span><br class="calibre10"/>            <span class="FontName">throw new RuntimeException(e);</span><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">if (conn != null) {</span><br class="calibre10"/>                <span class="FontName">try {</span><br class="calibre10"/>                    <span class="FontName">conn.close();</span><br class="calibre10"/>                <span class="FontName">} catch (SQLException e) {}</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Vehicle findByVehicleNo(String vehicleNo) {</span><br class="calibre10"/>        <span class="FontName">String sql = "SELECT * FROM VEHICLE WHERE VEHICLE_NO = ?";</span><br class="calibre10"/>        <span class="FontName">Connection conn = null;</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">conn = dataSource.getConnection();</span><br class="calibre10"/>            <span class="FontName">PreparedStatement ps = conn.prepareStatement(sql);</span><br class="calibre10"/>            <span class="FontName">ps.setString(1, vehicleNo);</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">Vehicle vehicle = null;</span><br class="calibre10"/>            <span class="FontName">ResultSet rs = ps.executeQuery();</span><br class="calibre10"/>            <span class="FontName">if (rs.next()) {</span><br class="calibre10"/>                <span class="FontName">vehicle = new Vehicle(rs.getString("VEHICLE_NO"),</span><br class="calibre10"/>                        <span class="FontName">rs.getString("COLOR"), rs.getInt("WHEEL"),</span><br class="calibre10"/>                        <span class="FontName">rs.getInt("SEAT"));</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>            <span class="FontName">rs.close();</span><br class="calibre10"/>            <span class="FontName">ps.close();</span><br class="calibre10"/>            <span class="FontName">return vehicle;</span><br class="calibre10"/>        <span class="FontName">} catch (SQLException e) {</span><br class="calibre10"/>            <span class="FontName">throw new RuntimeException(e);</span><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">if (conn != null) {</span><br class="calibre10"/>                <span class="FontName">try {</span><br class="calibre10"/>                    <span class="FontName">conn.close();</span><br class="calibre10"/>                <span class="FontName">} catch (SQLException e) {}</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void update(Vehicle vehicle) {/* ... */}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void delete(Vehicle vehicle) {/* ... */}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The vehicle insert operation is a typical JDBC update scenario. Each time this method is called, you obtain a connection from the data source and execute the SQL statement on this connection. Your DAO interface doesn’t declare throwing any checked exceptions, so if a <span class="FontName">SQLException</span> occurs, you have to wrap it with an unchecked <span class="FontName">RuntimeException</span><a id="cXXX.663" class="calibre5"></a>. (There is a detailed discussion on handling exceptions in your DAOs later in this chapter). Don’t forget to release the connection in the <span class="FontName">finally</span> block. Failing to do so may cause your application to run out of connections.</p>
<p class="indent">Here, the update and delete operations will be skipped, because they are much the same as the insert operation from a technical point of view. For the query operation, you have to extract the data from the returned result set to build a vehicle object in addition to executing the SQL statement.</p>
<p id="Sec5" class="Heading1">Configuring a Data Source in Spring</p>
<p class="noindent">The <span class="FontName">javax.sql.DataSource</span><a id="cXXX.664" class="calibre5"></a> interface is a standard interface defined by the JDBC specification that factories <span class="FontName">Connection</span> instances. There are many data source implementations provided by different vendors and projects: C3PO and Apache Commons DBCP are popular open source options, and most application servers will provide their own implementation. It is very easy to switch between different data source implementations, because they implement the common <span class="FontName">DataSource</span> interface. As a Java application framework, Spring also provides several convenient but less powerful data source implementations. The simplest one is <span class="FontName">DriverManagerDataSource</span><a id="cXXX.665" class="calibre5"></a>, which opens a new connection every time one is requested.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.vehicle.JdbcVehicleDao;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.vehicle.VehicleDao;</span><br class="calibre10"/><span class="FontName">import org.apache.derby.jdbc.ClientDriver;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.sql.DataSource;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class VehicleConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public VehicleDao vehicleDao() {</span><br class="calibre10"/>        <span class="FontName">return new JdbcVehicleDao(dataSource());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public DataSource dataSource() {</span><br class="calibre10"/>        <span class="FontName">DriverManagerDataSource dataSource = new DriverManagerDataSource();</span><br class="calibre10"/>        <span class="FontName">dataSource.setDriverClassName(ClientDriver.class.getName());</span><br class="calibre10"/>        <span class="FontName">dataSource.setUrl("jdbc:derby://localhost:1527/vehicle;create=true");</span><br class="calibre10"/>        <span class="FontName">dataSource.setUsername("app");</span><br class="calibre10"/>        <span class="FontName">dataSource.setPassword("app");</span><br class="calibre10"/>        <span class="FontName">return dataSource;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent"><span class="FontName">DriverManagerDataSource</span> is not an efficient data source implementation because it opens a new connection for the client every time it’s requested. Another data source implementation provided by Spring is <span class="FontName">SingleConnectionDataSource</span> (a <span class="FontName">DriverManagerDataSource</span> subclass). As its name indicates, this maintains only a single connection that’s reused all the time and never closed. Obviously, it is not suitable in a multithreaded environment.</p>
<p class="indent">Spring’s own data source implementations are mainly used for testing purposes. However, many production data source implementations support connection pooling. For example, the Database<a id="cXXX.666" class="calibre5"></a> Connection Pooling Services (DBCP<a id="cXXX.667" class="calibre5"></a>) module of the Apache Commons Library has several data source implementations that support connection pooling. Of these, <span class="FontName">BasicDataSource</span> accepts the same connection properties as <span class="FontName">DriverManagerDataSource</span> and allows you to specify the initial connection size and maximum active connections for the connection pool.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public DataSource dataSource() {</span><br class="calibre10"/>    <span class="FontName">BasicDataSource dataSource = new BasicDataSource();</span><br class="calibre10"/>    <span class="FontName">dataSource.setDriverClassName(ClientDriver.class.getName());</span><br class="calibre10"/>    <span class="FontName">dataSource.setUrl("jdbc:derby://localhost:1527/vehicle;create=true");</span><br class="calibre10"/>    <span class="FontName">dataSource.setUsername("app");</span><br class="calibre10"/>    <span class="FontName">dataSource.setPassword("app");</span><br class="calibre10"/>    <b class="calibre4">dataSource.setInitialSize(2);</b><br class="calibre10"/>    <b class="calibre4">dataSource.setMaxTotal(5);</b><br class="calibre10"/>    <span class="FontName">return dataSource;</span><br class="calibre10"/><span class="FontName">}</span></pre>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To use the data source implementations provided by DBCP, you have to add them to your CLASSPATH. If you are using Maven, add the following dependency to your project:</p>
<pre class="calibre19"><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;2.0&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span></pre></div>
<p class="indent">Many Java EE application servers build in data source implementations that you can configure from the server console or in configuration files. If you have a data source configured in an application server and exposed for JNDI lookup, you can use <span class="FontName">JndiDataSourceLookup</span><a id="cXXX.668" class="calibre5"></a> to look it up.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public DataSource dataSource() {</span><br class="calibre10"/>    <span class="FontName">return new JndiDataSourceLookup().getDataSource("jdbc/VehicleDS");</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec6" class="Heading1">Running the DAO</p>
<p class="noindent">The following <span class="FontName">Main</span> class<a id="cXXX.669" class="calibre5"></a> tests your DAO by using it to insert a new vehicle to the database. If it succeeds, you can query the vehicle from the database immediately.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context = new AnnotationConfigApplicationContext(VehicleConfiguration.class);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">VehicleDao vehicleDao = context.getBean(VehicleDao.class);</span><br class="calibre10"/>        <span class="FontName">Vehicle vehicle = new Vehicle("TEM0001", "Red", 4, 4);</span><br class="calibre10"/>        <span class="FontName">vehicleDao.insert(vehicle);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">vehicle = vehicleDao.findByVehicleNo("TEM0001");</span><br class="calibre10"/>        <span class="FontName">System.out.println("Vehicle No: " + vehicle.getVehicleNo());</span><br class="calibre10"/>        <span class="FontName">System.out.println("Color: " + vehicle.getColor());</span><br class="calibre10"/>        <span class="FontName">System.out.println("Wheel: " + vehicle.getWheel());</span><br class="calibre10"/>        <span class="FontName">System.out.println("Seat: " + vehicle.getSeat());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Now you can implement a DAO using JDBC directly. However, as you can see from the preceding DAO implementation, most of the JDBC code is similar and needs to be repeated for each database operation. Such redundant code will make your DAO methods much longer and less readable.</p>
<p id="Sec7" class="Heading1">Taking It a Step Further</p>
<p class="noindent">An alternative approach is to use an ORM<a id="cXXX.670" class="calibre5"></a> (an object/relational mapping) tool, which lets you code the logic specifically for mapping an entity in your domain model to a database table. The ORM will, in turn, figure out how to write the logic to usefully persist your class’s data to the database. This can be very liberating: you are suddenly beholden only to your business and domain model, not to whims of your database’s SQL parser. The flip side, of course, is that you are also divesting yourself from the complete control over the communication between your client and the database—you have to trust that the ORM layer will do the right thing.</p>
<p id="Sec8" class="Heading">10-1. Using a JDBC Template to Update a Database</p>
<p id="Sec9" class="Heading1">Problem</p>
<p class="noindent">Using JDBC is tedious and fraught with redundant API<a id="cXXX.671" class="calibre5"></a> calls, many of which could be managed for you. To implement a JDBC update operation, you have to perform the following tasks, most of which are redundant:</p>
<ol class="OrderedList"><li value="1" class="calibre17">Obtain a database connection from the data source.</li>
<li value="2" class="calibre17">Create a <span class="FontName">PreparedStatement</span> object from the connection.</li>
<li value="3" class="calibre17">Bind the parameters to the <span class="FontName">PreparedStatement</span> object.</li>
<li value="4" class="calibre17">Execute the <span class="FontName">PreparedStatement</span> object.</li>
<li value="5" class="calibre17">Handle <span class="FontName">SQLException</span>.</li>
<li value="6" class="calibre17">Clean <span class="FontName">up</span> the statement object and connection.</li></ol><p class="indent">JDBC is a very low-level API, but with the JDBC template, the surface area of the API that you need to work with becomes more expressive (you spend less time in the weeds and more time working on your application logic) and is simpler to work with safely.</p>
<p id="Sec10" class="Heading1">Solution</p>
<p class="noindent">The <span class="FontName">org.springframework.jdbc.core.JdbcTemplate</span> class declares a number of overloaded <span class="FontName">update()</span> template methods<a id="cXXX.672" class="calibre5"></a> to control the overall update process. Different versions of the <span class="FontName">update()</span> method allow you to override different task subsets of the default process. The Spring JDBC framework predefines several callback interfaces to encapsulate different task subsets. You can implement one of these callback interfaces and pass its instance to the corresponding <span class="FontName">update()</span> method to complete the process.</p>
<p id="Sec11" class="Heading1">How It Works</p>
<p id="Sec12" class="Heading2">Updating a Database with a Statement Creator</p>
<p class="noindent">The first callback interface to introduce is <span class="FontName">PreparedStatementCreator</span><a id="cXXX.673" class="calibre5"></a>. You implement this interface to override the statement creation task (task 2) and the parameter binding task (task 3) of the overall update process. To insert a vehicle into the database, you implement the <span class="FontName">PreparedStatementCreator</span> interface as follows:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.sql.Connection;</span><br class="calibre10"/><span class="FontName">import java.sql.PreparedStatement;</span><br class="calibre10"/><span class="FontName">import java.sql.SQLException;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.PreparedStatementCreator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class InsertVehicleStatementCreator implements PreparedStatementCreator {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Vehicle vehicle;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public InsertVehicleStatementCreator(Vehicle vehicle) {</span><br class="calibre10"/>        <span class="FontName">this.vehicle = vehicle;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public PreparedStatement createPreparedStatement(Connection con) throws SQLException {</span><br class="calibre10"/>        <span class="FontName">String sql = "INSERT INTO VEHICLE (VEHICLE_NO, COLOR, WHEEL, SEAT) VALUES (?, ?, ?, ?)";</span><br class="calibre10"/>        <span class="FontName">PreparedStatement ps = con.prepareStatement(sql);</span><br class="calibre10"/>        <span class="FontName">ps.setString(1, vehicle.getVehicleNo());</span><br class="calibre10"/>        <span class="FontName">ps.setString(2, vehicle.getColor());</span><br class="calibre10"/>        <span class="FontName">ps.setInt(3, vehicle.getWheel());</span><br class="calibre10"/>        <span class="FontName">ps.setInt(4, vehicle.getSeat());</span><br class="calibre10"/>        <span class="FontName">return ps;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">When implementing the <span class="FontName">PreparedStatementCreator</span> interface, you will get the database connection as the <span class="FontName">createPreparedStatement()</span> method’s argument. All you have to do in this method is to create a <span class="FontName">PreparedStatement</span> object on this connection and bind your parameters to this object. Finally, you have to return the <span class="FontName">PreparedStatement</span> object as the method’s return value. Notice that the method signature declares throwing <span class="FontName">SQLException</span>, which means that you don’t need to handle this kind of exception yourself.</p>
<p class="indent">Now, you can use this statement creator to simplify the vehicle insert operation. First of all, you have to create an instance of the <span class="FontName">JdbcTemplate</span> class<a id="cXXX.674" class="calibre5"></a> and pass in the data source for this template to obtain a connection from it. Then, you just make a call to the <span class="FontName">update()</span> method and pass in your statement creator for the template to complete the update process.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.JdbcTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public void insert(Vehicle vehicle) {</span><br class="calibre10"/>        <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br class="calibre10"/>        <span class="FontName">jdbcTemplate.update(new InsertVehicleStatementCreator(vehicle));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Typically, it is better to implement the <span class="FontName">PreparedStatementCreator</span> interface and other callback interfaces as inner classes if they are used within one method only. This is because you can get access to the local variables and method arguments directly from the inner class, instead of passing them as constructor arguments. The only constraint on such variables and arguments is that they must be declared as <span class="FontName">final</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.JdbcTemplate;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.PreparedStatementCreator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public void insert(final Vehicle vehicle) {</span><br class="calibre10"/>        <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">jdbcTemplate.update(new PreparedStatementCreator() {</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">public PreparedStatement createPreparedStatement(Connection conn)</span><br class="calibre10"/>                    <span class="FontName">throws SQLException {</span><br class="calibre10"/>                <span class="FontName">String sql = "INSERT INTO VEHICLE "</span><br class="calibre10"/>                        <span class="FontName">+ "(VEHICLE_NO, COLOR, WHEEL, SEAT) "</span><br class="calibre10"/>                        <span class="FontName">+ "VALUES (?, ?, ?, ?)";</span><br class="calibre10"/>                <span class="FontName">PreparedStatement ps = conn.prepareStatement(sql);</span><br class="calibre10"/>                <span class="FontName">ps.setString(1, vehicle.getVehicleNo());</span><br class="calibre10"/>                <span class="FontName">ps.setString(2, vehicle.getColor());</span><br class="calibre10"/>                <span class="FontName">ps.setInt(3, vehicle.getWheel());</span><br class="calibre10"/>                <span class="FontName">ps.setInt(4, vehicle.getSeat());</span><br class="calibre10"/>                <span class="FontName">return ps;</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">});</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Now, you can delete the preceding <span class="FontName">InsertVehicleStatementCreator</span> class<a id="cXXX.675" class="calibre5"></a>, because it will not be used anymore.</p>
<p id="Sec13" class="Heading2">Updating a Database with a Statement Setter</p>
<p class="noindent">The second callback interface, <span class="FontName">PreparedStatementSetter</span><a id="cXXX.676" class="calibre5"></a>, as its name indicates, performs only the parameter binding task (task 3) of the overall update process.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.JdbcTemplate;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.PreparedStatementSetter;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public void insert(final Vehicle vehicle) {</span><br class="calibre10"/>        <span class="FontName">String sql = "INSERT INTO VEHICLE (VEHICLE_NO, COLOR, WHEEL, SEAT) VALUES (?, ?, ?, ?)";</span><br class="calibre10"/>        <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">jdbcTemplate.update(sql, new PreparedStatementSetter() {</span><br class="calibre10"/><br class="calibre10"/>                    <span class="FontName">public void setValues(PreparedStatement ps)</span><br class="calibre10"/>                            <span class="FontName">throws SQLException {</span><br class="calibre10"/>                        <span class="FontName">ps.setString(1, vehicle.getVehicleNo());</span><br class="calibre10"/>                        <span class="FontName">ps.setString(2, vehicle.getColor());</span><br class="calibre10"/>                        <span class="FontName">ps.setInt(3, vehicle.getWheel());</span><br class="calibre10"/>                        <span class="FontName">ps.setInt(4, vehicle.getSeat());</span><br class="calibre10"/>                    <span class="FontName">}</span><br class="calibre10"/>                <span class="FontName">});</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Another version of the <span class="FontName">update()</span> template method accepts a SQL statement and a <span class="FontName">PreparedStatementSetter</span> object as arguments. This method will create a <span class="FontName">PreparedStatement</span> object for you from your SQL statement. All you have to do with this interface is to bind your parameters to the <span class="FontName">PreparedStatement</span> object.</p>
<p id="Sec14" class="Heading2">Updating a Database with a SQL<a id="cXXX.677" class="calibre6"></a> Statement and Parameter Values</p>
<p class="noindent">Finally, the simplest version of the <span class="FontName">update()</span> method<a id="cXXX.678" class="calibre5"></a> accepts a SQL statement and an object array as statement parameters. It will create a <span class="FontName">PreparedStatement</span> object from your SQL statement and bind the parameters for you. Therefore, you don’t have to override any of the tasks in the update process.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.JdbcTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public void insert(final Vehicle vehicle) {</span><br class="calibre10"/>        <span class="FontName">String sql = "INSERT INTO VEHICLE (VEHICLE_NO, COLOR, WHEEL, SEAT) VALUES (?, ?, ?, ?)";</span><br class="calibre10"/>        <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br class="calibre10"/><br class="calibre10"/>        <b class="calibre4">jdbcTemplate.update(sql, vehicle.getVehicleNo(),vehicle.getColor(),vehicle.getWheel(), vehicle.getSeat() );</b><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Of the three different versions of the <span class="FontName">update()</span> method introduced, the last is the simplest because you don’t have to implement any callback interfaces. Additionally, we’ve managed to remove all <span class="FontName">setX (setInt, setString, etc.)</span>–style methods for parameterizing the query. In contrast, the first is the most flexible because you can do any preprocessing of the <span class="FontName">PreparedStatement</span> object before its execution. In practice, you should always choose the simplest version that meets all your needs.</p>
<p class="indent">There are also other overloaded <span class="FontName">update()</span> methods provided by the <span class="FontName">JdbcTemplate</span> class<a id="cXXX.679" class="calibre5"></a>. Please refer to Javadoc for details.</p>
<p id="Sec15" class="Heading2">Batch Updating a Database</p>
<p class="noindent">Suppose you want to insert a batch of vehicles into the database. If you call the <span class="FontName">insert()</span> method multiple times, the update will be very slow as the SQL statement<a id="cXXX.2248" class="calibre5"></a> will be compiled repeatedly. So, it would be better to add a new method to the DAO interface for inserting a batch of vehicles.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public interface VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public void insertBatch(List&lt;Vehicle&gt; vehicles);</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The <span class="FontName">JdbcTemplate</span> class also offers the <span class="FontName">batchUpdate()</span> template method<a id="cXXX.680" class="calibre5"></a> for batch update operations. It requires a SQL statement and a <span class="FontName">BatchPreparedStatementSetter</span> object as arguments. In this method, the statement is compiled (prepared) only once and executed multiple times. If your database driver supports JDBC 2.0, this method automatically makes use of the batch update features to increase performance.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.BatchPreparedStatementSetter;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.JdbcTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public void insertBatch(final List&lt;Vehicle&gt; vehicles) {</span><br class="calibre10"/>        <span class="FontName">String sql = "INSERT INTO VEHICLE (VEHICLE_NO, COLOR, WHEEL, SEAT) VALUES (?, ?, ?, ?)";</span><br class="calibre10"/>        <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {</span><br class="calibre10"/><br class="calibre10"/>                    <span class="FontName">public int getBatchSize() {</span><br class="calibre10"/>                        <span class="FontName">return vehicles.size();</span><br class="calibre10"/>                    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>                    <span class="FontName">public void setValues(PreparedStatement ps, int i)</span><br class="calibre10"/>                            <span class="FontName">throws SQLException {</span><br class="calibre10"/>                        <span class="FontName">Vehicle vehicle = vehicles.get(i);</span><br class="calibre10"/>                        <span class="FontName">ps.setString(1, vehicle.getVehicleNo());</span><br class="calibre10"/>                        <span class="FontName">ps.setString(2, vehicle.getColor());</span><br class="calibre10"/>                        <span class="FontName">ps.setInt(3, vehicle.getWheel());</span><br class="calibre10"/>                        <span class="FontName">ps.setInt(4, vehicle.getSeat());</span><br class="calibre10"/>                    <span class="FontName">}</span><br class="calibre10"/>                <span class="FontName">});</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You can test your batch insert operation with the following code snippet in the <span class="FontName">Main</span> c<span class="FontName">Main</span> class<a id="cXXX.681" class="calibre5"></a>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">VehicleDao vehicleDao = (VehicleDao) context.getBean("vehicleDao");</span><br class="calibre10"/>        <span class="FontName">Vehicle vehicle1 = new Vehicle("TEM0002", "Blue", 4, 4);</span><br class="calibre10"/>        <span class="FontName">Vehicle vehicle2 = new Vehicle("TEM0003", "Black", 4, 6);</span><br class="calibre10"/>        <span class="FontName">vehicleDao.insertBatch(Arrays.asList(vehicle1, vehicle2));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec16" class="Heading">10-2. Using a JDBC Template to Query<a id="cXXX.682" class="calibre6"></a> a Database</p>
<p id="Sec17" class="Heading1">Problem</p>
<p class="noindent">To implement a JDBC query operation, you have to perform the following tasks, two of which (tasks 5 and 6) are additional as compared to an update operation:</p>
<ol class="OrderedList"><li value="1" class="calibre17">Obtain a database connection from the data source.</li>
<li value="2" class="calibre17">Create a <span class="FontName">PreparedStatement</span> object from the connection.</li>
<li value="3" class="calibre17">Bind the parameters to the <span class="FontName">PreparedStatement</span> object.</li>
<li value="4" class="calibre17">Execute the <span class="FontName">PreparedStatement</span> object.</li>
<li value="5" class="calibre17">Iterate the returned result set.</li>
<li value="6" class="calibre17">Extract data from the result set.</li>
<li value="7" class="calibre17">Handle <span class="FontName">SQLException</span>.</li>
<li value="8" class="calibre17">Clean up the statement object and connection.</li></ol><p class="indent">The only steps relevant to your business logic, however, are the definition of the query and the extraction of the results from the result set! The rest is better handled by the JDBC template.</p>
<p id="Sec18" class="Heading1">Solution</p>
<p class="noindent">The <span class="FontName">JdbcTemplate</span><a id="cXXX.683" class="calibre5"></a> class declares a number of overloaded <span class="FontName">query()</span> template methods to control the overall query process. You can override the statement creation (task 2) and the parameter binding (task 3) by implementing the <span class="FontName">PreparedStatementCreator</span> and <span class="FontName">PreparedStatementSetter</span><a id="cXXX.684" class="calibre5"></a> interfaces, just as you did for the update operations. Moreover, the Spring JDBC framework supports multiple ways for you to override the data extraction (task 6).</p>
<p id="Sec19" class="Heading1">How It Works</p>
<p id="Sec20" class="Heading2">Extracting Data with Row Callback Handler</p>
<p class="noindent"><span class="FontName">RowCallbackHandler</span><a id="cXXX.685" class="calibre5"></a> is the  is the primary interface that allows you to process the current row of the result set. One of the <span class="FontName">query()</span> methods iterates the result set for you and calls your <span class="FontName">RowCallbackHandler</span>  for each row. So, the <span class="FontName">processRow()</span> method<a id="cXXX.686" class="calibre5"></a> will be called once for each row of the returned result set.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.JdbcTemplate;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.RowCallbackHandler;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public Vehicle findByVehicleNo(String vehicleNo) {</span><br class="calibre10"/>        <span class="FontName">String sql = "SELECT * FROM VEHICLE WHERE VEHICLE_NO = ?";</span><br class="calibre10"/>        <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">final Vehicle vehicle = new Vehicle();</span><br class="calibre10"/>        <span class="FontName">jdbcTemplate.query(sql,</span><br class="calibre10"/>                <span class="FontName">new RowCallbackHandler() {</span><br class="calibre10"/>                    <span class="FontName">public void processRow(ResultSet rs) throws SQLException {</span><br class="calibre10"/>                        <span class="FontName">vehicle.setVehicleNo(rs.getString("VEHICLE_NO"));</span><br class="calibre10"/>                        <span class="FontName">vehicle.setColor(rs.getString("COLOR"));</span><br class="calibre10"/>                        <span class="FontName">vehicle.setWheel(rs.getInt("WHEEL"));</span><br class="calibre10"/>                        <span class="FontName">vehicle.setSeat(rs.getInt("SEAT"));</span><br class="calibre10"/>                    <span class="FontName">}</span><br class="calibre10"/>                <span class="FontName">}, vehicleNo);</span><br class="calibre10"/>        <span class="FontName">return vehicle;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">As there will be one row returned for the SQL query at maximum, you can create a vehicle object as a local variable and set its properties by extracting data from the result set. For a result set with more than one row, you should collect the objects as a list.</p>
<p id="Sec21" class="Heading2">Extracting Data with a Row Mapper</p>
<p class="noindent">The <span class="FontName">RowMapper&lt;T&gt;</span><a id="cXXX.687" class="calibre5"></a> interface is more general than <span class="FontName">RowCallbackHandler</span>. Its purpose is to map a single row of the result set to a customized object, so it can be applied to a single-row result set as well as a multiple-row result set. From the viewpoint of reuse, it’s better to implement the <span class="FontName">RowMapper&lt;T&gt;</span> interface as a normal class than as an inner class. In the <span class="FontName">mapRow()</span> method of this interface, you have to construct the object that represents a row and return it as the method’s return value.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.sql.ResultSet;</span><br class="calibre10"/><span class="FontName">import java.sql.SQLException;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.RowMapper;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class VehicleRowMapper implements RowMapper&lt;Vehicle&gt; {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Vehicle mapRow(ResultSet rs, int rowNum) throws SQLException {</span><br class="calibre10"/>        <span class="FontName">Vehicle vehicle = new Vehicle();</span><br class="calibre10"/>        <span class="FontName">vehicle.setVehicleNo(rs.getString("VEHICLE_NO"));</span><br class="calibre10"/>        <span class="FontName">vehicle.setColor(rs.getString("COLOR"));</span><br class="calibre10"/>        <span class="FontName">vehicle.setWheel(rs.getInt("WHEEL"));</span><br class="calibre10"/>        <span class="FontName">vehicle.setSeat(rs.getInt("SEAT"));</span><br class="calibre10"/>        <span class="FontName">return vehicle;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">As mentioned, <span class="FontName">RowMapper&lt;T&gt;</span> can be used for either a single-row or multiple-row result set. When querying for a unique object like in <span class="FontName">findByVehicleNo()</span>, you have to make a call to the <span class="FontName">queryForObject()</span><a id="cXXX.688" class="calibre5"></a> method of <span class="FontName">JdbcTemplate</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.JdbcTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public Vehicle findByVehicleNo(String vehicleNo) {</span><br class="calibre10"/>        <span class="FontName">String sql = "SELECT * FROM VEHICLE WHERE VEHICLE_NO = ?";</span><br class="calibre10"/>        <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br class="calibre10"/><br class="calibre10"/>        <b class="calibre4">return jdbcTemplate.queryForObject(sql, new VehicleRowMapper(), vehicleNo);</b><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Spring comes with a convenient <span class="FontName">RowMapper&lt;T&gt;</span> implementation, <span class="FontName">BeanPropertyRowMapper&lt;T&gt;</span>, which can automatically map a row to a new instance of the specified class. Note that the specified class must be a top-level class and must have a default or no-argument constructor. It first instantiates this class and then maps each column value to a property by matching their names. It supports matching a property name (e.g., <span class="FontName">vehicleNo</span>) to the same column name or the column name with underscores (e.g., <span class="FontName">VEHICLE_NO</span>).</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.JdbcTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">public Vehicle findByVehicleNo(String vehicleNo) {</span><br class="calibre10"/>       <span class="FontName">String sql = "SELECT * FROM VEHICLE WHERE VEHICLE_NO = ?";</span><br class="calibre10"/>       <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">return jdbcTemplate.queryForObject(sql,</span> <b class="calibre4">BeanPropertyRowMapper.newInstance(Vehicle.class)</b><span class="FontName">, vehicleNo);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec22" class="Heading2">Querying for Multiple Rows</p>
<p class="noindent">Now, let’s look at how to query for a result set with multiple rows. For example, suppose that you need a <span class="FontName">findAll()</span> method in the DAO interface to get all vehicles.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public interface VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public List&lt;Vehicle&gt; findAll();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Without the help of <span class="FontName">RowMapper&lt;T&gt;</span>, you can still call the <span class="FontName">queryForList()</span> method<a id="cXXX.689" class="calibre5"></a> and pass in a SQL statement. The returned result will be a list of maps. Each map stores a row of the result set with the column names as the keys.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.JdbcTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public List&lt;Vehicle&gt; findAll() {</span><br class="calibre10"/>        <span class="FontName">String sql = "SELECT * FROM VEHICLE";</span><br class="calibre10"/>        <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">List&lt;Vehicle&gt; vehicles = new ArrayList&lt;Vehicle&gt;();</span><br class="calibre10"/>        <span class="FontName">List&lt;Map&lt;String,Object&gt;&gt;rows = jdbcTemplate.queryForList(sql);</span><br class="calibre10"/>        <span class="FontName">for (Map&lt;String, Object&gt; row : rows) {</span><br class="calibre10"/>            <span class="FontName">Vehicle vehicle = new Vehicle();</span><br class="calibre10"/>            <span class="FontName">vehicle.setVehicleNo((String) row.get("VEHICLE_NO"));</span><br class="calibre10"/>            <span class="FontName">vehicle.setColor((String) row.get("COLOR"));</span><br class="calibre10"/>            <span class="FontName">vehicle.setWheel((Integer) row.get("WHEEL"));</span><br class="calibre10"/>            <span class="FontName">vehicle.setSeat((Integer) row.get("SEAT"));</span><br class="calibre10"/>            <span class="FontName">vehicles.add(vehicle);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">return vehicles;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You can test your <span class="FontName">findAll()</span> method<a id="cXXX.690" class="calibre5"></a> with the following code snippet in the <span class="FontName">Main</span> class:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">VehicleDao vehicleDao = (VehicleDao) context.getBean("vehicleDao");</span><br class="calibre10"/>        <span class="FontName">List&lt;Vehicle&gt; vehicles = vehicleDao.findAll();</span><br class="calibre10"/>        <span class="FontName">for (Vehicle vehicle : vehicles) {</span><br class="calibre10"/>            <span class="FontName">System.out.println("Vehicle No: " + vehicle.getVehicleNo());</span><br class="calibre10"/>            <span class="FontName">System.out.println("Color: " + vehicle.getColor());</span><br class="calibre10"/>            <span class="FontName">System.out.println("Wheel: " + vehicle.getWheel());</span><br class="calibre10"/>            <span class="FontName">System.out.println("Seat: " + vehicle.getSeat());</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you use a <span class="FontName">RowMapper&lt;T&gt;</span> object to map the rows in a result set, you will get a list of mapped objects from the <span class="FontName">query()</span> method.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.JdbcTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/>   <span class="FontName">...</span><br class="calibre10"/>  <span class="FontName">public List&lt;Vehicle&gt; findAll() {</span><br class="calibre10"/>     <span class="FontName">String sql = "SELECT * FROM VEHICLE";</span><br class="calibre10"/>     <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br class="calibre10"/>     <b class="calibre4">return jdbcTemplate.query (sql, BeanPropertyRowMapper.newInstance(Vehicle.class), vehicleNo);</b><br class="calibre10"/> <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec23" class="Heading2">Querying for a Single Value</p>
<p class="noindent">Finally, let’s consider to query for a single-row and single-column result set. As an example, add the following operations to the DAO interface<a id="cXXX.691" class="calibre5"></a>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public interface VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public String getColor(String vehicleNo);</span><br class="calibre10"/>    <span class="FontName">public int countAll();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">To query for a single string value, you can call the overloaded <span class="FontName">queryForObject()</span> method, which requires an argument of <span class="FontName">java.lang.Class</span> type<a id="cXXX.692" class="calibre5"></a>. This method will help you to map the result value to the type you specified.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.JdbcTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public String getColor(String vehicleNo) {</span><br class="calibre10"/>        <span class="FontName">String sql = "SELECT COLOR FROM VEHICLE WHERE VEHICLE_NO = ?";</span><br class="calibre10"/>        <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br class="calibre10"/><br class="calibre10"/>        <b class="calibre4">return jdbcTemplate.queryForObject(sql, String.class, vehicleNo);</b><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public int countAll() {</span><br class="calibre10"/>        <span class="FontName">String sql = "SELECT COUNT(*) FROM VEHICLE";</span><br class="calibre10"/>        <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br class="calibre10"/><br class="calibre10"/>        <b class="calibre4">return jdbcTemplate.queryForObject(sql, Integer.class);</b><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  Earlier versions of Spring provided the <span class="FontName">queryForInt</span> and <span class="FontName">queryForLong</span> methods, as of Spring 3.2 those methods are deprecated in favor of the <span class="FontName">queryForObject</span> method.</p></div>
<p class="indent">You can test these two methods with the following code snippet in the <span class="FontName">Main</span> class:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">VehicleDao vehicleDao = context.getBean(VehicleDao.class);</span><br class="calibre10"/>        <span class="FontName">int count = vehicleDao.countAll();</span><br class="calibre10"/>        <span class="FontName">System.out.println("Vehicle Count: " + count);</span><br class="calibre10"/>        <span class="FontName">String color = vehicleDao.getColor("TEM0001");</span><br class="calibre10"/>        <span class="FontName">System.out.println("Color for [TEM0001]: " +</span> <span class="FontName">color</span><span class="FontName">);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec24" class="Heading">10-3. Simplifying JDBC Template<a id="cXXX.693" class="calibre6"></a> Creation</p>
<p id="Sec25" class="Heading1">Problem</p>
<p class="noindent">It’s not efficient to create a new instance of <span class="FontName">JdbcTemplate</span> every time you use it, because you have to repeat the creation statement and incur the cost of creating a new object.</p>
<p id="Sec26" class="Heading1">Solution</p>
<p class="noindent">The <span class="FontName">JdbcTemplate</span> class is designed to be thread-safe, so you can declare a single instance of it in the IoC container and inject this instance into all your DAO instances. Furthermore, the Spring JDBC framework offers a convenient class, <span class="FontName">org.springframework.jdbc.core.support.JdbcDaoSupport</span>, to simplify your DAO implementation. This class declares a <span class="FontName">jdbcTemplate</span> property<a id="cXXX.694" class="calibre5"></a>, which can be injected from the IoC container or created automatically from a data source, for example, <span class="FontName">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource)</span>. Your DAO can extend this class to have this property inherited.</p>
<p id="Sec27" class="Heading1">How It Works</p>
<p id="Sec28" class="Heading2">Injecting a JDBC Template</p>
<p class="noindent">Until now, you have created a new instance of <span class="FontName">JdbcTemplate</span> in each DAO method. Actually, you can have it injected at the class level and use this injected instance in all DAO methods. For simplicity’s sake, the following code shows only the change to the <span class="FontName">insert()</span> method<a id="cXXX.695" class="calibre5"></a>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.JdbcTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao implements VehicleDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private final JdbcTemplate jdbcTemplate;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public JdbcVehicleDao (JdbcTemplate jdbcTemplate) {</span><br class="calibre10"/>        <span class="FontName">this.jdbcTemplate = jdbcTemplate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void insert(final Vehicle vehicle) {</span><br class="calibre10"/>        <span class="FontName">String sql = "INSERT INTO VEHICLE (VEHICLE_NO, COLOR, WHEEL, SEAT) "</span><br class="calibre10"/>                <span class="FontName">+ "VALUES (?, ?, ?, ?)";</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">jdbcTemplate.update(sql, new Object[] { vehicle.getVehicleNo(),</span><br class="calibre10"/>                <span class="FontName">vehicle.getColor(), vehicle.getWheel(), vehicle.getSeat() });</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">A JDBC template requires a data source to be set. You can inject this property by either a setter method or a constructor argument. Then, you can inject this JDBC template into your DAO<a id="cXXX.696" class="calibre5"></a>.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class VehicleConfiguration {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public VehicleDao vehicleDao() {</span><br class="calibre10"/>        <span class="FontName">return new JdbcVehicleDao(jdbcTemplate());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public JdbcTemplate jdbcTemplate() {</span><br class="calibre10"/>        <span class="FontName">return new JdbcTemplate(dataSource());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec29" class="Heading2">Extending the JdbcDaoSupport Class</p>
<p class="noindent">The <span class="FontName">org.springframework.jdbc.core.support.JdbcDaoSupport</span> class has  a <span class="FontName">setDataSource()</span> method and a <span class="FontName">setJdbcTemplate()</span> method. Your DAO class can extend this class to have these methods inherited. Then, you can either inject a JDBC template directly or inject a data source for it to create a JDBC template. The following code fragment is taken from Spring’s <span class="FontName">JdbcDaoSupport</span> class<a id="cXXX.697" class="calibre5"></a>:</p>
<pre class="calibre11"><span class="FontName">package org.springframework.jdbc.core.support;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public abstract class JdbcDaoSupport extends DaoSupport {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private JdbcTemplate jdbcTemplate;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public final void setDataSource(DataSource dataSource) {</span><br class="calibre10"/>       <span class="FontName">if( this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource() ){</span><br class="calibre10"/>         <span class="FontName">this.jdbcTemplate = createJdbcTemplate(dataSource);</span><br class="calibre10"/>         <span class="FontName">initTemplateConfig();</span><br class="calibre10"/>      <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>     <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) {</span><br class="calibre10"/>        <span class="FontName">this.jdbcTemplate = jdbcTemplate;</span><br class="calibre10"/>        <span class="FontName">initTemplateConfig();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public final JdbcTemplate getJdbcTemplate() {</span><br class="calibre10"/>        <span class="FontName">return this.jdbcTemplate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In your DAO methods, you can simply call the <span class="FontName">getJdbcTemplate()</span> method to retrieve the JDBC template. You also have to delete the <span class="FontName">dataSource</span> and <span class="FontName">jdbcTemplate</span> properties, as well as their setter methods, from your DAO class, because they have already been inherited. Again, for simplicity’s sake, only the change to the <span class="FontName">insert()</span> method is shown.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao extends JdbcDaoSupport implements VehicleDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void insert(final Vehicle vehicle) {</span><br class="calibre10"/>        <span class="FontName">String sql = "INSERT INTO VEHICLE (VEHICLE_NO, COLOR, WHEEL, SEAT) "</span><br class="calibre10"/>                <span class="FontName">+ "VALUES (?, ?, ?, ?)";</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">getJdbcTemplate().update(sql, new Object[] { vehicle.getVehicleNo(),</span><br class="calibre10"/>                <span class="FontName">vehicle.getColor(), vehicle.getWheel(), vehicle.getSeat() });</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">By extending <span class="FontName">JdbcDaoSupport</span>, your DAO class inherits the <span class="FontName">setDataSource()</span> method<a id="cXXX.698" class="calibre5"></a>. You can inject a data source into your DAO instance for it to create a JDBC template.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class VehicleConfiguration {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public VehicleDao vehicleDao() {</span><br class="calibre10"/>        <span class="FontName">JdbcVehicleDao vehicleDao = new JdbcVehicleDao();</span><br class="calibre10"/>        <span class="FontName">vehicleDao.setDataSource(dataSource());</span><br class="calibre10"/>        <span class="FontName">return</span> <span class="FontName">vehicleDao</span><span class="FontName">;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec30" class="Heading">10-4. Using Named Parameters in a JDBC Template</p>
<p id="Sec31" class="Heading1">Problem</p>
<p class="noindent">In classic JDBC usage, SQL<a id="cXXX.699" class="calibre5"></a> parameters are represented by the placeholder <span class="FontName">?</span> and are bound by position. The trouble with positional parameters is that whenever the parameter order is changed, you have to change the parameter bindings as well. For a SQL statement with many parameters, it is very cumbersome to match the parameters by position.</p>
<p id="Sec32" class="Heading1">Solution</p>
<p class="noindent">Another option when binding SQL parameters in the Spring JDBC framework is to use named parameters. As the term implies, named SQL parameters are specified by name (starting with a colon) rather than by position. Named parameters are easier to maintain and also improve readability. At runtime, the framework classes replace named parameters with placeholders. Named parameters are supported by the <span class="FontName">NamedParameterJdbcTemplate</span><a id="cXXX.700" class="calibre5"></a>.</p>
<p id="Sec33" class="Heading1">How It Works</p>
<p class="noindent">When using named parameters in your SQL statement, you can provide the parameter values in a map with the parameter names as the keys.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.namedparam.NamedParameterJdbcDaoSupport;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao extends</span> <b class="calibre4">NamedParameterJdbcDaoSupport</b> <span class="FontName">implements</span><br class="calibre10"/>        <span class="FontName">VehicleDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void insert(Vehicle vehicle) {</span><br class="calibre10"/>        <span class="FontName">String sql = "INSERT INTO VEHICLE (VEHICLE_NO, COLOR, WHEEL, SEAT) "</span><br class="calibre10"/>                <span class="FontName">+ "VALUES (:vehicleNo, :color, :wheel, :seat)";</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;();</span><br class="calibre10"/>        <span class="FontName">parameters.put("vehicleNo", vehicle.getVehicleNo());</span><br class="calibre10"/>        <span class="FontName">parameters.put("color", vehicle.getColor());</span><br class="calibre10"/>        <span class="FontName">parameters.put("wheel", vehicle.getWheel());</span><br class="calibre10"/>        <span class="FontName">parameters.put("seat", vehicle.getSeat());</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">getNamedParameterJdbcTemplate().update(sql, parameters);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You can also provide a SQL parameter source, whose responsibility is to offer SQL parameter values for named SQL parameters. There are three implementations of the <span class="FontName">SqlParameterSource</span> interface. The basic one is <span class="FontName">MapSqlParameterSource</span><a id="cXXX.701" class="calibre5"></a>, which wraps a map as its parameter source. In this example, this is a net-loss compared to the previous example, as we’ve introduced one extra object—the <span class="FontName">SqlParameterSource</span>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.namedparam.SqlParameterSource;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.namedparam.NamedParameterJdbcDaoSupport;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao extends NamedParameterJdbcDaoSupport implements</span><br class="calibre10"/>        <span class="FontName">VehicleDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void insert(Vehicle vehicle) {</span><br class="calibre10"/>        <span class="FontName">String sql = "INSERT INTO VEHICLE (VEHICLE_NO, COLOR, WHEEL, SEAT) "</span><br class="calibre10"/>                <span class="FontName">+ "VALUES (:vehicleNo, :color, :wheel, :seat)";</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;();</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">SqlParameterSource parameterSource =</span><br class="calibre10"/>            <span class="FontName">new MapSqlParameterSource(parameters);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">getNamedParameterJdbcTemplate().update(sql, parameterSource);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The power comes when we need an extra level of indirection between the parameters passed into the update method and the source of their values. For example, what if we want to get properties from a JavaBean? Here is where the <span class="FontName">SqlParameterSource</span> intermediary starts to benefit us! <span class="FontName">SqlParameterSource</span> is <span class="FontName">BeanPropertySqlParameterSource</span>, which wraps a normal Java object as a SQL parameter source. For each of the named parameters, the property with the same name will be used as the parameter value.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.namedparam.SqlParameterSource;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.namedparam.NamedParameterJdbcDaoSupport;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao extends NamedParameterJdbcDaoSupport implements</span><br class="calibre10"/>        <span class="FontName">VehicleDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void insert(Vehicle vehicle) {</span><br class="calibre10"/>        <span class="FontName">String sql = "INSERT INTO VEHICLE (VEHICLE_NO, COLOR, WHEEL, SEAT) "</span><br class="calibre10"/>                <span class="FontName">+ "VALUES (:vehicleNo, :color, :wheel, :seat)";</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">SqlParameterSource parameterSource =</span><br class="calibre10"/>            <span class="FontName">new BeanPropertySqlParameterSource(vehicle);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">getNamedParameterJdbcTemplate ().update(sql, parameterSource);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Named parameters can also be used in batch update. You can provide either a <span class="FontName">Map</span> array or a <span class="FontName">SqlParameterSource</span> array<a id="cXXX.702" class="calibre5"></a> for the parameter values.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.namedparam.SqlParameterSource;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.namedparam.NamedParameterJdbcDaoSupport;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcVehicleDao extends NamedParameterJdbcDaoSupport implements VehicleDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public void insertBatch(List&lt;Vehicle&gt; vehicles) {</span><br class="calibre10"/>        <span class="FontName">String sql = "INSERT INTO VEHICLE (VEHICLE_NO, COLOR, WHEEL, SEAT) "</span><br class="calibre10"/>                <span class="FontName">+ "VALUES (:vehicleNo, :color, :wheel, :seat)";</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">List&lt;SqlParameterSource&gt; parameters = new ArrayList&lt;SqlParameterSource&gt;();</span><br class="calibre10"/>        <span class="FontName">for (Vehicle vehicle : vehicles) {</span><br class="calibre10"/>            <span class="FontName">parameters.add(new BeanPropertySqlParameterSource(vehicle));</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">getNamedParameterJdbcTemplate ().batchUpdate(sql,</span><br class="calibre10"/>                <span class="FontName">parameters.toArray(new SqlParameterSource[paramters.size()]));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec34" class="Heading">10-5. Handling Exceptions in the Spring<a id="cXXX.703" class="calibre6"></a> JDBC Framework</p>
<p id="Sec35" class="Heading1">Problem</p>
<p class="noindent">Many of the JDBC APIs declare throwing <span class="FontName">java.sql.SQLException</span><a id="cXXX.704" class="calibre5"></a>, a checked exception that must be caught. It’s very troublesome to handle this kind of exception every time you perform a database operation. You often have to define your own policy to handle this kind of exception. Failure to do so may lead to inconsistent exception handling.</p>
<p id="Sec36" class="Heading1">Solution</p>
<p class="noindent">The Spring framework offers a consistent data access exception-handling mechanism for its data access module, including the JDBC framework. In general, all exceptions thrown by the Spring JDBC framework are subclasses of <span class="FontName">org.springframework.dao.DataAccessException</span>, a type of <span class="FontName">RuntimeException</span> that you are not forced to catch. It’s the root exception class for all exceptions in Spring’s data access module.</p>
<p class="indent"><a id="_Fig1" href="part0020.html#Fig1" class="calibre5">Figure 10-1</a> shows only part of the <span class="FontName">DataAccessException</span><a id="cXXX.705" class="calibre5"></a> hierarchy in Spring’s data access module. In total, there are more than 30 exception classes defined for different categories of data access exceptions.</p>
<div class="Figure" id="Fig1">
<p class="img1"><img src="../images/00067.jpeg" alt="9781430259084_Fig10-01.jpg" class="calibre3"/></p>
<p class="FigCapt"><span class="calibre4"><a href="part0020.html#_Fig1" class="calibre5">Figure 10-1</a>.</span> Common exception classes in the DataAccessException hierarchy</p></div>
<p id="Sec37" class="Heading1">How It Works</p>
<p id="Sec38" class="Heading2">Understanding Exception Handling in the Spring JDBC Framework</p>
<p class="noindent">Until now, you haven’t handled JDBC exceptions explicitly when using a JDBC template or JDBC operation objects. To help you understand the Spring JDBC framework’s exception-handling mechanism, let’s consider the following code fragment in the <span class="FontName">Main</span> class<a id="cXXX.706" class="calibre5"></a>, which inserts a vehicle. What happens if you insert a vehicle with a duplicate vehicle number?</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">VehicleDao vehicleDao = context.getBean(VehicleDao.class);</span><br class="calibre10"/>        <span class="FontName">Vehicle vehicle = new Vehicle("EX0001", "Green", 4, 4);</span><br class="calibre10"/>        <span class="FontName">vehicleDao.insert(vehicle);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you run the method twice, or the vehicle has already been inserted into the database, it will throw a <span class="FontName">DuplicateKeyException</span><a id="cXXX.707" class="calibre5"></a>, an indirect subclass of <span class="FontName">DataAccessException</span>. In your DAO methods, you neither need to surround the code with a try/catch block nor declare throwing an exception in the method signature. This is because <span class="FontName">DataAccessException</span> (and therefore its subclasses, including <span class="FontName">DuplicateKeyException</span>) is an unchecked exception that you are not forced to catch. The direct parent class of <span class="FontName">DataAccessException</span> is <span class="FontName">NestedRuntimeException</span><a id="cXXX.708" class="calibre5"></a>, a core Spring exception class that wraps another exception in a <span class="FontName">RuntimeException</span>.</p>
<p class="indent">When you use the classes of the Spring JDBC<a id="cXXX.2206" class="calibre5"></a> framework, they will catch <span class="FontName">SQLException</span> for you and wrap it with one of the subclasses of <span class="FontName">DataAccessException</span>. As this exception is a <span class="FontName">RuntimeException</span>, you are not required to catch it.</p>
<p class="indent">But how does the Spring JDBC framework know which concrete exception in the <span class="FontName">DataAccessException</span> hierarchy should be thrown? It’s by looking at the  <span class="FontName">errorCode</span> and <span class="FontName">SQLState</span> properties of the caught <span class="FontName">SQLException</span>. As a <span class="FontName">DataAccessException</span> wraps the underlying <span class="FontName">SQLException</span><a id="cXXX.709" class="calibre5"></a> as the root cause, you can inspect the <span class="FontName">errorCode</span> and <span class="FontName">SQLState</span> properties with the following catch block:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import java.sql.SQLException;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.dao.DataAccessException;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">VehicleDao vehicleDao = context.getBean(VehicleDao.class);</span><br class="calibre10"/>        <span class="FontName">Vehicle vehicle = new Vehicle("EX0001", "Green", 4, 4);</span><br class="calibre10"/>        <b class="calibre4">try {</b><br class="calibre10"/>            <span class="FontName">vehicleDao.insert(vehicle);</span><br class="calibre10"/>        <b class="calibre4">} catch (DataAccessException e) {</b><br class="calibre10"/>            <b class="calibre4">SQLException sqle = (SQLException) e.getCause();</b><br class="calibre10"/>            <b class="calibre4">System.out.println("Error code: " + sqle.getErrorCode());</b><br class="calibre10"/>            <b class="calibre4">System.out.println("SQL state: " + sqle.getSQLState());</b><br class="calibre10"/>        <b class="calibre4">}</b><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">When you insert the duplicate vehicle again, notice that Apache Derby returns the following error code and SQL state:</p>
<div class="thinline">
<pre class="calibre11"><span class="FontName">Error code : -1</span><br class="calibre10"/><span class="FontName">SQL state : 23505</span></pre></div>
<p class="indent">If you refer to the Apache Derby reference manual, you will find the error code description shown in <a id="_Tab2" href="part0020.html#Tab2" class="calibre5">Table 10-2</a>.</p>
<div class="Table" id="Tab2">
<p class="TabCapt"><span class="calibre4"><a href="part0020.html#_Tab2" class="calibre5">Table 10-2</a>.</span> Apache Derby’s<a id="cXXX.710" class="calibre5"></a> Error Code Description</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">SQL State</p></th><th valign="top" class="calibre14">
<p class="tab-left">Message Text</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">23505</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by ‘&lt;<i class="calibre8">value</i>&gt;’ defined on ‘&lt;<i class="calibre8">value</i>&gt;’.</p></td></tr></tbody></table>
</div>
<p class="indent">How does the Spring JDBC framework know that state <span class="FontName">23505</span> should be mapped to <span class="FontName">DuplicateKeyException</span>? The error code and SQL state<a id="cXXX.711" class="calibre5"></a> are database specific, which means different database products may return different codes for the same kind of error. Moreover, some database products will specify the error in the <span class="FontName">errorCode</span> property, while others (like Derby) will do so in the <span class="FontName">SQLState</span> property.</p>
<p class="indent">As an open Java application framework, Spring understands the error codes of most popular database products. Because of the large number of error codes, however, it can only maintain mappings for the most frequently encountered errors. The mapping is defined in the <span class="FontName">sql-error-codes.xml</span> file, located in the <span class="FontName">org.springframework.jdbc.support</span><a id="cXXX.712" class="calibre5"></a> package. The following snippet for Apache Derby is taken from this file:</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><span class="FontName">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 3.0//EN"</span><br class="calibre10"/>    <span class="FontName">"</span><span class="FontName"><a href="http://www.springframework.org/dtd/spring-beans-3.0.dtd" class="calibre5">http://www.springframework.org/dtd/spring-beans-3.0.dtd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;bean id="Derby" class="org.springframework.jdbc.support.SQLErrorCodes"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="databaseProductName"&gt;</span><br class="calibre10"/>                  <span class="FontName">&lt;value&gt;Apache Derby&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="useSqlStateForTranslation"&gt;</span><br class="calibre10"/>                  <span class="FontName">&lt;value&gt;true&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="badSqlGrammarCodes"&gt;</span><br class="calibre10"/>                  <span class="FontName">&lt;value&gt;42802,42821,42X01,42X02,42X03,42X04,42X05,42X06,42X07,42X08&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="duplicateKeyCodes"&gt;</span><br class="calibre10"/>                  <span class="FontName">&lt;value&gt;23505&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="dataIntegrityViolationCodes"&gt;</span><br class="calibre10"/>                  <span class="FontName">&lt;value&gt;22001,22005,23502,23503,23513,X0Y32&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="dataAccessResourceFailureCodes"&gt;</span><br class="calibre10"/>                  <span class="FontName">&lt;value&gt;04501,08004,42Y07&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="cannotAcquireLockCodes"&gt;</span><br class="calibre10"/>                  <span class="FontName">&lt;value&gt;40XL1&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;property name="deadlockLoserCodes"&gt;</span><br class="calibre10"/>                  <span class="FontName">&lt;value&gt;40001&lt;/value&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">Note that the <span class="FontName">databaseProductName</span> property<a id="cXXX.713" class="calibre5"></a> is used to match the database product name returned by <span class="FontName">Connection.getMetaData().</span><span class="FontName">getDatabaseProductName()</span><a id="cXXX.714" class="calibre5"></a>. This enables Spring to know which type of database is currently connecting. The <span class="FontName">useSqlStateForTranslation</span> property means that the <span class="FontName">SQLState</span> property, rather than the <span class="FontName">errorCode</span> property, should be used to match the error code. Finally, the <span class="FontName">SQLErrorCodes</span> class defines several categories for you to map database error codes. The code <span class="FontName">23505</span> lies in the <span class="FontName">dataIntegrityViolationCodes</span> c<span class="FontName">dataIntegrityViolationCodes</span> category.</p>
<p id="Sec39" class="Heading2">Customizing Data Access Exception Handling</p>
<p class="noindent">The Spring JDBC framework only maps well-known error codes. Sometimes, you may wish to customize the mapping yourself. For example, you might decide to add more codes to an existing category or define a custom exception for particular error codes.</p>
<p class="indent">In <a href="part0020.html#Tab2" class="calibre5">Table 10-2</a>, the error code <span class="FontName">23505</span> indicates a duplicate key error in Apache Derby. It is mapped by default to <span class="FontName">DataIntegrityViolationException</span><a id="cXXX.715" class="calibre5"></a>. Suppose that you want to create a custom exception type, <span class="FontName">MyDuplicateKeyException</span>, for this kind of error. It should extend <span class="FontName">DataIntegrityViolationException</span> because it is also a kind of data integrity violation error. Remember that for an exception to be thrown by the Spring JDBC framework, it must be compatible with the root exception class <span class="FontName">DataAccessException</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.vehicle;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.dao.DataIntegrityViolationException;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class MyDuplicateKeyException extends DataIntegrityViolationException {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public MyDuplicateKeyException(String msg) {</span><br class="calibre10"/>        <span class="FontName">super(msg);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public MyDuplicateKeyException(String msg, Throwable cause) {</span><br class="calibre10"/>        <span class="FontName">super(msg, cause);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">By default, Spring will look up an exception from the <span class="FontName">sql-error-codes.xml</span> file<a id="cXXX.716" class="calibre5"></a> located in the <span class="FontName">org.springframework.jdbc.support</span> package. However, you can override some of the mappings by providing a file with the same name in the root of the classpath. If Spring can find your custom file, it will look up an exception from your mapping first. However, if it does not find a suitable exception there, Spring will look up the default mapping.</p>
<p class="indent">For example, suppose that you want to map your custom <span class="FontName">DuplicateKeyException</span> type to error code <span class="FontName">23505</span>. You have to add the binding via a <span class="FontName">CustomSQLErrorCodesTranslation</span> bean, and then add this bean to the <span class="FontName">customTranslations</span> category.</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><span class="FontName">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"</span><br class="calibre10"/>    <span class="FontName">"</span><span class="FontName"><a href="http://www.springframework.org/dtd/spring-beans-2.0.dtd" class="calibre5">http://www.springframework.org/dtd/spring-beans-2.0.dtd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="Derby"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jdbc.support.SQLErrorCodes"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="databaseProductName"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;Apache Derby&lt;/value&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="useSqlStateForTranslation"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;true&lt;/value&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="customTranslations"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;list&gt;</span><br class="calibre10"/>                <span class="FontName">&lt;ref local="myDuplicateKeyTranslation" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/list&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="myDuplicateKeyTranslation"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jdbc.support.CustomSQLErrorCodesTranslation"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="errorCodes"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;23505&lt;/value&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="exceptionClass"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;value&gt;</span><br class="calibre10"/>                <span class="FontName">com.apress.springrecipes.vehicle.MyDuplicateKeyException</span><br class="calibre10"/>            <span class="FontName">&lt;/value&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">Now, if you remove the try/catch block surrounding the vehicle insert operation and insert a duplicate vehicle, the Spring JDBC framework will throw a <span class="FontName">MyDuplicateKeyException</span> instead.</p>
<p class="indent">However, if you are not satisfied with the basic code-to-exception mapping strategy used by the <span class="FontName">SQLErrorCodes</span> class, you may further implement the <span class="FontName">SQLExceptionTranslator</span> interface and inject its instance into a JDBC template via the <span class="FontName">setExceptionTranslator()</span> method<a id="cXXX.717" class="calibre5"></a>.</p>
<p id="Sec40" class="Heading">10-6. Problems with Using ORM<a id="cXXX.718" class="calibre6"></a> Frameworks Directly</p>
<p id="Sec41" class="Heading1">Problem</p>
<p class="noindent">You’ve decided to go to the next level—you have a sufficiently complex domain model, and manually writing all the code for each entity is getting tedious, so you begin to investigate a few alternatives, like Hibernate. You’re stunned to find that while they’re powerful, they can be anything but simple!</p>
<p id="Sec42" class="Heading1">Solution</p>
<p class="noindent">Let Spring lend a hand; it has facilities for dealing with ORM layers that rival those available for plain ol’ JDBC access<a id="cXXX.719" class="calibre5"></a>.</p>
<p id="Sec43" class="Heading1">How It Works</p>
<p class="noindent">Suppose you are developing a course management system for a training center. The first class you create for this system is <span class="FontName">Course</span>. This class is called an <i class="calibre8">entity class</i> or a <i class="calibre8">persistent</i> <i class="calibre8">class</i><a id="cXXX.720" class="calibre5"></a> because it represents a real-world entity and its instances will be persisted to a database. Remember that for each entity class to be persisted by an ORM framework, a default constructor with no argument is required.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Course {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Long id;</span><br class="calibre10"/>    <span class="FontName">private String title;</span><br class="calibre10"/>    <span class="FontName">private Date beginDate;</span><br class="calibre10"/>    <span class="FontName">private Date endDate;</span><br class="calibre10"/>    <span class="FontName">private int fee;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Constructors, Getters and Setters</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">For each entity class, you must define an identifier property to uniquely identify an entity. It’s a best practice to define an auto-generated identifier because this has no business meaning and thus won’t be changed under any circumstances. Moreover, this identifier will be used by the ORM framework to determine an entity’s state. If the identifier value is <span class="FontName">null</span>, this entity will be treated as a new and unsaved entity. When this entity is persisted, an insert SQL statement will be issued; otherwise, an update statement will. To allow the identifier to be <span class="FontName">null</span>, you should choose a primitive wrapper type like <span class="FontName">java.lang.Integer</span> and <span class="FontName">java.lang.Long</span> for the identifier.</p>
<p class="indent">In your course management system, you need a DAO interface to encapsulate the data access logic. Let’s define the following operations in the <span class="FontName">CourseDao</span> interface<a id="cXXX.721" class="calibre5"></a>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public interface CourseDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void store(Course course);</span><br class="calibre10"/>    <span class="FontName">public void delete(Long courseId);</span><br class="calibre10"/>    <span class="FontName">public Course findById(Long courseId);</span><br class="calibre10"/>    <span class="FontName">public List&lt;Course&gt; findAll();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Usually, when using ORM for persisting objects, the insert and update operations are combined into a single operation (e.g., store). This is to let the ORM framework (not you) decide whether an object should be inserted or updated.</p>
<p class="indent">In order for an ORM framework to persist your objects to a database, it must know the mapping metadata for the entity classes. You have to provide mapping metadata to it in its supported format. The native format for Hibernate is XML. However, because each ORM framework may have its own format for defining mapping metadata, JPA defines a set of persistent annotations for you to define mapping metadata in a standard format that is more likely to be reusable in other ORM frameworks.</p>
<p class="indent">Hibernate also supports the use of JPA<a id="cXXX.722" class="calibre5"></a> annotations to define mapping metadata, so there are essentially three different strategies for mapping and persisting your objects with Hibernate and JPA:</p>
<ul class="bulleted"><li class="calibre17">Using the Hibernate API to persist objects with Hibernate XML mappings</li>
<li class="calibre17">Using the Hibernate API to persist objects with JPA annotations</li>
<li class="calibre17">Using JPA to persist objects with JPA annotations</li></ul>
<p class="indent">The core programming elements of Hibernate, JPA, and other ORM frameworks resemble those of JDBC. They are summarized in <a id="_Tab3" href="part0020.html#Tab3" class="calibre5">Table 10-3</a><a id="cXXX.723" class="calibre5"></a>.</p>
<div class="Table" id="Tab3">
<p class="TabCapt"><span class="calibre4"><a href="part0020.html#_Tab3" class="calibre5">Table 10-3</a>.</span> Core Programming Elements for Different Data Access Strategies</p>
<p class="img1"><img src="../images/00068.jpeg" alt="Table10-3.jpg" class="calibre3"/></p></div>
<p class="indent">In Hibernate, the core interface for object persistence is <span class="FontName">Session</span>, whose instances can be obtained from a <span class="FontName">SessionFactory</span> instance. In JPA, the corresponding interface is <span class="FontName">EntityManager</span>, whose instances can be obtained from an <span class="FontName">EntityManagerFactory</span> instance. The exceptions thrown by Hibernate are of type <span class="FontName">HibernateException</span>, while those thrown by JPA may be of type <span class="FontName">PersistenceException</span> or other Java SE exceptions like <span class="FontName">IllegalArgumentException</span> and <span class="FontName">IllegalStateException</span>. Note that all these exceptions are subclasses of <span class="FontName">RuntimeException</span><a id="cXXX.724" class="calibre5"></a>, which you are not forced to catch and handle.</p>
<p id="Sec44" class="Heading1">Persisting Objects Using the Hibernate<a id="cXXX.725" class="calibre6"></a> API with Hibernate XML Mappings</p>
<p class="noindent">To map entity classes with Hibernate XML mappings, you can provide a single mapping file for each class or a large file for several classes. Practically, you should define one for each class by joining the class name with <span class="FontName">.hbm.xml</span> as the file extension for ease of maintenance. The middle extension <span class="FontName">hbm</span> stands for “Hibernate metadata<a id="cXXX.2055" class="calibre5"></a>.”</p>
<p class="indent">The mapping file for the <span class="FontName">Course</span> class should be named <span class="FontName">Course.hbm.xml</span><a id="cXXX.726" class="calibre5"></a> and put in the same package as the entity class.</p>
<pre class="calibre11"><span class="FontName">&lt;!DOCTYPE hibernate-mapping</span><br class="calibre10"/>    <span class="FontName">PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span><br class="calibre10"/>    <span class="FontName">"</span><span class="FontName"><a href="http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd" class="calibre5">http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;hibernate-mapping package="com.apress.springrecipes.course"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;class name="Course" table="COURSE"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;id name="id" type="long" column="ID"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;generator class="identity" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/id&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="title" type="string"&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;column name="TITLE" length="100" not-null="true" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="beginDate" type="date" column="BEGIN_DATE" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="endDate" type="date" column="END_DATE" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="fee" type="int" column="FEE" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/class&gt;</span><br class="calibre10"/><span class="FontName">&lt;/hibernate-mapping&gt;</span></pre>
<p class="indent">In the mapping file, you can specify a table name for this entity class and a table column for each simple property. You can also specify the column details such as column length, not-null constraints, and unique constraints. In addition, each entity must have an identifier defined, which can be generated automatically or assigned manually. In this example, the identifier will be generated using a table identity column.</p>
<p class="indent">Each application that uses Hibernate requires a global configuration file to configure properties such as the database settings (either JDBC connection properties or a data source’s JNDI name), the database dialect, the mapping metadata’s locations, and so on. When using XML mapping files to define mapping metadata, you have to specify the locations of the XML files. By default, Hibernate will read the <span class="FontName">hibernate.cfg.xml</span> file from the root of the classpath. The middle extension <span class="FontName">cfg</span> stands for “configuration.” If there is a <span class="FontName">hibernate.properties</span> file on the classpath, that file will be consulted first and overridden by <span class="FontName">hibernate.cfg.xml</span><a id="cXXX.727" class="calibre5"></a>.</p>
<pre class="calibre11"><span class="FontName">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br class="calibre10"/>    <span class="FontName">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span><br class="calibre10"/>    <span class="FontName">"</span><span class="FontName"><a href="http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd" class="calibre5">http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;hibernate-configuration&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;session-factory&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="connection.driver_class"&gt;</span><br class="calibre10"/>            <span class="FontName">org.apache.derby.jdbc.ClientDriver</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="connection.url"&gt;</span><br class="calibre10"/>            <span class="FontName">jdbc:derby://localhost:1527/course;create=true</span><br class="calibre10"/>        <span class="FontName">&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="connection.username"&gt;app&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="connection.password"&gt;app&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="dialect"&gt;org.hibernate.dialect.DerbyTenSevenDialect&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="show_sql"&gt;true&lt;/property&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">&lt;mapping resource="com/apress/springrecipes/course/Course.hbm.xml" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/session-factory&gt;</span><br class="calibre10"/><span class="FontName">&lt;/hibernate-configuration&gt;</span></pre>
<p class="indent">Before you can persist your objects, you have to create tables in a database schema to store the object data. When using an ORM framework like Hibernate, you usually needn’t design the tables by yourself. If you set the <span class="FontName">hbm2ddl.auto</span> property<a id="cXXX.728" class="calibre5"></a> to <span class="FontName">update</span>, Hibernate can help you to update the database schema and create the tables when necessary. Naturally, you shouldn’t enable this in production, but it can be a great speed boost for development.</p>
<p class="indent">Now, let’s implement the DAO<a id="cXXX.729" class="calibre5"></a> interface in the <span class="FontName">hibernate</span> subpackage using the plain Hibernate API. Before you call the Hibernate API for object persistence, you have to initialize a Hibernate session factory (e.g., in the constructor).</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course.hibernate;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.hibernate.Query;</span><br class="calibre10"/><span class="FontName">import org.hibernate.Session;</span><br class="calibre10"/><span class="FontName">import org.hibernate.SessionFactory;</span><br class="calibre10"/><span class="FontName">import org.hibernate.Transaction;</span><br class="calibre10"/><span class="FontName">import org.hibernate.cfg.Configuration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class HibernateCourseDao implements CourseDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private SessionFactory sessionFactory;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public HibernateCourseDao() {</span><br class="calibre10"/>        <span class="FontName">Configuration configuration = new Configuration().configure();</span><br class="calibre10"/>        <span class="FontName">sessionFactory = configuration.buildSessionFactory();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void store(Course course) {</span><br class="calibre10"/>        <span class="FontName">Session session = sessionFactory.openSession();</span><br class="calibre10"/>        <span class="FontName">Transaction tx = session.getTransaction();</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">tx.begin();</span><br class="calibre10"/>            <b class="calibre4">session.saveOrUpdate(course);</b><br class="calibre10"/>            <span class="FontName">tx.commit();</span><br class="calibre10"/>        <span class="FontName">} catch (RuntimeException e) {</span><br class="calibre10"/>            <span class="FontName">tx.rollback();</span><br class="calibre10"/>            <span class="FontName">throw e;</span><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">session.close();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void delete(Long courseId) {</span><br class="calibre10"/>        <span class="FontName">Session session = sessionFactory.openSession();</span><br class="calibre10"/>        <span class="FontName">Transaction tx = session.getTransaction();</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">tx.begin();</span><br class="calibre10"/>            <b class="calibre4">Course course = (Course) session.get(Course.class, courseId);</b><br class="calibre10"/>            <b class="calibre4">session.delete(course);</b><br class="calibre10"/>            <span class="FontName">tx.commit();</span><br class="calibre10"/>        <span class="FontName">} catch (RuntimeException e) {</span><br class="calibre10"/>            <span class="FontName">tx.rollback();</span><br class="calibre10"/>            <span class="FontName">throw e;</span><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">session.close();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Course findById(Long courseId) {</span><br class="calibre10"/>        <span class="FontName">Session session = sessionFactory.openSession();</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <b class="calibre4">return (Course) session.get(Course.class, courseId);</b><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">session.close();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public List&lt;Course&gt; findAll() {</span><br class="calibre10"/>        <span class="FontName">Session session = sessionFactory.openSession();</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <b class="calibre4">Query query = session.createQuery("from Course");</b><br class="calibre10"/>            <b class="calibre4">return query.list();</b><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">session.close();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The first step in using Hibernate is to create a <span class="FontName">Configuration</span> object and ask it to load the Hibernate configuration file. By default, it loads <span class="FontName">hibernate.cfg.xml</span> from the classpath root when you call the <span class="FontName">configure()</span> method<a id="cXXX.730" class="calibre5"></a>. Then, you build a Hibernate session factory from this <span class="FontName">Configuration</span> object. The purpose of a session factory is to produce sessions for you to persist your objects.</p>
<p class="indent">In the preceding DAO methods, you first open a session from the session factory. For any operation that involves database update, such as <span class="FontName">saveOrUpdate()</span> and <span class="FontName">delete()</span>, you must start a Hibernate transaction on that session. If the operation completes successfully, you commit the transaction. Otherwise, you roll it back if any <span class="FontName">RuntimeException</span><a id="cXXX.731" class="calibre5"></a> happens. For read-only operations such as <span class="FontName">get()</span> and HQL queries<a id="cXXX.2143" class="calibre5"></a>, there’s no need to start a transaction. Finally, you must remember to close a session to release the resources held by this session.</p>
<p class="indent">You can create the following <span class="FontName">Main</span> class to test run all the DAO methods. It also demonstrates an entity’s typical life cycle.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">CourseDao courseDao = new HibernateCourseDao();</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Course course = new Course();</span><br class="calibre10"/>        <span class="FontName">course.setTitle("Core Spring");</span><br class="calibre10"/>        <span class="FontName">course.setBeginDate(new GregorianCalendar(2007, 8, 1).getTime());</span><br class="calibre10"/>        <span class="FontName">course.setEndDate(new GregorianCalendar(2007, 9, 1).getTime());</span><br class="calibre10"/>        <span class="FontName">course.setFee(1000);</span><br class="calibre10"/>        <span class="FontName">courseDao.store(course);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">List&lt;Course&gt; courses = courseDao.findAll();</span><br class="calibre10"/>        <span class="FontName">Long courseId = courses.get(0).getId();</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">course = courseDao.findById(courseId);</span><br class="calibre10"/>        <span class="FontName">System.out.println("Course Title: " + course.getTitle());</span><br class="calibre10"/>        <span class="FontName">System.out.println("Begin Date: " + course.getBeginDate());</span><br class="calibre10"/>        <span class="FontName">System.out.println("End Date: " + course.getEndDate());</span><br class="calibre10"/>        <span class="FontName">System.out.println("Fee: " + course.getFee());</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">courseDao.delete(courseId);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec45" class="Heading1">Persisting Objects Using the Hibernate API with JPA<a id="cXXX.732" class="calibre6"></a> Annotations</p>
<p class="noindent">JPA annotations are standardized in the JSR-220 specification, so they’re supported by all JPA-compliant ORM frameworks, including Hibernate. Moreover, the use of annotations will be more convenient for you to edit mapping metadata in the same source file.</p>
<p class="indent">The following <span class="FontName">Course</span> class illustrates the use of JPA annotations to define mapping metadata<a id="cXXX.733" class="calibre5"></a>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import javax.persistence.Column;</span><br class="calibre10"/><span class="FontName">import javax.persistence.Entity;</span><br class="calibre10"/><span class="FontName">import javax.persistence.GeneratedValue;</span><br class="calibre10"/><span class="FontName">import javax.persistence.GenerationType;</span><br class="calibre10"/><span class="FontName">import javax.persistence.Id;</span><br class="calibre10"/><span class="FontName">import javax.persistence.Table;</span><br class="calibre10"/><br class="calibre10"/><b class="calibre4">@Entity</b><br class="calibre10"/><b class="calibre4">@Table(name = "COURSE")</b><br class="calibre10"/><span class="FontName">public class Course {</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Id</b><br class="calibre10"/>    <b class="calibre4">@GeneratedValue(strategy = GenerationType.IDENTITY)</b><br class="calibre10"/>    <b class="calibre4">@Column(name = "ID")</b><br class="calibre10"/>    <span class="FontName">private Long id;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Column(name = "TITLE", length = 100, nullable = false)</b><br class="calibre10"/>    <span class="FontName">private String title;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Column(name = "BEGIN_DATE")</b><br class="calibre10"/>    <span class="FontName">private Date beginDate;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Column(name = "END_DATE")</b><br class="calibre10"/>    <span class="FontName">private Date endDate;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Column(name = "FEE")</b><br class="calibre10"/>    <span class="FontName">private int fee;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// Constructors, Getters and Setters</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Each entity class must be annotated with the <span class="FontName">@Entity</span> annotation. You can assign a table name for an entity class in this annotation. For each property, you can specify a column name and column details using the <span class="FontName">@Column</span> annotation. Each entity class must have an identifier defined by the <span class="FontName">@Id</span> annotation. You can choose a strategy for identifier generation using the <span class="FontName">@GeneratedValue</span> annotation. Here, the identifier will be generated by a table identity column.</p>
<p class="indent">Hibernate supports both native XML mapping files and JPA annotations as ways of defining mapping metadata. For JPA annotations, you have to specify the fully qualified names of the entity classes in <span class="FontName">hibernate.cfg.xml</span><a id="cXXX.734" class="calibre5"></a> for Hibernate to read the annotations.</p>
<pre class="calibre11"><span class="FontName">&lt;hibernate-configuration&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;session-factory&gt;</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <b class="calibre4">&lt;mapping class="com.apress.springrecipes.course.Course" /&gt;</b><br class="calibre10"/>    <span class="FontName">&lt;/session-factory&gt;</span><br class="calibre10"/><span class="FontName">&lt;/hibernate-configuration&gt;</span></pre>
<p id="Sec46" class="Heading1">Persisting Objects Using JPA with Hibernate as the Engine</p>
<p class="noindent">In addition to persistent annotations, JPA defines a set of programming interfaces<a id="cXXX.735" class="calibre5"></a> for object persistence. However, JPA is not a persistence implementation; you have to pick up a JPA-compliant engine to provide persistence services. Hibernate can be JPA-compliant through the Hibernate EntityManager extension module. With this extension, Hibernate can work as an underlying JPA engine to persist objects. This lets you retain both the valuable investment in Hibernate (perhaps it’s faster or handles certain operations more to your satisfaction) and write code that is JPA-compliant and portable among other JPA engines. This can also be a useful way to transition a code base to JPA. New code is written strictly against the JPA APIs, and older code is transitioned to the JPA interfaces.</p>
<p class="indent">In a Java EE environment, you can configure the JPA engine in a Java EE container. But in a Java SE application, you have to set up the engine locally. The configuration of JPA is through the central XML file <span class="FontName">persistence.xml</span><a id="cXXX.736" class="calibre5"></a>, located in the <span class="FontName">META-INF</span> directory of the classpath root. In this file, you can set any vendor-specific properties for the underlying engine configuration.</p>
<p class="indent">Now, let’s create the JPA configuration file <span class="FontName">persistence.xml</span> in the <span class="FontName">META-INF</span> directory<a id="cXXX.737" class="calibre5"></a> of the classpath root. Each JPA configuration file contains one or more <span class="FontName">&lt;persistence-unit&gt;</span> elements. A <i class="calibre8">persistence unit</i> defines a set of persistent classes and how they should be persisted. Each persistence unit requires a name for identification. Here, you assign the name <span class="FontName">course</span> to this persistence unit.</p>
<pre class="calibre11"><span class="FontName">&lt;persistence  xmlns="</span><span class="FontName"><a href="http://java.sun.com/xml/ns/persistence" class="calibre5">http://java.sun.com/xml/ns/persistence</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://java.sun.com/xml/ns/persistence" class="calibre5">http://java.sun.com/xml/ns/persistence</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd" class="calibre5">http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">version="2.0"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;persistence-unit name="course"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;properties&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;property name="hibernate.ejb.cfgfile" value="/hibernate.cfg.xml" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/properties&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/persistence-unit&gt;</span><br class="calibre10"/><span class="FontName">&lt;/persistence&gt;</span></pre>
<p class="indent">In this JPA configuration file, you configure Hibernate as your underlying JPA engine by referring to the Hibernate configuration file located in the classpath root<a id="cXXX.738" class="calibre5"></a>. However, because Hibernate EntityManager will automatically detect XML mapping files and JPA annotations as mapping metadata, you have no need to specify them explicitly. Otherwise, you will encounter an <span class="FontName">org.hibernate.DuplicateMappingException</span><a id="cXXX.739" class="calibre5"></a>.</p>
<pre class="calibre11"><span class="FontName">&lt;hibernate-configuration&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;session-factory&gt;</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">&lt;!-- Don't need to specify mapping files and annotated classes --&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;!--</span><br class="calibre10"/>        <span class="FontName">&lt;mapping resource="com/apress/springrecipes/course/Course.hbm.xml" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;mapping class="com.apress.springrecipes.course.Course" /&gt;</span><br class="calibre10"/>        <span class="FontName">--&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/session-factory&gt;</span><br class="calibre10"/><span class="FontName">&lt;/hibernate-configuration&gt;</span></pre>
<p class="indent">As an alternative to referring to the Hibernate configuration file, you can also centralize all the Hibernate configurations in <span class="FontName">persistence.xml</span>.</p>
<pre class="calibre11"><span class="FontName">&lt;persistence ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;persistence-unit name="course"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;properties&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;property name="hibernate.connection.driver_class"</span><br class="calibre10"/>                      <span class="FontName">value="org.apache.derby.jdbc.ClientDriver" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;property name="hibernate.connection.url"</span><br class="calibre10"/>                      <span class="FontName">value="jdbc:derby://localhost:1527/course;create=true" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;property name="hibernate.connection.username" value="app" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;property name="hibernate.connection.password" value="app" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;property name="hibernate.dialect"</span><br class="calibre10"/>                      <span class="FontName">value="org.hibernate.dialect.DerbyTenSevenDialect" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;property name="hibernate.show_sql" value="true" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;property name="hibernate.hbm2ddl.auto" value="update" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/properties&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/persistence-unit&gt;</span><br class="calibre10"/><span class="FontName">&lt;/persistence&gt;'</span></pre>
<p class="indent">In a Java EE environment<a id="cXXX.740" class="calibre5"></a>, a Java EE container is able to manage the entity manager for you and inject it into your EJB components directly. But when you use JPA outside of a Java EE container (e.g., in a Java SE application), you have to create and maintain the entity manager by yourself.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To use Hibernate as the underlying JPA engine, you have to include the Hibernate Entity Manager libraries to your CLASSPATH. If you’re using Maven, add the following dependency to your project:</p>
<pre class="calibre19"><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;${hibernate.version}&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span></pre></div>
<p class="indent">Now, let’s implement the <span class="FontName">CourseDao</span> interface<a id="cXXX.741" class="calibre5"></a> using JPA in a Java SE application. Before you call JPA for object persistence, you have to initialize an entity manager factory. The purpose of an entity manager factory is to produce entity managers for you to persist your objects.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import javax.persistence.EntityManager;</span><br class="calibre10"/><span class="FontName">import javax.persistence.EntityManagerFactory;</span><br class="calibre10"/><span class="FontName">import javax.persistence.EntityTransaction;</span><br class="calibre10"/><span class="FontName">import javax.persistence.Persistence;</span><br class="calibre10"/><span class="FontName">import javax.persistence.Query;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JpaCourseDao implements CourseDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private EntityManagerFactory entityManagerFactory;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public JpaCourseDao() {</span><br class="calibre10"/>        <span class="FontName">entityManagerFactory = Persistence.createEntityManagerFactory("course");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void store(Course course) {</span><br class="calibre10"/>        <span class="FontName">EntityManager manager = entityManagerFactory.createEntityManager();</span><br class="calibre10"/>        <span class="FontName">EntityTransaction tx = manager.getTransaction();</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">tx.begin();</span><br class="calibre10"/>            <b class="calibre4">manager.merge(course);</b><br class="calibre10"/>            <span class="FontName">tx.commit();</span><br class="calibre10"/>        <span class="FontName">} catch (RuntimeException e) {</span><br class="calibre10"/>            <span class="FontName">tx.rollback();</span><br class="calibre10"/>            <span class="FontName">throw e;</span><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">manager.close();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void delete(Long courseId) {</span><br class="calibre10"/>        <span class="FontName">EntityManager manager = entityManagerFactory.createEntityManager();</span><br class="calibre10"/>        <span class="FontName">EntityTransaction tx = manager.getTransaction();</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">tx.begin();</span><br class="calibre10"/>            <b class="calibre4">Course course = manager.find(Course.class, courseId);</b><br class="calibre10"/>            <b class="calibre4">manager.remove(course);</b><br class="calibre10"/>            <span class="FontName">tx.commit();</span><br class="calibre10"/>        <span class="FontName">} catch (RuntimeException e) {</span><br class="calibre10"/>            <span class="FontName">tx.rollback();</span><br class="calibre10"/>            <span class="FontName">throw e;</span><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">manager.close();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public Course findById(Long courseId) {</span><br class="calibre10"/>        <span class="FontName">EntityManager manager = entityManagerFactory.createEntityManager();</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <b class="calibre4">return manager.find(Course.class, courseId);</b><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">manager.close();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public List&lt;Course&gt; findAll() {</span><br class="calibre10"/>        <span class="FontName">EntityManager manager = entityManagerFactory.createEntityManager();</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <b class="calibre4">Query query = manager.createQuery("select course from Course course");</b><br class="calibre10"/>            <b class="calibre4">return query.getResultList();</b><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">manager.close();</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The entity manager factory is built by the static method <span class="FontName">createEntityManagerFactory()</span><a id="cXXX.742" class="calibre5"></a> of the <span class="FontName">javax.persistence.Persistence</span> class. You have to pass in a persistence unit name defined in <span class="FontName">persistence.xml</span> for an entity manager factory.</p>
<p class="indent">In the preceding DAO methods, you first create an entity manager from the entity manager factory. For any operation that involves database update, such as <span class="FontName">merge()</span> and <span class="FontName">remove()</span>, you must start a JPA transaction on the entity manager. For read-only operations such as <span class="FontName">find()</span> and JPA queries, there’s no need to start a transaction. Finally, you must close an entity manager to release the resources.</p>
<p class="indent">You can test this DAO with the similar <span class="FontName">Main</span> class, but this time, you instantiate the JPA DAO implementation<a id="cXXX.743" class="calibre5"></a> instead.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">CourseDao courseDao = new JpaCourseDao();</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In the preceding DAO implementations for both Hibernate and JPA, there are only one or two lines that are different for each DAO method. The rest of the lines are boilerplate routine tasks that you have to repeat. Moreover, each ORM framework has its own API for local transaction management.</p>
<p id="Sec47" class="Heading">10-7. Configuring ORM Resource Factories in Spring</p>
<p id="Sec48" class="Heading1">Problem</p>
<p class="noindent">When using an ORM framework on its own, you have to configure its resource factory with its API. For Hibernate and JPA, you have to build a session factory and an entity manager factory from the native Hibernate API and JPA. You have no choice but to manage these objects manually, without Spring’s support.</p>
<p id="Sec49" class="Heading1">Solution</p>
<p class="noindent">Spring provides several factory beans for you to create a Hibernate session factory or a JPA entity manager factory as a singleton bean in the IoC container. These factories can be shared between multiple beans via dependency injection. Moreover, this allows the session factory and the entity manager factory<a id="cXXX.744" class="calibre5"></a> to integrate with other Spring data access facilities, such as data sources and transaction managers.</p>
<p id="Sec50" class="Heading1">How It Works</p>
<p id="Sec51" class="Heading2">Configuring a Hibernate Session Factory in Spring</p>
<p class="noindent">First of all, let’s modify <span class="FontName">HibernateCourseDao</span><a id="cXXX.745" class="calibre5"></a> to accept a session factory via dependency injection, instead of creating it directly with the native Hibernate API in the constructor.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course.hibernate;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.hibernate.SessionFactory;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class HibernateCourseDao implements CourseDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private SessionFactory sessionFactory;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setSessionFactory(SessionFactory sessionFactory) {</span><br class="calibre10"/>        <span class="FontName">this.sessionFactory = sessionFactory;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Now, let’s look at how to declare a session factory that uses XML mapping files<a id="cXXX.746" class="calibre5"></a> in Spring. For this purpose, you have to enable the XML mapping file definition in <span class="FontName">hibernate.cfg.xml</span> again.</p>
<pre class="calibre11"><span class="FontName">&lt;hibernate-configuration&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;session-factory&gt;</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">&lt;!-- For Hibernate XML mappings --&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;mapping resource="com/apress/springrecipes/course/Course.hbm.xml" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/session-factory&gt;</span><br class="calibre10"/><span class="FontName">&lt;/hibernate-configuration&gt;</span></pre>
<p class="indent">Then, you create a bean configuration file for using Hibernate as the ORM framework (e.g., <span class="FontName">beans-hibernate.xml</span> in the classpath root). You can declare a session factory that uses XML mapping files with the factory bean <span class="FontName">LocalSessionFactoryBean</span><a id="cXXX.747" class="calibre5"></a>. You can also declare a <span class="FontName">HibernateCourseDao</span> instance under Spring’s management.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.course.CourseDao;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.course.HibernateCourseDao;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.core.io.ClassPathResource;</span><br class="calibre10"/><span class="FontName">import org.springframework.orm.hibernate4.LocalSessionFactoryBean;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class CourseConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public CourseDao courseDao() {</span><br class="calibre10"/>        <span class="FontName">return new HibernateCourseDao(sessionfactory().getObject());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public LocalSessionFactoryBean sessionfactory() {</span><br class="calibre10"/>        <span class="FontName">LocalSessionFactoryBean sessionFactoryBean = new LocalSessionFactoryBean();</span><br class="calibre10"/>        <span class="FontName">sessionFactoryBean.setConfigLocation(new ClassPathResource("hibernate.cfg.xml"));</span><br class="calibre10"/>        <span class="FontName">return sessionFactoryBean;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Note that you can specify the <span class="FontName">configLocation</span> property<a id="cXXX.748" class="calibre5"></a> for this factory bean to load the Hibernate configuration file. The <span class="FontName">configLocation</span> property is of type <span class="FontName">Resource</span>, and we want to load the file from the classpath, hence we construct a <span class="FontName">ClassPathResource</span> with the name of the configuration file. The preceding factory bean loads the configuration file from the root of the classpath.</p>
<p class="indent">Now, you can modify the <span class="FontName">Main</span> class to retrieve the <span class="FontName">HibernateCourseDao</span> instance from the Spring IoC container.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context = new AnnotationConfigApplicationContext(CourseConfiguration.class);</span><br class="calibre10"/>        <span class="FontName">CourseDao courseDao = context.getBean(CourseDao.class);</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The preceding factory bean creates a session factory by loading the Hibernate configuration file, which includes the database settings (either JDBC connection properties or a data source’s JNDI name). Now, suppose you have a data source defined in the Spring IoC container. If you want to use this data source for your session factory, you can inject it into the <span class="FontName">dataSource</span> property of <span class="FontName">LocalSessionFactoryBean</span>. The data source specified in this property will override the database settings in the Hibernate configuration file. If this is set, the Hibernate settings should not define a connection provider to avoid meaningless double configuration.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class CourseConfiguration {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public LocalSessionFactoryBean sessionfactory() {</span><br class="calibre10"/>        <span class="FontName">LocalSessionFactoryBean sessionFactoryBean = new LocalSessionFactoryBean();</span><br class="calibre10"/>        <b class="calibre4">sessionFactoryBean.setDataSource(dataSource());</b><br class="calibre10"/>        <span class="FontName">sessionFactoryBean.setConfigLocation(new ClassPathResource("hibernate.cfg.xml"));</span><br class="calibre10"/>        <span class="FontName">return sessionFactoryBean;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public DataSource dataSource() {</span><br class="calibre10"/>        <span class="FontName">SimpleDriverDataSource dataSource = new SimpleDriverDataSource();</span><br class="calibre10"/>        <span class="FontName">dataSource.setDriverClass(ClientDriver.class);</span><br class="calibre10"/>        <span class="FontName">dataSource.setUrl("jdbc:derby://localhost:1527/course;create=true");</span><br class="calibre10"/>        <span class="FontName">dataSource.setUsername("app");</span><br class="calibre10"/>        <span class="FontName">dataSource.setPassword("app");</span><br class="calibre10"/>        <span class="FontName">return dataSource;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Or you can even ignore the Hibernate configuration file by merging all the configurations into <span class="FontName">LocalSessionFactoryBean</span>. For example, you can specify the packages containing the JPA annotated classes in the <span class="FontName">packagesToScan</span> property<a id="cXXX.749" class="calibre5"></a> and other Hibernate properties such as the database dialect in the <span class="FontName">hibernateProperties</span> property.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class CourseConfiguration {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public LocalSessionFactoryBean sessionfactory() {</span><br class="calibre10"/>        <span class="FontName">LocalSessionFactoryBean sessionFactoryBean = new LocalSessionFactoryBean();</span><br class="calibre10"/>        <span class="FontName">sessionFactoryBean.setDataSource(dataSource());</span><br class="calibre10"/>        <span class="FontName">sessionFactoryBean.setPackagesToScan("com.apress.springrecipes.course");</span><br class="calibre10"/>        <span class="FontName">sessionFactoryBean.setHibernateProperties(hibernateProperties());</span><br class="calibre10"/>        <span class="FontName">return sessionFactoryBean;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private Properties hibernateProperties() {</span><br class="calibre10"/>        <span class="FontName">Properties properties = new Properties();</span><br class="calibre10"/>        <span class="FontName">properties.put("hibernate.dialect", org.hibernate.dialect.DerbyTenSevenDialect.class.getName());</span><br class="calibre10"/>        <span class="FontName">properties.put("hibernate.show_sql", true);</span><br class="calibre10"/>        <span class="FontName">properties.put("hibernate.hbm2dll.auto", "update");</span><br class="calibre10"/>        <span class="FontName">return properties;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you are in a project that still uses Hibernate mapping files you can use the <span class="FontName">mappingLocations</span> property to specify the mapping files. <span class="FontName">LocalSessionFactoryBean</span> also allows you take advantage of Spring’s resource-loading support to load mapping files from various types of locations. You can specify the resource paths of the mapping files in the <span class="FontName">mappingLocations</span> property<a id="cXXX.750" class="calibre5"></a>, whose type is <span class="FontName">Resource[]</span>.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public LocalSessionFactoryBean sessionfactory() {</span><br class="calibre10"/>    <span class="FontName">LocalSessionFactoryBean sessionFactoryBean = new LocalSessionFactoryBean();</span><br class="calibre10"/>    <span class="FontName">sessionFactoryBean.setDataSource(dataSource());</span><br class="calibre10"/>    <span class="FontName">sessionFactoryBean.setMappingLocations(</span><br class="calibre10"/>       <span class="FontName">new ClassPathResource("com/apress/springrecipes/course/Course.hbm.xml "));</span><br class="calibre10"/>    <span class="FontName">sessionFactoryBean.setHibernateProperties(hibernateProperties());</span><br class="calibre10"/>    <span class="FontName">return sessionFactoryBean;</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">With Spring’s resource-loading support, you can also use wildcards in a resource path to match multiple mapping files so that you don’t need to configure their locations every time you add a new entity class. For this to work we need a <span class="FontName">ResourcePatternResolver</span> in our configuration class.  We can get this by using the <span class="FontName">ResourcePatternUtils</span> and the <span class="FontName">ResourceLoaderAware</span> interface. We implement the latter and use the <span class="FontName">getResourcePatternResolver</span> method to get a <span class="FontName">ResourcePatternResolver</span> based on the <span class="FontName">ResourceLoader</span>.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class CourseConfiguration implements ResourceLoaderAware {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private ResourcePatternResolver resourcePatternResolver;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Override</span><br class="calibre10"/>    <span class="FontName">public void setResourceLoader(ResourceLoader resourceLoader) {</span><br class="calibre10"/>        <span class="FontName">this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Now we can use the <span class="FontName">ResourecePatternResolver</span><a id="cXXX.751" class="calibre5"></a> to resolve resource patterns to resources.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public LocalSessionFactoryBean sessionfactory() throws IOException {</span><br class="calibre10"/>    <span class="FontName">LocalSessionFactoryBean sessionFactoryBean = new LocalSessionFactoryBean();</span><br class="calibre10"/>    <b class="calibre4">Resource[] mappingResources =</b><br class="calibre10"/>        <b class="calibre4">resourcePatternResolver.getResources("classpath:com/apress/springrecipes/course/*.hbm.xml");</b><br class="calibre10"/>    <b class="calibre4">sessionFactoryBean.setMappingLocations(mappingResources);</b><br class="calibre10"/>    <b class="calibre4">...</b><br class="calibre10"/>    <span class="FontName">return sessionFactoryBean;</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You can now delete the Hibernate configuration file (i.e., <span class="FontName">hibernate.cfg.xml</span>) because its configurations have been ported to Spring.</p>
<p id="Sec52" class="Heading2">Configuring a JPA Entity Manager Factory in Spring</p>
<p class="noindent">First of all, let’s modify <span class="FontName">JpaCourseDao</span><a id="cXXX.752" class="calibre5"></a> to accept an entity manager factory via dependency injection, instead of creating it directly in the constructor.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import javax.persistence.EntityManagerFactory;</span><br class="calibre10"/><span class="FontName">import javax.persistence.Persistence;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JpaCourseDao implements CourseDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private final EntityManagerFactory entityManagerFactory;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public JpaCourseDao (EntityManagerFactory entityManagerFactory) {</span><br class="calibre10"/>        <span class="FontName">this.entityManagerFactory = entityManagerFactory;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The JPA specification defines how you should obtain an entity manager factory in Java SE and Java EE environments. In a Java SE environment, an entity manager factory is created manually by calling the <span class="FontName">createEntityManagerFactory()</span> static method of the <span class="FontName">Persistence</span> class.</p>
<p class="indent">Let’s create a bean configuration file for using JPA. Spring provides a factory bean, <span class="FontName">LocalEntityManagerFactoryBean</span><a id="cXXX.753" class="calibre5"></a>, for you to create an entity manager factory in the IoC container. You must specify the persistence unit name defined in the JPA configuration file. You can also declare a <span class="FontName">JpaCourseDao</span> instance under Spring’s management.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.course.CourseDao;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.course.JpaCourseDao;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class CourseConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public CourseDao courseDao() {</span><br class="calibre10"/>        <span class="FontName">return new JpaCourseDao(entityManagerFactory().getObject());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public LocalContainerEntityManagerFactoryBean entityManagerFactory() {</span><br class="calibre10"/>        <span class="FontName">LocalContainerEntityManagerFactoryBean emf = new LocalContainerEntityManagerFactoryBean();</span><br class="calibre10"/>        <span class="FontName">emf.setPersistenceUnitName("course");</span><br class="calibre10"/>        <span class="FontName">return emf;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Now, you can test this <span class="FontName">JpaCourseDao</span> instance with the <span class="FontName">Main</span> class by retrieving it from the Spring IoC container.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context = new AnnotationConfigApplicationContext(CourseConfiguration.class);</span><br class="calibre10"/>        <span class="FontName">CourseDao courseDao = context.getBean(CourseDao.class);</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In a Java EE environment, you can look up an entity manager factory from a Java EE container with JNDI. In Spring, you can perform a JNDI lookup by using the <span class="FontName">JndiLocatorDelegate</span> object<a id="cXXX.754" class="calibre5"></a> (which is simpler than constructing a <span class="FontName">JndiObjectFactoryBean</span> which would also work).</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public EntityManagerFactory entityManagerFactory() throws NamingException {</span><br class="calibre10"/>    <span class="FontName">return JndiLocatorDelegate.createDefaultResourceRefLocator()</span><br class="calibre10"/>            <span class="FontName">.lookup("jpa/coursePU", EntityManagerFactory.class);</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent"><span class="FontName">LocalEntityManagerFactoryBean</span> creates an entity manager factory by loading the JPA configuration file (i.e., <span class="FontName">persistence.xml</span>). Spring supports a more flexible way to create an entity manager factory by another factory bean, <span class="FontName">LocalContainerEntityManagerFactoryBean</span>. It allows you to override some of the configurations in the JPA configuration file, such as the data source and database dialect. So, you can take advantage of Spring’s data access facilities to configure the entity manager factory.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class CourseConfiguration {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public LocalContainerEntityManagerFactoryBean entityManagerFactory() {</span><br class="calibre10"/>        <span class="FontName">LocalContainerEntityManagerFactoryBean emf = new LocalContainerEntityManagerFactoryBean();</span><br class="calibre10"/>        <span class="FontName">emf.setPersistenceUnitName("course");</span><br class="calibre10"/>        <span class="FontName">emf.setDataSource(dataSource());</span><br class="calibre10"/>        <span class="FontName">emf.setJpaVendorAdapter(jpaVendorAdapter());</span><br class="calibre10"/>        <span class="FontName">return emf;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private JpaVendorAdapter jpaVendorAdapter() {</span><br class="calibre10"/>        <span class="FontName">HibernateJpaVendorAdapter jpaVendorAdapter = new HibernateJpaVendorAdapter();</span><br class="calibre10"/>        <span class="FontName">jpaVendorAdapter.setShowSql(true);</span><br class="calibre10"/>        <span class="FontName">jpaVendorAdapter.setGenerateDdl(true);</span><br class="calibre10"/>        <span class="FontName">jpaVendorAdapter.setDatabasePlatform(DerbyTenSevenDialect.class.getName());</span><br class="calibre10"/>        <span class="FontName">return jpaVendorAdapter;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public DataSource dataSource() {</span><br class="calibre10"/>        <span class="FontName">SimpleDriverDataSource dataSource = new SimpleDriverDataSource();</span><br class="calibre10"/>        <span class="FontName">dataSource.setDriverClass(ClientDriver.class);</span><br class="calibre10"/>        <span class="FontName">dataSource.setUrl("jdbc:derby://localhost:1527/course;create=true");</span><br class="calibre10"/>        <span class="FontName">dataSource.setUsername("app");</span><br class="calibre10"/>        <span class="FontName">dataSource.setPassword("app");</span><br class="calibre10"/>        <span class="FontName">return dataSource;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In the preceding bean configurations, you inject a data source into this entity manager factory. It will override the database settings in the JPA configuration file. You can set a JPA vendor adapter to <span class="FontName">LocalContainerEntityManagerFactoryBean</span> to specify JPA engine–specific properties. With Hibernate as the underlying JPA engine, you should choose <span class="FontName">HibernateJpaVendorAdapter</span><a id="cXXX.755" class="calibre5"></a>. Other properties that are not supported by this adapter can be specified in the <span class="FontName">jpaProperties</span> property.</p>
<p class="indent">Now your JPA configuration file (i.e., <span class="FontName">persistence.xml</span>) can be simplified as follows because its configurations have been ported to Spring:</p>
<pre class="calibre11"><span class="FontName">&lt;persistence ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;persistence-unit name="course" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/persistence&gt;</span></pre>
<p class="indent">Spring also makes it possible to configure the JPA <span class="FontName">EntityManagerFactory</span> without a <span class="FontName">persistence.xml</span> if we want we can fully configure it in a Spring configuration file. Instead of a <span class="FontName">persistenceUnitName</span> we need to specify the <span class="FontName">packagesToScan</span><a id="cXXX.756" class="calibre5"></a> property. After this we can remove the <span class="FontName">persistence.xml</span> completely.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public LocalContainerEntityManagerFactoryBean entityManagerFactory() {</span><br class="calibre10"/>    <span class="FontName">LocalContainerEntityManagerFactoryBean emf = new LocalContainerEntityManagerFactoryBean();</span><br class="calibre10"/>    <span class="FontName">emf.setDataSource(dataSource());</span><br class="calibre10"/>    <b class="calibre4">emf.setPackagesToScan("com.apress.springrecipes.course");</b><br class="calibre10"/>    <span class="FontName">emf.setJpaVendorAdapter(jpaVendorAdapter());</span><br class="calibre10"/>    <span class="FontName">return</span> <span class="FontName">emf</span><span class="FontName">;</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec53" class="Heading">10-8. Persisting Objects with Spring’s ORM Templates<a id="cXXX.2247" class="calibre6"></a></p>
<p id="Sec54" class="Heading1">Problem</p>
<p class="noindent">When using an ORM framework on its own, you have to repeat certain routine tasks for each DAO operation. For example, in a DAO operation implemented with Hibernate or JPA, you have to open and close a session or an entity manager, and begin, commit, and roll back a transaction with the native API.</p>
<p id="Sec55" class="Heading1">Solution</p>
<p class="noindent">Spring’s approach to simplifying an ORM framework’s usage is the same as JDBC’s—by defining template classes and DAO support classes. Also, Spring defines an abstract layer on top of different transaction management<a id="cXXX.757" class="calibre5"></a> APIs. For different ORM frameworks, you only have to pick up a corresponding transaction manager implementation. Then, you can manage transactions for them in a similar way.</p>
<p class="indent">In Spring’s data access module, the support for different data access strategies is consistent. <a id="_Tab4" href="part0020.html#Tab4" class="calibre5">Table 10-4</a> compares the support classes for JDBC, Hibernate, and JPA.</p>
<div class="Table" id="Tab4">
<p class="TabCapt"><span class="calibre4"><a href="part0020.html#_Tab4" class="calibre5">Table 10-4</a>.</span> Spring’s Support Classes for Different Data Access Strategies</p>
<p class="img1"><img src="../images/00069.jpeg" alt="Table10-4.jpg" class="calibre3"/></p></div>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  Before Spring 4.0 there were also <span class="FontName">JpaTemplate</span> and <span class="FontName">JpaDaoSupport</span> classes; however they have been removed in favor of using plain JPA (see Recipe 10-10).</p></div>
<p class="indent">Spring defines the <span class="FontName">HibernateTemplate</span> class<a id="cXXX.758" class="calibre5"></a> (for Hibernate 3 and 4) to provide template methods for different versions of Hibernate minimize the effort involved in using them. The template methods in <span class="FontName">HibernateTemplate</span> ensure that Hibernate will be opened and closed properly. They will also have native Hibernate transactions participate in Spring-managed transactions. As a result, you will be able to manage transactions declaratively for your Hibernate and JDBC DAOs without any boilerplate transaction code.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  The template approach should be considered deprecated in favor of using either a plain <span class="FontName">SessionFactory</span> or <span class="FontName">EntityManager</span> (see respectively Recipes 10-9 and 10-10).</p></div>
<p id="Sec56" class="Heading1">How It Works</p>
<p id="Sec57" class="Heading2">Using a Hibernate Template</p>
<p class="noindent">First, the <span class="FontName">HibernateCourseDao</span> class can be simplified as follows with the help of Spring’s <span class="FontName">HibernateTemplate</span>:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.orm.hibernate4.HibernateTemplate;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class HibernateCourseDao implements CourseDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private HibernateTemplate hibernateTemplate;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setHibernateTemplate(HibernateTemplate hibernateTemplate) {</span><br class="calibre10"/>        <span class="FontName">this.hibernateTemplate = hibernateTemplate;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional</span><br class="calibre10"/>    <span class="FontName">public void store(Course course) {</span><br class="calibre10"/>        <span class="FontName">hibernateTemplate.saveOrUpdate(course);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional</span><br class="calibre10"/>    <span class="FontName">public void delete(Long courseId) {</span><br class="calibre10"/>        <span class="FontName">Course course = (Course) hibernateTemplate.get(Course.class, courseId);</span><br class="calibre10"/>        <span class="FontName">hibernateTemplate.delete(course);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional(readOnly = true)</span><br class="calibre10"/>    <span class="FontName">public Course findById(Long courseId) {</span><br class="calibre10"/>        <span class="FontName">return (Course) hibernateTemplate.get(Course.class, courseId);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional(readOnly = true)</span><br class="calibre10"/>    <span class="FontName">public List&lt;Course&gt; findAll() {</span><br class="calibre10"/>        <span class="FontName">return hibernateTemplate.find("from Course");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In this DAO implementation, you declare all the DAO<a id="cXXX.759" class="calibre5"></a> methods to be transactional with the <span class="FontName">@Transactional</span> annotation. Among these methods, <span class="FontName">findById()</span> and <span class="FontName">findAll()</span> are read-only. The template methods in <span class="FontName">HibernateTemplate</span> are responsible for managing the sessions and transactions. If there are multiple Hibernate operations in a transactional DAO method, the template methods will ensure that they will run within the same session and transaction. As a result, you have no need to deal with the Hibernate API for session and transaction management.</p>
<p class="indent">The <span class="FontName">HibernateTemplate</span> class is thread-safe, so you can declare a single instance of it in the bean configuration file for Hibernate and inject this instance into all Hibernate DAOs. A <span class="FontName">HibernateTemplate</span> instance requires the <span class="FontName">sessionFactory</span> property<a id="cXXX.760" class="calibre5"></a> to be set. You can inject this property by either setter method or constructor argument.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">@EnableTransactionManagement</span><br class="calibre10"/><span class="FontName">public class CourseConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public CourseDao courseDao() {</span><br class="calibre10"/>        <span class="FontName">return new HibernateCourseDao(hibernateTemplate());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public HibernateTemplate hibernateTemplate() {</span><br class="calibre10"/>        <span class="FontName">return new HibernateTemplate(sessionfactory().getObject());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public LocalSessionFactoryBean sessionfactory() { ... }</span><br class="calibre10"/><br class="calibre10"/>}<br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public PlatformTransactionManager transactionManager() {</span><br class="calibre10"/>        <span class="FontName">return new HibernateTransactionManager(sessionfactory().getObject());</span><br class="calibre10"/>    <span class="FontName">}</span></pre>
<p class="indent">To enable declarative transaction management for the methods annotated with <span class="FontName">@Transactional</span>, you have to add the <span class="FontName">@EnableTransactionManagement</span> annotation to your configuration class. By default, it will look for a transaction manager with the name <span class="FontName">transactionManager</span>, so you have to declare a <span class="FontName">HibernateTransactionManager</span> instance with that name. <span class="FontName">HibernateTransactionManager</span> requires the session factory property to be set. It will manage transactions for sessions opened through this session factory.</p>
<p class="indent">Another advantage of <span class="FontName">HibernateTemplate</span> is that they will translate native Hibernate exceptions into exceptions in Spring’s <span class="FontName">DataAccessException</span><a id="cXXX.761" class="calibre5"></a> hierarchy. This allows consistent exception handling for all the data access strategies in Spring. For instance, if a database constraint is violated when persisting an object, Hibernate will throw an <span class="FontName">org.hibernate.exception.ConstraintViolationException</span>, while JPA will throw a <span class="FontName">javax.persistence.EntityExistsException</span>. These exceptions will be translated by <span class="FontName">HibernateTemplate</span> into a <span class="FontName">DataIntegrityViolationException</span>, which is a subclass of Spring’s <span class="FontName">DataAccessException</span>.</p>
<p class="indent">If you want to get access to the underlying Hibernate session in <span class="FontName">HibernateTemplate</span> in order to perform native Hibernate operations, you can implement the <span class="FontName">HibernateCallback</span> interface and pass its instance to the <span class="FontName">execute()</span> method of the template. This will give you a chance to use any implementation-specific features directly if there’s not sufficient support already available from the template implementations.</p>
<pre class="calibre11"><span class="FontName">hibernateTemplate.execute(new HibernateCallback() {</span><br class="calibre10"/>    <span class="FontName">public Object doInHibernate(Session session) throws HibernateException, SQLException {</span><br class="calibre10"/>       <span class="FontName">// ... anything you can imagine doing can be done here.</span><br class="calibre10"/>       <span class="FontName">// Cache invalidation, for example...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">};</span></pre>
<p id="Sec58" class="Heading2">Extending the Hibernate DAO Support Classes</p>
<p class="noindent">Your Hibernate DAO can  extend <span class="FontName">HibernateDaoSupport</span> to have the <span class="FontName">setSessionFactory()</span> and <span class="FontName">setHibernateTemplate()</span> methods inherited. Then, in your DAO methods, you can simply call the <span class="FontName">getHibernateTemplate()</span><a id="cXXX.762" class="calibre5"></a> method to retrieve the template instance.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.orm.hibernate4.support.HibernateDaoSupport;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class HibernateCourseDao</span> <b class="calibre4">extends HibernateDaoSupport</b> <span class="FontName">implements CourseDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional</span><br class="calibre10"/>    <span class="FontName">public void store(Course course) {</span><br class="calibre10"/>        <span class="FontName">getHibernateTemplate().saveOrUpdate(course);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional</span><br class="calibre10"/>    <span class="FontName">public void delete(Long courseId) {</span><br class="calibre10"/>       <span class="FontName">Course course = getHibernateTemplate().get(Course.class,courseId);</span><br class="calibre10"/>       <span class="FontName">return getHibernateTemplate().delete(Course.class,courseId);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional(readOnly = true)</span><br class="calibre10"/>    <span class="FontName">public Course findById(Long courseId) {</span><br class="calibre10"/>        <span class="FontName">return getHibernateTemplate().get(Course.class, courseId);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional(readOnly = true)</span><br class="calibre10"/>    <span class="FontName">public List&lt;Course&gt; findAll() {</span><br class="calibre10"/>        <span class="FontName">return getHibernateTemplate().find("from Course");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Because <span class="FontName">HibernateCourseDao</span> inherits the <span class="FontName">setSessionFactory()</span> and <span class="FontName">setHibernateTemplate()</span><a id="cXXX.763" class="calibre5"></a> methods, you can inject either of them into your DAO so that you can retrieve the <span class="FontName">HibernateTemplate</span> instance. If you inject a session factory, you will be able to delete the <span class="FontName">HibernateTemplate</span> declaration.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public CourseDao courseDao() {</span><br class="calibre10"/>    <span class="FontName">HibernateCourseDao courseDao = new HibernateCourseDao();</span><br class="calibre10"/>    <b class="calibre4">courseDao.setSessionFactory(sessionfactory().getObject());</b><br class="calibre10"/>    <span class="FontName">return courseDao;</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec59" class="Heading">10-9. Persisting Objects with Hibernate’s Contextual Sessions</p>
<p id="Sec60" class="Heading1">Problem</p>
<p class="noindent">Spring’s <span class="FontName">HibernateTemplate</span><a id="cXXX.764" class="calibre5"></a> can simplify your DAO implementation by managing sessions and transactions for you. However, using <span class="FontName">HibernateTemplate</span> means your DAO has to depend on Spring’s API.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Tip</b>  This is the recommended approach instead of the template-based approach!</p></div>
<p id="Sec61" class="Heading1">Solution</p>
<p class="noindent">An alternative to Spring’s <span class="FontName">HibernateTemplate</span> is to use Hibernate’s contextual sessions. In Hibernate 3, a session factory can manage contextual sessions for you and allows you to retrieve them by the <span class="FontName">getCurrentSession()</span> method on <span class="FontName">org.hibernate.SessionFactory</span>. Within a single transaction, you will get the same session for each <span class="FontName">getCurrentSession()</span><a id="cXXX.765" class="calibre5"></a> method call. This ensures that there will be only one Hibernate session per transaction, so it works nicely with Spring’s transaction management support.</p>
<p id="Sec62" class="Heading1">How It Works</p>
<p class="noindent">To use the contextual session approach, your DAO methods require access to the session factory, which can be injected via a setter method or a constructor argument. Then, in each DAO method, you get the contextual session from the session factory and use it for object persistence.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.hibernate.Query;</span><br class="calibre10"/><span class="FontName">import org.hibernate.SessionFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class HibernateCourseDao implements CourseDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private SessionFactory sessionFactory;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setSessionFactory(SessionFactory sessionFactory) {</span><br class="calibre10"/>        <span class="FontName">this.sessionFactory = sessionFactory;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional</span><br class="calibre10"/>    <span class="FontName">public void store(Course course) {</span><br class="calibre10"/>        <span class="FontName">sessionFactory.getCurrentSession().saveOrUpdate(course);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional</span><br class="calibre10"/>    <span class="FontName">public void delete(Long courseId) {</span><br class="calibre10"/>        <span class="FontName">Course course = (Course) sessionFactory.getCurrentSession().get(Course.class, courseId);</span><br class="calibre10"/>        <span class="FontName">sessionFactory.getCurrentSession().delete(course);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional(readOnly = true)</span><br class="calibre10"/>    <span class="FontName">public Course findById(Long courseId) {</span><br class="calibre10"/>        <span class="FontName">return (Course) sessionFactory.getCurrentSession().get(Course.class, courseId);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional(readOnly = true)</span><br class="calibre10"/>    <span class="FontName">public List&lt;Course&gt; findAll() {</span><br class="calibre10"/>        <span class="FontName">Query query = sessionFactory.getCurrentSession().createQuery("from Course");</span><br class="calibre10"/>        <span class="FontName">return query.list();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Note that all your DAO methods must be made transactional. This is required because Spring integrates with Hibernate through Hibernate’s Contextual Session support. Spring has its own implementation of the <span class="FontName">CurrentSessionContext</span><a id="cXXX.766" class="calibre5"></a> interface from Hibernate. It will attempt to find a transaction and then fail, complaining that no Hibernate session’s been bound to the thread. You can achieve this by annotating each method or the entire class with <span class="FontName">@Transactional</span>. This ensures that the persistence operations within a DAO method will be executed in the same transaction and hence by the same <span class="FontName">Session</span>. Moreover, if a service layer component’s method calls multiple DAO methods, and it propagates its own transaction to these methods, then all these DAO methods will run within the same session as well.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Caution</b>  When configuring Hibernate with Spring make sure not to set the <span class="FontName">hibernate.current_session_context_class</span> property, as that will interfere with Springs’ ability to properly manage the transactions. You should only set this property when you are in need of JTA transactions.</p></div>
<p class="indent">In the bean configuration file, you have to declare a <span class="FontName">HibernateTransactionManager</span> instance for this application and enable declarative transaction management via <span class="FontName">@EnableTransactionManagement</span>.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">@EnableTransactionManagement</span><br class="calibre10"/><span class="FontName">public class CourseConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public CourseDao courseDao() {</span><br class="calibre10"/>        <span class="FontName">return new HibernateCourseDao(sessionfactory().getObject());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public PlatformTransactionManager transactionManager() {</span><br class="calibre10"/>        <span class="FontName">return new HibernateTransactionManager(sessionfactory().getObject());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Remember that <span class="FontName">HibernateTemplate</span> will translate the native Hibernate exceptions into exceptions in Spring’s <span class="FontName">DataAccessException</span> hierarchy. This allows consistent exception handling for different data access strategies in Spring. However, when calling the native methods on a Hibernate session, the exceptions thrown will be of native type <span class="FontName">HibernateException</span>. If you want the Hibernate exceptions to be translated into Spring’s <span class="FontName">DataAccessException</span> for consistent exception handling, you have to apply the <span class="FontName">@</span><span class="FontName">Repository</span> annotation<a id="cXXX.767" class="calibre5"></a> to your DAO class that requires exception translation.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course.hibernate;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Repository;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Repository</span><br class="calibre10"/><span class="FontName">public class HibernateCourseDao implements CourseDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">A <span class="FontName">PersistenceExceptionTranslationPostProcessor</span> takes care of translating the native Hibernate exceptions into data access exceptions in Spring’s <span class="FontName">DataAccessException</span> hierarchy. This bean post processor will only translate exceptions for beans annotated with <span class="FontName">@Repository</span>. When using Java based configuration this bean is automatically registered in the <span class="FontName">AnnotationConfigApplicationContext</span><a id="cXXX.768" class="calibre5"></a>, hence there is no need to explicitly declare a bean for it.</p>
<p class="indent">In Spring, <span class="FontName">@Repository</span> is a stereotype annotation. By annotating it, a component class can be auto-detected through component scanning. You can assign a component name in this annotation and have the session factory auto-wired by the Spring IoC container with <span class="FontName">@Autowired</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course.hibernate;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.hibernate.SessionFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Repository;</span><br class="calibre10"/><br class="calibre10"/><b class="calibre4">@Repository("courseDao")</b><br class="calibre10"/><span class="FontName">public class HibernateCourseDao implements CourseDao {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private SessionFactory sessionFactory;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Autowired</b><br class="calibre10"/>    <span class="FontName">public HibernateCourseDao (SessionFactory sessionFactory) {</span><br class="calibre10"/>        <span class="FontName">this.sessionFactory = sessionFactory;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Then, you can simply add the <span class="FontName">@</span><span class="FontName">ComponentScan</span> annotation<a id="cXXX.769" class="calibre5"></a> and delete the original <span class="FontName">HibernateCourseDao</span> bean declaration.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">@EnableTransactionManagement</span><br class="calibre10"/><b class="calibre4">@ComponentScan("com.apress.springrecipes.course")</b><br class="calibre10"/><span class="FontName">public class CourseConfiguration { ... }</span></pre>
<p id="Sec63" class="Heading">10-10. Persisting Objects with JPA’s Context Injection</p>
<p id="Sec64" class="Heading1">Problem</p>
<p class="noindent">In a Java EE environment, a Java EE container can manage entity managers for you and inject them into your EJB components directly. An EJB component<a id="cXXX.770" class="calibre5"></a> can simply perform persistence operations on an injected entity manager without caring much about the entity manager creation and transaction management.</p>
<p id="Sec65" class="Heading1">Solution</p>
<p class="noindent">Originally, the <span class="FontName">@</span><span class="FontName">PersistenceContext</span> annotation<a id="cXXX.771" class="calibre5"></a> is used for entity manager injection in EJB components. Spring can also interpret this annotation by means of a bean post processor. It will inject an entity manager into a property with this annotation. Spring ensures that all your persistence operations within a single transaction will be handled by the same entity manager.</p>
<p id="Sec66" class="Heading1">How It Works</p>
<p class="noindent">To use the context injection approach, you can declare an entity manager field in your DAO and annotate it with the <span class="FontName">@PersistenceContext</span> annotation. Spring will inject an entity manager into this field for you to persist your objects.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import javax.persistence.EntityManager;</span><br class="calibre10"/><span class="FontName">import javax.persistence.PersistenceContext;</span><br class="calibre10"/><span class="FontName">import javax.persistence.Query;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JpaCourseDao implements CourseDao {</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@PersistenceContext</b><br class="calibre10"/>    <span class="FontName">private EntityManager entityManager;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional</span><br class="calibre10"/>    <span class="FontName">public void store(Course course) {</span><br class="calibre10"/>        <span class="FontName">entityManager.merge(course);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional</span><br class="calibre10"/>    <span class="FontName">public void delete(Long courseId) {</span><br class="calibre10"/>        <span class="FontName">Course course = entityManager.find(Course.class, courseId);</span><br class="calibre10"/>        <span class="FontName">entityManager.remove(course);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional(readOnly = true)</span><br class="calibre10"/>    <span class="FontName">public Course findById(Long courseId) {</span><br class="calibre10"/>        <span class="FontName">return entityManager.find(Course.class, courseId);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional(readOnly = true)</span><br class="calibre10"/>    <span class="FontName">public List&lt;Course&gt; findAll() {</span><br class="calibre10"/>        <span class="FontName">TypedQuery&lt;Course&gt; query = entityManager.createQuery("from Course", Course.class);</span><br class="calibre10"/>        <span class="FontName">return query.getResultList();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You can annotate each DAO method or the entire DAO class with <span class="FontName">@Transactional</span> to make all these methods transactional. It ensures that the persistence operations within a DAO method will be executed in the same transaction and hence by the same entity manager.</p>
<p class="indent">In the bean configuration file, you have to declare a <span class="FontName">JpaTransactionManager</span> instance and enable declarative transaction management via<span class="FontName">@EnableTransactionManagement</span>. A <span class="FontName">PersistenceAnnotationBeanPostProcessor</span> instance is registered automatically when using Java based config, to inject entity managers into properties annotated with <span class="FontName">@PersistenceContext</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.course.CourseDao;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.course.JpaCourseDao;</span><br class="calibre10"/><span class="FontName">import org.apache.derby.jdbc.ClientDriver;</span><br class="calibre10"/><span class="FontName">import org.hibernate.dialect.DerbyTenSevenDialect;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.datasource.SimpleDriverDataSource;</span><br class="calibre10"/><span class="FontName">import org.springframework.orm.jpa.JpaTransactionManager;</span><br class="calibre10"/><span class="FontName">import org.springframework.orm.jpa.JpaVendorAdapter;</span><br class="calibre10"/><span class="FontName">import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;</span><br class="calibre10"/><span class="FontName">import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.PlatformTransactionManager;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.EnableTransactionManagement;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.sql.DataSource;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">@EnableTransactionManagement</span><br class="calibre10"/><span class="FontName">public class CourseConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public CourseDao courseDao() {</span><br class="calibre10"/>        <span class="FontName">return new JpaCourseDao();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public LocalContainerEntityManagerFactoryBean entityManagerFactory() {</span><br class="calibre10"/>        <span class="FontName">LocalContainerEntityManagerFactoryBean emf = new LocalContainerEntityManagerFactoryBean();</span><br class="calibre10"/>        <span class="FontName">emf.setDataSource(dataSource());</span><br class="calibre10"/>        <span class="FontName">emf.setJpaVendorAdapter(jpaVendorAdapter());</span><br class="calibre10"/>        <span class="FontName">return emf;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private JpaVendorAdapter jpaVendorAdapter() {</span><br class="calibre10"/>        <span class="FontName">HibernateJpaVendorAdapter jpaVendorAdapter = new HibernateJpaVendorAdapter();</span><br class="calibre10"/>        <span class="FontName">jpaVendorAdapter.setShowSql(true);</span><br class="calibre10"/>        <span class="FontName">jpaVendorAdapter.setGenerateDdl(true);</span><br class="calibre10"/>        <span class="FontName">jpaVendorAdapter.setDatabasePlatform(DerbyTenSevenDialect.class.getName());</span><br class="calibre10"/>        <span class="FontName">return jpaVendorAdapter;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public PlatformTransactionManager transactionManager() {</span><br class="calibre10"/>        <span class="FontName">return new JpaTransactionManager(entityManagerFactory().getObject());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public DataSource dataSource() { ... }</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The <span class="FontName">PersistenceAnnotationBeanPostProcessor</span> can also inject the entity manager factory into a property with the <span class="FontName">@PersistenceUnit</span> annotation. This allows you to create entity managers and manage transactions by yourself. It’s no different from injecting the entity manager factory via a setter method.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import javax.persistence.EntityManagerFactory;</span><br class="calibre10"/><span class="FontName">import javax.persistence.PersistenceUnit;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JpaCourseDao implements CourseDao {</span><br class="calibre10"/>    <b class="calibre4">@PersistenceContext</b><br class="calibre10"/>    <span class="FontName">private EntityManager entityManager;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@PersistenceUnit</b><br class="calibre10"/>    <b class="calibre4">private EntityManagerFactory entityManagerFactory;</b><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">When calling native methods on a JPA entity manager, the exceptions thrown will be of native type <span class="FontName">PersistenceException</span>, or other Java SE exceptions like <span class="FontName">IllegalArgumentException</span> and <span class="FontName">IllegalStateException</span>. If you want JPA exceptions to be translated into Spring’s <span class="FontName">DataAccessException</span>, you have to apply the <span class="FontName">@Repository</span> annotation to your DAO class.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Repository;</span><br class="calibre10"/><br class="calibre10"/><b class="calibre4">@Repository("courseDao")</b><br class="calibre10"/><span class="FontName">public class JpaCourseDao implements CourseDao {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">A <span class="FontName">PersistenceExceptionTranslationPostProcessor</span> instance will translate the native JPA exceptions into exceptions in Spring’s <span class="FontName">DataAccessException</span> hierarchy. When using Java based configuration this bean is automatically registered in the <span class="FontName">AnnotationConfigApplicationContext</span>, hence there is no need to explicitly declare a bean for it.</p>
<p id="Sec67" class="Heading">10-11. Simplify JPA with Spring Data JPA</p>
<p id="Sec68" class="Heading1">Problem</p>
<p class="noindent">Writing data access code, even with JPA, can be a tedious and repetitive task. You often need access to the <span class="FontName">EntityManager</span> or <span class="FontName">EntityManagerFactory</span><a id="cXXX.772" class="calibre5"></a> and have to create queries. Not to mention the fact that when one has a lot of dao’s the repetitive declaration of <span class="FontName">findById</span>, <span class="FontName">findAll</span> methods for all different entities.</p>
<p id="Sec69" class="Heading1">Solution</p>
<p class="noindent">Spring Data JPA allows you, just as Spring itself, to focus on the parts that are important and not on the boilerplate needed to accomplish this. It also provides default implementations for the most commonly used data access methods (i.e., <span class="FontName">findAll</span>, <span class="FontName">delete</span>, <span class="FontName">save</span> etc.).</p>
<p id="Sec70" class="Heading1">How It Works</p>
<p class="noindent">To use Spring Data JPA we have to extend one of its interfaces, these interfaces are detected and a default implementation of that repository is generated at runtime. In most cases it is enough to extend the <span class="FontName">CrudRepository&lt;T, ID&gt;</span> interface.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.course.Course;</span><br class="calibre10"/><span class="FontName">import org.springframework.data.repository.CrudRepository;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface CourseRepository extends CrudRepository&lt;Course, Long&gt;{}</span></pre>
<p class="indent">This is enough to be able to do all necessary CRUD actions for the <span class="FontName">Course</span> entity. When extending the Spring Data interfaces we have to specify the type, <span class="FontName">Course</span>, and the type of the primary key, <span class="FontName">Long</span>, this information is needed to generate the repository at runtime.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  You could also extend <span class="FontName">JpaRepository</span> which adds some JPA specific methods (<span class="FontName">flush</span>, <span class="FontName">saveAndFlush</span>) and provides query methods with paging/sorting capabilities.</p></div>
<p class="indent">Next we need to enable detection of the Spring Data enabled repositories for this we can use the <span class="FontName">@</span><span class="FontName">EnableJpaRepositories annotation</span><a id="cXXX.773" class="calibre5"></a> provided by Spring Data JPA.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">@EnableTransactionManagement</span><br class="calibre10"/><b class="calibre4">@EnableJpaRepositories("com.apress.springrecipes.course")</b><br class="calibre10"/><span class="FontName">public class CourseConfiguration { ... }</span></pre>
<p class="indent">This will bootstrap Spring Data JPA and will construct a usable repository. By default all repository methods are marked with <span class="FontName">@Transactional</span> so no additional annotations are needed.</p>
<p class="indent">Now, you can test this <span class="FontName">CourseRepository</span><a id="cXXX.774" class="calibre5"></a> instance with the <span class="FontName">Main</span> class by retrieving it from the Spring IoC container.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.course.datajpa;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context = new AnnotationConfigApplicationContext(CourseConfiguration.class);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">CourseRepository repository = context.getBean(CourseRepository.class);</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">All other things like exception translation, transaction management, and easy configuration of your EntityManagerFactory still apply to Spring Data JPA based repositories. It just makes your life a lot easier and lets you focus on what is important.</p>
<p id="Sec71" class="Heading">Summary</p>
<p class="noindent">This chapter discussed how to use Spring’s support for JDBC, Hibernate, and JPA. You learned how to configure a <span class="FontName">DataSource</span> to connect to a database and how to use Spring’s <span class="FontName">JdbcTemplate</span> and <span class="FontName">HibernateTemplate</span> to rid your code of tedious boilerplate handling. You saw how to use the utility base classes to build DAO classes with JDBC and Hibernate, as well as how to use Spring’s support for stereotype annotations and component scanning to easily build new DAOs and Services with a minimum of XML. The final recipe showed you how to  simplify your data access code even more by using the power of Spring Data JPA.</p>
<p class="indent">In the next chapter, you will learn how to use transactions (i.e., for JMS or a database) with Spring to help ensure consistent state in your services.</p></div>
</body></html>
