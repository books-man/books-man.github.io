<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Chapter 12 Spring Batch</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre"><p class="ChapterNumber"><a id="b9781430259084_12" class="calibre6"></a>CHAPTER 12</p>
<p class="Chapimage"><img src="../images/00008.jpeg" alt="image" class="calibre3"/></p>
<p class="ChapterTitle">Spring Batch</p>
<div class="calibre10"><p class="noindent">Batch processing<a id="cXXX.829" class="calibre5"></a><a id="cXXX.830" class="calibre5"></a> has been around for decades. The earliest widespread applications of technology for managing information (information technology) were applications of batch processing. These environments didn’t have interactive sessions and usually didn’t have the capability to load multiple applications in memory. Computers were expensive and bore no resemblance to today’s servers. Typically, machines were multiuser and in use during the day (time-shared). During the evening, however, the machines would sit idle, which was a tremendous waste. Businesses invested in ways to utilize the offline time to do work aggregated through the course of the day. Out of this practice emerged batch processing.</p>
<p class="indent">Batch processing solution<a id="cXXX.831" class="calibre5"></a>s typically run offline, indifferent to events in the system. In the past, batch processes ran offline out of necessity. Today, however, most batch processes are run offline because having work done at a predictable time and having chunks of work done is a requirement for a lot of architectures. A batch processing solution doesn’t usually respond to requests, although there’s no reason it couldn’t be started as a consequence of a message or request. Batch processing solutions tend to be used on large datasets where the duration of the processing is a critical factor in its architecture and implementation. A process might run for minutes, hours, or days! Jobs may have unbounded durations (i.e., run until all work is finished, even if this means running for a few days), or they may be strictly bounded (jobs must proceed in constant time, with each row taking the same amount of time regardless of bound, which lets you, say, predict that a given job will finish in a certain time window.)</p>
<p class="indent">Batch processing has had a long history that informs even modern batch processing solutions.</p>
<p class="indent">Mainframe applications used batch processing, and one of the largest modern day environments for batch processing, CICS<a id="cXXX.832" class="calibre5"></a> on z/OS, is still fundamentally a mainframe operating system. Customer Information Control System (CICS)<a id="cXXX.833" class="calibre5"></a><a id="cXXX.834" class="calibre5"></a> is very well suited to a particular type of task: take input, process it, and write it to output. CICS is a transaction server used most in financial institutions and government that runs programs in a number of languages (COBOL, C, PLI, and so on). It can easily support thousands of transactions per second. CICS was one of the first containers, a concept familiar to Spring and Java EE users, even though CICS itself debuted in 1969! A CICS installation is very expensive, and although IBM still sells and installs CICS, many other solutions have come along since then. These solutions are usually specific to a particular environment: COBOL/CICS on mainframes, C on Unix, and, today, Java on any number of environments. The problem is that there’s very little standardized infrastructure for dealing with these types of batch processing solutions. Very few people are even aware of what they’re missing because there’s very little native support on the Java platform for batch processing. Businesses that need a solution typically end up writing it in-house, resulting in fragile, domain-specific code.</p>
<p class="indent">The pieces are there, however: transaction support, fast I/O, schedulers such as Quartz, and solid threading support, as well as a very powerful concept of an application container in Java EE and Spring. It was only natural that Dave Syer and his team would come along and build Spring Batch, a batch processing solution for the Spring platform.</p>
<p class="indent">It’s important to think about the kinds of problems this framework solves before diving into the details. A technology is defined by its solution space. A typical Spring Batch application typically reads in a lot of data and then writes it back out in a modified form. Decisions about transactional barriers, input size, concurrency, and order of steps in processing are all dimensions of a typical integration.</p>
<p class="indent">A common requirement is loading data from a comma-separated value (CSV)<a id="cXXX.835" class="calibre5"></a> <a id="cXXX.836" class="calibre5"></a> file, perhaps as a business-to-business (B2B<a id="cXXX.837" class="calibre5"></a>)<a id="cXXX.838" class="calibre5"></a> transaction, perhaps as an integration technique with an older legacy application. Another common application is nontrivial processing on records in a database. Perhaps the output is an update of the database record itself. An example might be resizing of images on the file system whose metadata is stored in a database or needing to trigger another process based on some condition.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  <i class="calibre8">Fixed-width data</i> is a format of rows and cells, quite like a CSV file. CSV file cells are separated by commas or tabs however, and fixed-width data works by presuming certain lengths for each value. The first value might be the first nine characters, the second value the next four characters after that, and so on.</p></div>
<p class="indent">Fixed-width data<a id="cXXX.839" class="calibre5"></a> which is often used with legacy or embedded systems, is a fine candidate for batch processing. Processing that deals with a resource that’s fundamentally nontransactional (e.g., a web service or a file) begs for batch processing, because batch processing provides retry/skip/fail functionality that most web services will not.</p>
<p class="indent">It’s also important to understand what Spring Batch <i class="calibre8">doesn’t</i> do. Spring Batch is a flexible but not all-encompassing solution. Just as Spring doesn’t reinvent the wheel when it can be avoided, Spring Batch leaves a few important pieces to the discretion of the implementor. Case in point: Spring Batch provides a generic mechanism by which to launch a job, be it by the command line, a Unix <span class="FontName">cron</span>, an operating system service, Quartz (discussed in <a href="part0024.html" class="calibre5">Chapter 14</a>), or in response to an event on an enterprise service bus (for example, the Mule ESB or Spring’s own ESB-like solution, Spring Integration, which is discussed in <a href="part0026.html" class="calibre5">Chapter 16</a>). Another example is the way Spring Batch manages the state of batch processes. Spring Batch requires a durable store. The only useful implementation of a <span class="FontName">JobRepository</span> (an interface provided by Spring Batch for storing runtime data) requires a database, because a database is transactional and there’s no need to reinvent it. To which database you should deploy, however, is largely unspecified, although there are useful defaults provided for you, of course.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  The JEE7 specification includes JSR-352<a id="_Fn1" href="part0022.html#Fn1" class="calibre5"><sup class="calibre9">1</sup></a> (Batch Applications for the Java Platform) Spring Batch 3.0 is the reference implementation of this specification.</p></div>
<p id="Sec1" class="Heading">Runtime Metadata Model<a id="cXXX.2171" class="calibre6"></a><a id="cXXX.840" class="calibre6"></a></p>
<p class="noindent">Spring Batch works with a <span class="FontName">JobRepository</span><a id="cXXX.841" class="calibre5"></a>, which is the keeper of all the knowledge and metadata for each job (including component parts such as <span class="FontName">JobInstances</span>, <span class="FontName">JobExecution</span>, and <span class="FontName">StepExecution</span>). Each <span class="FontName">Job</span> is composed of one or more <span class="FontName">Step</span>s, one after another. With Spring Batch, a <span class="FontName">Step</span> can conditionally follow another <span class="FontName">Step</span>, allowing for primitive workflows. These steps can also be concurrent: two steps can run at the same time.</p>
<p class="indent">When a job is run, it’s often coupled with <span class="FontName">JobParameter</span>s to parameterize the behavior of the <span class="FontName">Job</span> itself. For example, a job might take a date parameter to determine which records to process. This coupling is called a <span class="FontName">JobInstance</span>. A <span class="FontName">JobInstance</span><a id="cXXX.842" class="calibre5"></a>  is unique because of the <span class="FontName">JobParameter</span>s associated with it. Each time the same <span class="FontName">JobInstance</span> (i.e., the same <span class="FontName">Job</span> and <span class="FontName">JobParameter</span>s) is run, it’s called a <span class="FontName">JobExecution</span>. This is a runtime context for a version of the <span class="FontName">Job</span>. Ideally, for every <span class="FontName">JobInstance</span> there’d be only one <span class="FontName">JobExecution</span>: the <span class="FontName">JobExecution</span><a id="cXXX.843" class="calibre5"></a> that was created the first time the <span class="FontName">JobInstance</span> ran. However, if there were any errors, the <span class="FontName">JobInstance</span> should be restarted; the subsequent run would create another <span class="FontName">JobExecution</span>. For every step in the original job there is a <span class="FontName">StepExecution</span> in the <span class="FontName">JobExecution</span>.</p>
<p class="indent">Thus, you can see that Spring Batch has a mirrored object graph, one reflecting the design/build time view of a job, and another reflecting the runtime view of a job. This split between the prototype and the instance is very similar to the way many workflow engines—including jBPM—work.</p>
<p class="indent">For example, suppose that a daily report is generated at 2 AM. The parameter to the job would be the date (most likely the previous day’s date). The job, in this case, would model a loading step, a summary step, and an output step. Each day the job is run, a new <span class="FontName">JobInstance</span> and <span class="FontName">JobExecution</span> would be created. If there are any retries of the same <span class="FontName">JobInstance</span>, conceivably many <span class="FontName">JobExecution</span>s would be created.</p>
<div class="Singlethin">
<p class="Heading4a"><b class="calibre1">SPRING BATCH LIBRARIES</b></p>
<p class="box-left">If you want to use Spring Batch, you need to add the appropriate libraries to the classpath. If you are using Maven, add the following dependency to your project.</p>
<pre class="calibre11"><span class="FontName">&lt;dependency&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;groupId&gt;org.springframework.batch&lt;/groupId&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;artifactId&gt;spring-batch-core&lt;/artifactId&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;version&gt;3.0.1.RELEASE&lt;/version&gt;</span><br class="calibre10"/><span class="FontName">&lt;/dependency&gt;</span></pre></div>
<p id="Sec2" class="Heading">12-1. Setting Up Spring Batch’s Infrastructure<a id="cXXX.844" class="calibre6"></a></p>
<p id="Sec3" class="Heading1">Problem</p>
<p class="noindent">Spring Batch provides a lot of flexibility and guarantees to your application, but it cannot work in a vacuum. To do its work, the <span class="FontName">JobRepository</span><a id="cXXX.845" class="calibre5"></a> requires a database. Additionally, there are several collaborators required for Spring Batch to do its work. This configuration is mostly boilerplate.</p>
<p id="Sec4" class="Heading1">Solution</p>
<p class="noindent">In this recipe, you’ll set up the Spring Batch database and also create a Spring application configuration that can be imported by subsequent solutions. This configuration is repetitive and largely uninteresting. It will also tell Spring Batch what database to use for the metadata it stores.</p>
<p id="Sec5" class="Heading1">How It Works</p>
<p class="noindent">The <span class="FontName">JobRepository</span> interface is the first thing that you’ll have to deal with when setting up a Spring Batch process. You usually don’t deal with it in code, but in Spring configuration it is key to getting everything else working. There’s only one really useful implementation of the <span class="FontName">JobRepository</span> interface called <span class="FontName">SimpleJobRepository</span>, which stores information about the state of the batch processes in a database. Creation is done through a <span class="FontName">JobRepositoryFactoryBean</span>. Another standard factory, <span class="FontName">MapJobRepositoryFactoryBean</span><a id="cXXX.846" class="calibre5"></a> is useful mainly for testing because its state is not durable – it’s an in-memory implementation. Both factories create an instance of <span class="FontName">SimpleJobRepository</span>.</p>
<p class="indent">Because this <span class="FontName">JobRepository</span> instance works on your database, you need to set up the schema for Spring Batch to work with. The schemas for different databases are in the Spring Batch distribution. The simplest way to initialize your database is to use the <span class="FontName">&lt;jdbc:initialize-database /&gt;</span>tag or a <span class="FontName">DataSourceInitializer</span> in Java config.  The files can be found in the <span class="FontName">org/springframework/batch/core</span> directory there are several .<span class="FontName">sql</span> files, each containing the data definition languag<a id="cXXX.847" class="calibre5"></a><a id="cXXX.848" class="calibre5"></a><a id="cXXX.2026" class="calibre5"></a><a id="cXXX.849" class="calibre5"></a>e (DDL, the subset of SQL used for defining and examining the structure of a database) for the required schema for the database of your choice. In these examples, we will use Apache Derby, so we will use the DDL for Derby: <span class="FontName">schema-derby.sql</span>. Make sure you configure it and tell Spring Batch about it as in the following configurations.</p>
<p id="Sec6" class="Heading2">Configure Spring Batch’s Infrastructure using XML<a id="cXXX.2193" class="calibre6"></a></p>
<p class="noindent">To setup the infrastructure components<a id="cXXX.850" class="calibre5"></a> mentioned in XML use the following Spring XML configuration.</p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><span class="FontName">&lt;beans:beans</span><br class="calibre10"/>   <span class="FontName"> xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/batch" class="calibre5">http://www.springframework.org/schema/batch</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:beans="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:p="</span><span class="FontName"><a href="http://www.springframework.org/schema/p" class="calibre5">http://www.springframework.org/schema/p</a></span><span class="FontName">"\</span><br class="calibre10"/>    <span class="FontName">xmlns:context=</span><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><br class="calibre10"/>    <span class="FontName">xmlns:jdbc="</span><span class="FontName"><a href="http://www.springframework.org/schema/jdbc" class="calibre5">http://www.springframework.org/schema/jdbc</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>   <span class="FontName">xsi:schemaLocation="</span><br class="calibre10"/>    <span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span> <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans.xsd</a></span><br class="calibre10"/>    <span class="FontName"><a href="http://www.springframework.org/schema/batch" class="calibre5">http://www.springframework.org/schema/batch</a></span> <span class="FontName"><a href="http://www.springframework.org/schema/batch/spring-batch.xsd" class="calibre5">http://www.springframework.org/schema/batch/spring-batch.xsd</a></span><br class="calibre10"/>    <span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span> <span class="FontName"><a href="http://www.springframework.org/schema/util/spring-context.xsd" class="calibre5">http://www.springframework.org/schema/util/spring-context.xsd</a></span><br class="calibre10"/>    <span class="FontName"><a href="http://www.springframework.org/schema/jdbc" class="calibre5">http://www.springframework.org/schema/jdbc</a></span> <span class="FontName"><a href="http://www.springframework.org/schema/jdbc/spring-jdbc.xsd" class="calibre5">http://www.springframework.org/schema/jdbc/spring-jdbc.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;context:component-scan base-package="com.apress.springrecipes.springbatch"/&gt;</span><br class="calibre10"/><span class="FontName">&lt;context:property-placeholder location="batch.properties" ignore-unresolvable ="true" /&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;!—Initialize the database if tables do not already exist --&gt;</span><br class="calibre10"/><b class="calibre4">&lt;jdbc:initialize-database enabled="true" data-source="dataSource" ignore-failures="ALL"&gt;</b><br class="calibre10"/>    <b class="calibre4">&lt;jdbc:script location="classpath:org/springframework/batch/core/schema-derby.sql" execution="INIT"/&gt;</b><br class="calibre10"/><b class="calibre4">&lt;/jdbc:initialize-database&gt;</b><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;beans:bean id="jobRepository"</span><br class="calibre10"/><span class="FontName">class="org.springframework.batch.core.repository.support.JobRepositoryFactoryBean"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:property name="dataSource" ref="dataSource" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:property name="transactionManager" ref="transactionManager" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/beans:bean&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:bean</span><br class="calibre10"/>        <span class="FontName">id="dataSource"</span><br class="calibre10"/>        <span class="FontName">class="org.apache.commons.dbcp2.BasicDataSource"</span><br class="calibre10"/>        <span class="FontName">destroy-method="close"</span><br class="calibre10"/>        <span class="FontName">p:driverClassName="${dataSource.driverClassName}"</span><br class="calibre10"/>        <span class="FontName">p:username="${dataSource.username}"</span><br class="calibre10"/>        <span class="FontName">p:password="${dataSource.password}"</span><br class="calibre10"/>        <span class="FontName">p:url="${dataSource.url}"/&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:bean id="transactionManager"</span><br class="calibre10"/><span class="FontName">            class="org.springframework.jdbc.datasource.DataSourceTransactionManager"</span><br class="calibre10"/>            <span class="FontName">p:dataSource-ref="dataSource"/&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:bean id="jobRegistry"</span><br class="calibre10"/><span class="FontName">            class="org.springframework.batch.core.configuration.support.MapJobRegistry"/&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:bean id="jobLauncher"             class="org.springframework.batch.core.launch.support.SimpleJobLauncher"</span><br class="calibre10"/>                                 <span class="FontName">p:jobRepository-ref="jobRepository"/&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:bean</span><br class="calibre10"/>  <span class="FontName">id="jobRegistryBeanPostProcessor"</span><br class="calibre10"/><span class="FontName">  class="org.springframework.batch.core.configuration.support.JobRegistryBeanPostProcessor"</span><br class="calibre10"/>  <span class="FontName">p:jobRegistry-ref="jobRegistry"/&gt;</span></pre>
<p class="indent">Because the implementation uses a database to persist the metadata, take care to configure a <span class="FontName">DataSource</span> as well as a <span class="FontName">TransactionManager</span><a id="cXXX.851" class="calibre5"></a>. In this example, you’re using a <span class="FontName">PropertyPlaceholderConfigurer</span> to load the contents of a properties file (<span class="FontName">batch.properties</span>) whose values you use to configure the data source. You need to place values for your particular database in this file. This example uses Spring’s property schema<a id="cXXX.852" class="calibre5"></a> (<span class="FontName">"p"</span>) to abbreviate the tedious configuration. In subsequent examples, this file will be referenced as <span class="FontName">batch.xml</span>. The properties file looks like this for us:</p>
<pre class="calibre11"><span class="FontName">dataSource.password=app</span><br class="calibre10"/><span class="FontName">dataSource.username=app</span><br class="calibre10"/><span class="FontName">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br class="calibre10"/><span class="FontName">dataSource.url= jdbc:derby://localhost:1527/batch;create=true</span></pre>
<p class="indent">The first few beans are related strictly to configuration—nothing particularly novel or peculiar to Spring Batch: a data source, a transaction manager, and a properties resolver.</p>
<p class="indent">Eventually, we get to the declaration of a <span class="FontName">MapJobRegistry</span><a id="cXXX.853" class="calibre5"></a> instance. This is critical—it is the central store for information regarding a given <span class="FontName">Job</span>, and it controls the “big picture” about all <span class="FontName">Jobs</span> in the system. Everything else works with this instance.</p>
<p class="indent">Next, we have a <span class="FontName">SimpleJobLauncher</span><a id="cXXX.854" class="calibre5"></a>, whose sole purpose is to give you a mechanism to launch batch jobs, where a “job” in this case is our batch solution. The <span class="FontName">jobLauncher</span> is used to specify the name of the batch solution to run as well as any parameters required. We’ll follow up more on that in the next recipe.</p>
<p class="indent">Next, you define a <span class="FontName">JobRegistryBeanPostProcessor</span>. This bean scans your Spring context file and associates any configured <span class="FontName">Jobs</span> with the <span class="FontName">MapJobRegistry</span>.</p>
<p class="indent">Finally, we get to the <span class="FontName">SimpleJobRepository</span> (that is, in turn, factoried by the <span class="FontName">JobRepositoryFactoryBean</span>). The <span class="FontName">JobRepository</span> is an implementation of “repository" (in the <i class="calibre8">Patterns of Enterprise Application Architecture</i> sense of the word): it handles persistence and retrieval for the domain models surrounding <span class="FontName">Step</span>s, <span class="FontName">Job</span>s, and so on.</p>
<p class="indent">Spring Batch comes with namespace support and we can use this support to simplify our configuration a little. Spring Batch has the <span class="FontName">job-repository</span> tag that makes it easier to configure the <span class="FontName">JobRepositoryFactoryBean</span> and you don’t have to remember the name of the bean to use. We could replace the bean definition for the <span class="FontName">JobRepositoryFactoryBean</span> with the following.</p>
<pre class="calibre11"><span class="FontName">&lt;job-repository id="jobRepository" data-source="dataSource" transaction-manager="transactionManager" /&gt;</span></pre>
<p class="indent">This saves a couple of lines of XML, which can be especially useful if extensive configuration is needed for the <span class="FontName">JobRepositoryFactoryBean</span>.</p>
<p id="Sec7" class="Heading2">Configure Spring Batch’s Infrastructure using Java Config</p>
<p class="noindent">As of Spring Batch 3.0, there is also the possibility to use Java based configuration<a id="cXXX.855" class="calibre5"></a>. For this use the <span class="FontName">@EnableBatchProcessing</span> annotation on a <span class="FontName">@Configuration</span> class.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springbatch.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.apache.commons.dbcp2.BasicDataSource;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.ComponentScan;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.PropertySource;</span><br class="calibre10"/><span class="FontName">import org.springframework.core.env.Environment;</span><br class="calibre10"/><span class="FontName">import org.springframework.core.io.ClassPathResource;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.datasource.init.DataSourceInitializer;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.sql.DataSource;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><b class="calibre4">@EnableBatchProcessing(modular = false)</b><br class="calibre10"/><span class="FontName">@ComponentScan("com.apress.springrecipes.springbatch")</span><br class="calibre10"/><span class="FontName">@PropertySource("classpath:/batch.properties")</span><br class="calibre10"/><span class="FontName">public class BatchConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private Environment env;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public DataSource dataSource() {</span><br class="calibre10"/>        <span class="FontName">BasicDataSource dataSource = new BasicDataSource();</span><br class="calibre10"/>        <span class="FontName">dataSource.setUrl(env.getRequiredProperty("dataSource.url"));</span><br class="calibre10"/>        <span class="FontName">dataSource.setDriverClassName(env.getRequiredProperty("dataSource.driverClassName"));</span><br class="calibre10"/>        <span class="FontName">dataSource.setUsername(env.getProperty("dataSource.username"));</span><br class="calibre10"/>        <span class="FontName">dataSource.setPassword(env.getProperty("dataSource.password"));</span><br class="calibre10"/>        <span class="FontName">return dataSource;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public DataSourceInitializer databasePopulator() {</span><br class="calibre10"/>        <span class="FontName">ResourceDatabasePopulator populator = new ResourceDatabasePopulator();</span><br class="calibre10"/>        <span class="FontName">populator.addScript(new ClassPathResource("org/springframework/batch/core/schema-derby.sql"));</span><br class="calibre10"/>        <span class="FontName">populator.addScript(new ClassPathResource("sql/reset_user_registration.sql"));</span><br class="calibre10"/>        <span class="FontName">populator.setContinueOnError(true);</span><br class="calibre10"/>        <span class="FontName">populator.setIgnoreFailedDrops(true);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">DataSourceInitializer initializer = new DataSourceInitializer();</span><br class="calibre10"/>        <span class="FontName">initializer.setDatabasePopulator(populator);</span><br class="calibre10"/>        <span class="FontName">initializer.setDataSource(dataSource());</span><br class="calibre10"/>        <span class="FontName">return initializer;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The <span class="FontName">@</span><span class="FontName">PropertySource</span> annotation<a id="cXXX.856" class="calibre5"></a> will instruct Spring to load our <span class="FontName">batch.properties</span> file, the properties we need we are going to retrieve using the <span class="FontName">Environment</span> class.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Tip</b>  we could have also used a <span class="FontName">@Value</span> annotation to inject all individual properties but when needing multiple properties in a configuration class it is easier to use the <span class="FontName">Environment</span> object.</p></div>
<p class="indent">This class only contains two bean definitions one for the datasource and one for initializing the database, everything else is taken care of due to the <span class="FontName">@EnableBatchProcessing</span> annotation. The configuration class above will bootstrap Spring Batch with some sensible defaults. The <span class="FontName">modular</span> attribute<a id="cXXX.857" class="calibre5"></a> indicates if the job definitions should be loaded in the same context or in their own child contexts. For now it is enough to load the jobs in the same context and hence we set it to <span class="FontName">false</span>.</p>
<p class="indent">The default configuration will configure a <span class="FontName">JobRepository</span>, <span class="FontName">JobRegistry,</span> and <span class="FontName">JobLauncher</span>.</p>
<p class="indent">The <span class="FontName">JobRegistry</span> will be an instance of the <span class="FontName">MapJobRegistry</span>. This is critical—it is the central store for information regarding a given <span class="FontName">Job</span>, and it controls the “big picture” about all <span class="FontName">Jobs</span> in the system. Everything else works with this instance.</p>
<p class="indent">Next, the <span class="FontName">JobLauncher</span> will be a <span class="FontName">SimpleJobLauncher</span>, whose sole purpose is to give you a mechanism to launch batch jobs, where a “job” in this case is our batch solution. The <span class="FontName">JobLauncher</span> is used to specify the name of the batch solution to run as well as any parameters required. We’ll follow up more on that in the next recipe.</p>
<p class="indent">Finally, a JobRepository is also created, in this case a <span class="FontName">SimpleJobRepository</span><a id="cXXX.858" class="calibre5"></a> (that is, in turn, factoried by the <span class="FontName">JobRepositoryFactoryBean</span>). The <span class="FontName">JobRepository</span> is an implementation of “repository (in the <i class="calibre8">Patterns of Enterprise Application Architecture</i> sense of the word): it handles persistence and retrieval for the domain models surrounding <span class="FontName">Step</span>s, <span class="FontName">Job</span>s, and so on. Due to the existence of a datasource in our configuration a JDBC version of the JobRepository will be created, of there are no datasources a <span class="FontName">Map</span> based version would have been constructed.</p>
<p class="indent">If there are multiple datasources in your application you need to add <span class="FontName">BatchConfigurer</span> to select the datasource to use for the batch part of your application.</p>
<p class="indent">The following <span class="FontName">Main</span> class<a id="cXXX.859" class="calibre5"></a> will use the Java based configuration for running the batch application:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springbatch;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.springbatch.config.BatchConfiguration;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.configuration.JobRegistry;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.launch.JobLauncher;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.repository.JobRepository;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) throws Throwable {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span> <b class="calibre4">new AnnotationConfigApplicationContext</b><span class="FontName">(BatchConfiguration.class);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">JobRegistry jobRegistry = context.getBean("jobRegistry", JobRegistry.class);</span><br class="calibre10"/>        <span class="FontName">JobLauncher jobLauncher = context.getBean("jobLauncher", JobLauncher.class);</span><br class="calibre10"/>        <span class="FontName">JobRepository jobRepository = context.getBean("jobRepository", JobRepository.class);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">System.out.println("JobRegistry: " + jobRegistry);</span><br class="calibre10"/>        <span class="FontName">System.out.println("JobLauncher: " + jobLauncher);</span><br class="calibre10"/>        <span class="FontName">System.out.println("JobRepository: " + jobRepository);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Notice the usage of the <span class="FontName">AnnotationConfigApplicationContext</span>, the application is now only using Java and no more XML for configuration and running.</p>
<p id="Sec8" class="Heading">12-2. Reading and Writing</p>
<p id="Sec9" class="Heading1">Problem</p>
<p class="noindent">You want to insert data from a file into a database. This solution will be one of the simplest solutions and will give you a chance to explore the moving pieces of a typical solution.</p>
<p id="Sec10" class="Heading1">Solution</p>
<p class="noindent">You’ll build a solution that does a minimal amount of work, while being a viable application of the technology. The solution will read in a file of arbitrary length and write out the data into a database. The end result will be almost 100 percent code free. You will rely on an existing model class and write one class (a class containing the <span class="FontName">public static void main(String [] args()</span> method) to round out the example. There’s no reason why the model class couldn’t be a Hibernate class or something from your DAO layer, though in this case it’s a brainless POJO. This solution will use the components we configured in <span class="FontName">batch.xml</span>.</p>
<p id="Sec11" class="Heading1">How It Works</p>
<p class="noindent">This example demonstrates the simplest possible use of a Spring Batch: to provide scalability. This program will do nothing but read data from a CSV file, with fields delimited by commas and rows delimited by new lines. It then inserts the records into a table. You are exploiting the intelligent infrastructure that Spring Batch provides to avoid worrying about scaling. This application could easily be done manually. You will not exploit any of the smart transactional functionality made available to you, nor will you worry about retries for the time being.</p>
<p class="indent">This solution is as simple as Spring Batch solutions get. Spring Batch models solutions using XML schema. The abstractions and terms are in the spirit of classical batch processing solutions so will be portable from previous technologies and perhaps to subsequent technologies. Spring Batch provides useful default classes that you can override or selectively adjust. In the following example, you’ll use a lot of the utility implementations provided by Spring Batch. Fundamentally, most solutions look about the same and feature a combination of the same set of interfaces. It’s usually just a matter of picking and choosing the right ones.</p>
<p class="indent">When I ran this program, it worked on files with 20,000 rows, and it worked on files with 1 million rows. I experienced no increase in memory, which indicates there were no memory leaks. Naturally, it took a lot longer! (The application ran for several hours with the 1-million-row insert.)</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Tip</b>  Of course, it would be catastrophic if you worked with a million rows and it failed on the penultimate record, because you’d lose all your work when the transaction rolled back! Read on for examples on chunking. Additionally, you might want to read through <a href="part0021.html" class="calibre5">Chapter 11</a> to brush up on transactions.</p></div>
<pre class="calibre11"><span class="FontName">create table USER_REGISTRATION</span><br class="calibre10"/><span class="FontName">(</span><br class="calibre10"/>  <span class="FontName">ID BIGINT NOT NULL PRIMARY KEY GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1),</span><br class="calibre10"/>  <span class="FontName">FIRST_NAME VARCHAR(255) not null,</span><br class="calibre10"/>  <span class="FontName">LAST_NAME VARCHAR(255) not null,</span><br class="calibre10"/>  <span class="FontName">COMPANY VARCHAR(255) not null,</span><br class="calibre10"/>  <span class="FontName">ADDRESS VARCHAR(255) not null,</span><br class="calibre10"/>  <span class="FontName">CITY VARCHAR(255) not null,</span><br class="calibre10"/>  <span class="FontName">STATE VARCHAR(255) not null,</span><br class="calibre10"/>  <span class="FontName">ZIP VARCHAR(255) not null,</span><br class="calibre10"/>  <span class="FontName">COUNTY VARCHAR(255) not null,</span><br class="calibre10"/>  <span class="FontName">URL VARCHAR(255) not null,</span><br class="calibre10"/>  <span class="FontName">PHONE_NUMBER VARCHAR(255) not null,</span><br class="calibre10"/>  <span class="FontName">FAX VARCHAR(255) not null</span><br class="calibre10"/><span class="FontName">) ;</span></pre>
<div class="Singlethin">
<p class="Heading4a"><b class="calibre1">DATA LOADS AND DATA WAREHOUSES</b></p>
<p class="box-left">I didn’t tune the table at all. For example, there are no indexes on any of the columns besides the primary key. This is to avoid complicating the example. Great care should be taken with a table like this one in a nontrivial, production-bound application.</p>
<p class="box-left">Spring Batch applications are workhorse applications and have the potential to reveal bottlenecks in your application you didn’t know you had. Imagine suddenly being able to achieve 1 million new database insertions every 10 minutes. Would your database grind to a halt? Insert speed can be a critical factor in the speed of your application. Software developers will (hopefully) think about their database schema in terms of how well it enforces the constraints of the business logic and how well it serves the overall business model. However, it’s important to wear another hat, that of a DBA, when writing applications such as this one. A common solution is to create a denormalized table whose contents can be coerced into valid data once inside the database, perhaps by a trigger on inserts. This is typical in data warehousing. Later, you’ll explore using Spring Batch to do processing on a record before insertion. This lets the developer verify or override the input into the database. This processing, in tandem with a conservative application of constraints that are best expressed in the database, can make for applications that are very robust <i class="calibre8">and</i> quick.</p></div>
<p id="Sec12" class="Heading2">The Job Configuration</p>
<p class="noindent">The configuration for the <span class="FontName">job</span> is as follows:</p>
<pre class="calibre11"><span class="FontName">&lt;job</span><br class="calibre10"/>  <span class="FontName">job-repository="jobRepository"</span><br class="calibre10"/>  <span class="FontName">id="insertIntoDbFromCsvJob"&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;step id="step1"&gt;</span><br class="calibre10"/> <span class="FontName">      &lt;tasklet transaction-manager="transactionManager"&gt;</span><br class="calibre10"/>       <span class="FontName">&lt;chunk</span><br class="calibre10"/>               <span class="FontName">reader="csvFileReader"</span><br class="calibre10"/>               <span class="FontName">writer="jdbcItemWriter"</span><br class="calibre10"/>               <span class="FontName">commit-interval="5"</span><br class="calibre10"/>          <span class="FontName">/&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/tasklet&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/step&gt;</span><br class="calibre10"/><span class="FontName">&lt;/job&gt;</span></pre>
<p class="indent">As described earlier, a <span class="FontName">job</span> consists of <span class="FontName">step</span>s, which are the real workhorse of a given <span class="FontName">job</span>. The <span class="FontName">step</span>s can be as complex or as simple as you like. Indeed, a <span class="FontName">step</span> could be considered the smallest unit of work for a <span class="FontName">job</span>. Input (what’s read) is passed to the <span class="FontName">Step</span> and potentially processed; then output (what’s written) is created from the <span class="FontName">step</span>. This processing is spelled out using a <span class="FontName">Tasklet</span>. You can provide your own <span class="FontName">Tasklet</span> implementation<a id="cXXX.860" class="calibre5"></a> or simply use some of the preconfigured configurations for different processing scenarios. These implementations are made available in terms of subelements of the <span class="FontName">Tasklet</span> element. One of the most important aspects of batch processing is chunk-oriented processing, which is employed here using the <span class="FontName">chunk</span> element.</p>
<p class="indent">In chunk-oriented processing<a id="cXXX.861" class="calibre5"></a>, input is read from a reader, optionally processed, and then aggregated. Finally, at a configurable interval—as specified by the <span class="FontName">commit-interval</span> attribute to configure how many items will be processed before the transaction is committed—all the input is sent to the <span class="FontName">writer</span>. If there is a transaction manager in play, the transaction is also committed. Right before a commit, the metadata in the database is updated to mark the progress of the <span class="FontName">job</span>.</p>
<p class="indent">There are some nuances surrounding the aggregation of the input (read) values when a transaction-aware writer (or processor) rolls back. Spring Batch caches the values it reads and writes them to the writer. If the writer component is transactional, like a database, and the reader is not, there’s nothing inherently wrong with caching the read values and perhaps retrying or taking some alternative approach. If the reader itself is also transactional, then the values read from the resource will be rolled back and could conceivably change, rendering the in-memory cached values stale. If this happens, you can configure the chunk to not cache the values using <span class="FontName">reader-transactional-queue="true"</span> on the <span class="FontName">chunk</span> element.</p>
<p id="Sec13" class="Heading2">Input<a id="cXXX.862" class="calibre6"></a></p>
<p class="noindent">The first responsibility is reading a file from the file system. You use a provided implementation for the example. Reading CSV files is a very common scenario, and Spring Batch’s support does not disappoint. The <span class="FontName">org.springframework.batch.item.file.FlatFileItemReader&lt;T&gt;</span> class delegates the task of delimiting fields and records within a file to a <span class="FontName">LineMapper&lt;T&gt;</span>, which in turn delegates the task of identifying the fields within that record, to <span class="FontName">LineTokenizer.</span>  You use a <span class="FontName">org.springframework.batch.item.file.transform.DelimitedLineTokenizer</span>, which is configured to delineate fields separated by a “,” character.</p>
<p class="indent">The <span class="FontName">FlatFileItemReader</span> also declares a <span class="FontName">fieldSetMapper</span> attribute that requires an implementation of <span class="FontName">FieldSetMapper</span>. This bean is responsible for taking the input name/value pairs and producing a type that will be given to the writer component.</p>
<p class="indent">In this case, you use an <span class="FontName">BeanWrapperFieldSetMapper</span> that will create a JavaBean POJO of type <span class="FontName">UserRegistration</span>. You name the fields so that you can reference them later in the configuration. These names don’t have to be the values of some header row in the input file; they just have to correspond to the order in which the fields are found in the input file. These names are also used by the <span class="FontName">FieldSetMapper</span> to match properties on a POJO. As each record is read, the values are applied to an instance of a POJO, and that POJO is returned.</p>
<pre class="calibre11"><span class="FontName">&lt;beans:bean</span><br class="calibre10"/>  <span class="FontName">id="csvFileReader"</span><br class="calibre10"/>  <span class="FontName">class="org.springframework.batch.item.file.FlatFileItemReader"</span><br class="calibre10"/>  <span class="FontName">p:resource="file:${user.home}/batches/registrations.csv"&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;beans:property</span><br class="calibre10"/><span class="FontName">name="lineMapper"&gt;</span><br class="calibre10"/>   <span class="FontName">&lt;beans:bean</span><br class="calibre10"/>    <span class="FontName">class="org.springframework.batch.item.file.mapping.DefaultLineMapper"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;beans:property</span><br class="calibre10"/><span class="FontName">name="lineTokenizer"&gt;</span><br class="calibre10"/>     <span class="FontName">&lt;beans:beanclass="org.springframework.batch.item.file.transform.DelimitedLineTokenizer"</span><br class="calibre10"/>      <span class="FontName">p:delimiter=","p:names="firstName,lastName,company,address,city,state,zip,county,url,phoneNumber,fax" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/beans:property&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;beans:property</span><br class="calibre10"/><span class="FontName">name="fieldSetMapper"&gt;</span><br class="calibre10"/>     <span class="FontName">&lt;beans:bean class="org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper<img src="../images/00053.jpeg" alt="image" class="calibre3"/></span><br class="calibre10"/>      <span class="FontName">p:targetType="com.apress.springrecipes.springbatch.UserRegistration" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/beans:property&gt;</span><br class="calibre10"/>   <span class="FontName">&lt;/beans:bean&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;/beans:property&gt;</span><br class="calibre10"/> <span class="FontName">&lt;/beans:bean&gt;</span></pre>
<p class="indent">The class returned from the reader, <span class="FontName">UserRegistration</span>, is a rather plain JavaBean.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springbatch;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class UserRegistration implements Serializable {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private String firstName;</span><br class="calibre10"/>    <span class="FontName">private String lastName;</span><br class="calibre10"/>    <span class="FontName">private String company;</span><br class="calibre10"/>    <span class="FontName">private String address;</span><br class="calibre10"/>    <span class="FontName">private String city;</span><br class="calibre10"/>    <span class="FontName">private String state;</span><br class="calibre10"/>    <span class="FontName">private String zip;</span><br class="calibre10"/>    <span class="FontName">private String county;</span><br class="calibre10"/>    <span class="FontName">private String url;</span><br class="calibre10"/>    <span class="FontName">private String phoneNumber;</span><br class="calibre10"/>    <span class="FontName">private String fax;</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">//... accessor / mutators omitted for brevity ...</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec14" class="Heading2">Output<a id="cXXX.863" class="calibre6"></a></p>
<p class="noindent">The next component to do work is the <span class="FontName">writer</span>, which is responsible for taking the aggregated collection of items read from the reader. In this case, you might imagine that a new collection (<span class="FontName">java.util.List&lt;UserRegistration&gt;)</span> is created, then written, and then reset each time the collection exceeds the commit-interval attribute on the <span class="FontName">chunk</span> element. Because you’re trying to write to a database, you use Spring Batch’s <span class="FontName">org.springframework.batch.item.database.JdbcBatchItemWriter</span>. This class contains support for taking input and writing it to a database. It is up to the developer to provide the input and to specify what SQL should be run for the input. It will run the SQL specified by the <span class="FontName">sql</span> property, in essence reading from the database, as many times as specified by the <span class="FontName">chunk</span> element’s <span class="FontName">commit-interval</span>, and then commit the whole transaction. Here, you’re doing a simple insert. The names and values for the named parameters are being created by the bean configured for the <span class="FontName">itemSqlParameterSourceProvider</span> property, an instance of the interface <span class="FontName">BeanPropertyItemSqlParameterSourceProvider</span>, whose sole job it is to take JavaBean properties and make them available as named parameters corresponding to the property name on the JavaBean.</p>
<pre class="calibre11"><span class="FontName">&lt;beans:bean id="jdbcItemWriter"class="org.springframework.batch.item.database.JdbcBatchItemWriter"         p:assertUpdates="true"</span><br class="calibre10"/>        <span class="FontName">p:dataSource-ref="dataSource"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:property name="sql"&gt;</span><br class="calibre10"/>         <span class="FontName">&lt;beans:value&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;![CDATA[</span><br class="calibre10"/>      <span class="FontName">insert into USER_REGISTRATION(</span><br class="calibre10"/><span class="FontName">FIRST_NAME, LAST_NAME, COMPANY, ADDRESS,</span><br class="calibre10"/><span class="FontName">CITY, STATE, ZIP, COUNTY,</span><br class="calibre10"/><span class="FontName">URL, PHONE_NUMBER, FAX )</span><br class="calibre10"/><span class="FontName">values ( :firstName, :lastName, :company, :address, :city , :state, :zip, :county,  :url, :phoneNumber, :fax )</span><br class="calibre10"/><span class="FontName">]]&gt; &lt;/beans:value&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans:property&gt;</span><br class="calibre10"/><span class="FontName">&lt;beans:property name="itemSqlParameterSourceProvider"&gt;</span><br class="calibre10"/><span class="FontName">&lt;beans:bean</span><br class="calibre10"/>    <span class="FontName">class="org.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans:property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans:bean&gt;</span></pre>
<p class="indent">And that’s it! A working solution. With little configuration and no custom code, you’ve built a solution for taking large CSV files and reading them into a database. This solution is bare bones and leaves a lot of edge cases uncared for. You might want to do processing on the item as it’s read (before it’s inserted), for example.</p>
<p class="indent">This exemplifies a simple <span class="FontName">job</span>. It’s important to remember that there are similar classes for doing the exact opposite transformation: reading from a database and writing to a CSV file.</p>
<p class="indent">As mentioned in Recipe 12-1 there is also a Java Config alternative available, instead of writing XML we can also create a class, annotated with <span class="FontName">@Configuration</span>, to setup our job and steps. The Java Config alternative would look like the following</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springbatch.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.springbatch.UserRegistration;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.Job;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.Step;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.ItemReader;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.ItemWriter;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.database.JdbcBatchItemWriter;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.file.FlatFileItemReader;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.file.LineMapper;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.file.mapping.DefaultLineMapper;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.file.transform.DelimitedLineTokenizer;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Value;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.core.io.Resource;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.sql.DataSource;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class UserJob {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private static final String INSERT_REGISTRATION_QUERY =</span><br class="calibre10"/>            <span class="FontName">"insert into USER_REGISTRATION(FIRST_NAME, LAST_NAME, COMPANY, ADDRESS,CITY,STATE,ZIP,COUNTY,URL,PHONE_NUMBER,FAX)" +</span><br class="calibre10"/>            <span class="FontName">" values " +</span><br class="calibre10"/>    <span class="FontName">"(:firstName,:lastName,:company,:address,:city,:state,:zip,:county,:url,:phoneNumber,:fax)";</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Autowired</b><br class="calibre10"/>    <b class="calibre4">private JobBuilderFactory jobs;</b><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Autowired</b><br class="calibre10"/>    <b class="calibre4">private StepBuilderFactory steps;</b><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private DataSource dataSource;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Value("file:${user.home}/batches/registrations.csv")</span><br class="calibre10"/>    <span class="FontName">private Resource input;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public Job insertIntoDbFromCsvJob() {</span><br class="calibre10"/>        <span class="FontName">return jobs.get("insertIntoDbFromCsvJob")</span><br class="calibre10"/>                <span class="FontName">.start(step1())</span><br class="calibre10"/>                <span class="FontName">.build();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">protected Step step1() {</span><br class="calibre10"/>        <span class="FontName">return steps.get("step1")</span><br class="calibre10"/>                <span class="FontName">.&lt;UserRegistration,UserRegistration&gt;chunk(5)</span><br class="calibre10"/>                <span class="FontName">.reader(csvFileReader())</span><br class="calibre10"/>                <span class="FontName">.writer(jdbcItemWriter())</span><br class="calibre10"/>                <span class="FontName">.build();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">ItemReader&lt;UserRegistration&gt; csvFileReader() {</span><br class="calibre10"/>        <span class="FontName">FlatFileItemReader&lt;UserRegistration&gt; itemReader = new FlatFileItemReader&lt;&gt;();</span><br class="calibre10"/>        <span class="FontName">itemReader.setLineMapper(lineMapper());</span><br class="calibre10"/>        <span class="FontName">itemReader.setResource(input);</span><br class="calibre10"/>        <span class="FontName">return itemReader;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">ItemWriter&lt;UserRegistration&gt; jdbcItemWriter() {</span><br class="calibre10"/>        <span class="FontName">JdbcBatchItemWriter itemWriter = new JdbcBatchItemWriter();</span><br class="calibre10"/>        <span class="FontName">itemWriter.setDataSource(dataSource);</span><br class="calibre10"/>        <span class="FontName">itemWriter.setSql(INSERT_REGISTRATION_QUERY);</span><br class="calibre10"/>        <span class="FontName">itemWriter.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider());</span><br class="calibre10"/>        <span class="FontName">return itemWriter;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">LineMapper&lt;UserRegistration&gt; lineMapper() {</span><br class="calibre10"/>        <span class="FontName">DelimitedLineTokenizer tokenizer = new DelimitedLineTokenizer();</span><br class="calibre10"/>        <span class="FontName">tokenizer.setDelimiter(",");</span><br class="calibre10"/>        <span class="FontName">tokenizer.setNames(new String[]{"firstName","lastName","company","address","city","state","zip","county","url","phoneNumber","fax"});</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">BeanWrapperFieldSetMapper&lt;UserRegistration&gt; fieldSetMapper = new BeanWrapperFieldSetMapper();</span><br class="calibre10"/>        <span class="FontName">fieldSetMapper.setTargetType(UserRegistration.class);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">DefaultLineMapper&lt;UserRegistration&gt; lineMapper = new DefaultLineMapper&lt;&gt;();</span><br class="calibre10"/>        <span class="FontName">lineMapper.setLineTokenizer(tokenizer);</span><br class="calibre10"/>        <span class="FontName">lineMapper.setFieldSetMapper(fieldSetMapper);</span><br class="calibre10"/>        <span class="FontName">return lineMapper;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Basically we configure the different components here, the <span class="FontName">ItemReader</span> and <span class="FontName">ItemWriter</span> with all the related beans. There are two factory classes, <span class="FontName">StepBuilderFactory</span> and <span class="FontName">JobBuilderFactory</span>, which help use configure our steps and jobs. Both classes follow the builder pattern and that allows us to chain the methods to configure our step and job. Let's take a closer look at our step configuration.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">protected Step step1() {</span><br class="calibre10"/>    <span class="FontName">return steps.get("step1")</span><br class="calibre10"/>            <span class="FontName">.chunk(5)</span><br class="calibre10"/>            <span class="FontName">.reader(csvFileReader())</span><br class="calibre10"/>            <span class="FontName">.writer(jdbcItemWriter())</span><br class="calibre10"/>            <span class="FontName">.build();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">To configure the step we give it the name <span class="FontName">step1</span>, we are using chunk based processing and we need to tell it that we want a chunk size of 5, next we supply it with a <span class="FontName">reader</span> and <span class="FontName">writer</span> and finally we tell the factory to build to the step. Effectively resulting in the same step configuration as in our XML configuration earlier on.</p>
<p class="indent">The configured step is finally wired as a starting point to our job, which consists only of this step.</p>
<p id="Sec15" class="Heading">12-3. Writing a Custom ItemWriter and ItemReader</p>
<p id="Sec16" class="Heading1">Problem</p>
<p class="noindent">You want to talk to a resource (you might imagine an RSS feed, or any other custom data format) that Spring Batch doesn’t know how to connect to.</p>
<p id="Sec17" class="Heading1">Solution</p>
<p class="noindent">You can easily write your own <span class="FontName">ItemWriter</span> or <span class="FontName">ItemReader</span>. The interfaces are drop dead simple, and there’s not a lot of responsibility placed on the implementations.</p>
<p id="Sec18" class="Heading1">How It Works</p>
<p class="noindent">As easy and trivial as this process is to do, it’s still not better than just reusing any of the numerous provided options. If you look, you’ll likely find something. There’s support for writing JMS (<span class="FontName">JmsItemWriter&lt;T&gt;</span>), JPA (<span class="FontName">JpaItemWriter&lt;T&gt;</span>), JDBC (<span class="FontName">JdbcBatchItemWriter&lt;T&gt;</span>), Files (<span class="FontName">FlatFileItemWriter&lt;T&gt;</span>), iBatis (<span class="FontName">IbatisBatchItemWriter&lt;T&gt;</span>), Hibernate (<span class="FontName">HibernateItemWriter&lt;T&gt;</span>), and more. There’s even support for writing by invoking a method on a bean (<span class="FontName">PropertyExtractingDelegatingItemWriter&lt;T&gt;</span>) and passing to it as arguments the properties on the <span class="FontName">Item</span> to be written! One of the more useful writers lets you write to a set of files that are numbered. This implementation—<span class="FontName">MultiResourceItemWriter&lt;T&gt;</span>—delegates to other proper <span class="FontName">ItemWriter&lt;T&gt;</span> implementation for the work, but lets you write to multiple files, not just one very large one. There’s a slightly smaller but impressive set of implementations for <span class="FontName">ItemReader</span> implementations. If it doesn’t exist, look again. If you <i class="calibre8">still</i> can’t find one, consider writing your own. In this recipe, we will do just that.</p>
<p id="Sec19" class="Heading2">Writing a Custom ItemReader<a id="cXXX.864" class="calibre6"></a><a id="cXXX.865" class="calibre6"></a></p>
<p class="noindent">The <span class="FontName">ItemReader</span> example is trivial. Here, an <span class="FontName">ItemReader</span> is created that knows how to retrieve <span class="FontName">UserRegistration</span> objects from a remote procedure call (RPC)<a id="cXXX.866" class="calibre5"></a><a id="cXXX.867" class="calibre5"></a> endpoint:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springbatch;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.Collection;</span><br class="calibre10"/><span class="FontName">import java.util.Date;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.ItemReader;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.ParseException;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.UnexpectedInputException;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.springbatch.UserRegistrationService;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.springbatch.UserRegistration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class UserRegistrationItemReader</span><br class="calibre10"/>  <span class="FontName">implements ItemReader&lt;UserRegistration&gt; {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private UserRegistrationService userRegistrationService;</span><br class="calibre10"/>    <span class="FontName">public UserRegistration read() throws Exception,UnexpectedInputException,</span><br class="calibre10"/>    <span class="FontName">ParseException {</span><br class="calibre10"/>        <span class="FontName">Date today = new Date();</span><br class="calibre10"/>        <span class="FontName">Collection&lt;UserRegistration&gt; registrations =</span><br class="calibre10"/><br class="calibre10"/>         <span class="FontName">userRegistrationService.getOutstandingUserRegistrationBatchForDate(</span><br class="calibre10"/>                  <span class="FontName">1, today);</span><br class="calibre10"/>        <span class="FontName">if (registrations!=null &amp;&amp; registrations.size() &gt;=1)</span><br class="calibre10"/>             <span class="FontName">return registrations.iterator().next();</span><br class="calibre10"/>        <span class="FontName">return null;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">As you can see, the interface is trivial. In this case, you defer most work to a remote service to provide you with the input. The interface requires that you return one record. The interface is parameterized to the type of object (the “item”) to be returned. All the read items will be aggregated and then passed to the <span class="FontName">ItemWriter</span>.</p>
<p id="Sec20" class="Heading2">Writing a Custom ItemWriter<a id="cXXX.868" class="calibre6"></a><a id="cXXX.869" class="calibre6"></a></p>
<p class="noindent">The <span class="FontName">ItemWriter</span> example is also trivial. Imagine wanting to write by invoking a remote service using any of the numerous options for remoting that Spring provides. The <span class="FontName">ItemWriter&lt;T&gt;</span> interface is parameterized by the type of item you’re expecting to write. Here, you expect a <span class="FontName">UserRegistration</span> object from the <span class="FontName">ItemReader&lt;T&gt;</span>. The interface consists of one method, which expects a <span class="FontName">List</span> of the class’s parameterized type. These are the objects read from <span class="FontName">ItemReader&lt;T&gt;</span> and aggregated. If your <span class="FontName">commit-interval</span> were ten, you might expect ten or fewer items in the <span class="FontName">List</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springbatch;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.List;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.apache.commons.lang3.builder.ToStringBuilder;</span><br class="calibre10"/><span class="FontName">import org.slf4j.Logger;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.ItemWriter;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.springbatch.User;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.springbatch.UserRegistrationService;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.springbatch.solution1.UserRegistration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class UserRegistrationServiceItemWriter implements</span><br class="calibre10"/>      <span class="FontName">ItemWriter&lt;UserRegistration&gt; {</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">private static final Logger logger = LoggerFactory.getLogger(UserRegistrationServiceItemWriter.class);</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">// this is the client interface to an HTTP Invoker service.</span><br class="calibre10"/>   <span class="FontName">@Autowired</span><br class="calibre10"/>   <span class="FontName">private UserRegistrationService userRegistrationService;</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">/**</span><br class="calibre10"/>    <span class="FontName">* takes aggregated input from the reader and 'writes' them using a custom</span><br class="calibre10"/>    <span class="FontName">* implementation.</span><br class="calibre10"/>    <span class="FontName">*/</span><br class="calibre10"/>   <span class="FontName">public void write(List&lt;? extends UserRegistration&gt; items)</span><br class="calibre10"/>   <span class="FontName">throws Exception {</span><br class="calibre10"/>      <span class="FontName">for (final UserRegistration userRegistration : items) {</span><br class="calibre10"/>         <span class="FontName">UserRegistration registeredUser = userRegistrationService.registerUser(userRegistration);</span><br class="calibre10"/>         <span class="FontName">logger.debug("Registered: {}",ToStringBuilder.reflectionToString(registeredUser));</span><br class="calibre10"/>      <span class="FontName">}</span><br class="calibre10"/>   <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Here, you’ve wired in the service’s client interface. You simply loop through the <span class="FontName">UserRegistration</span> objects and invoke the service, which in turn hands you back an identical instance of <span class="FontName">UserRegistration</span>. If you remove the gratuitous spacing, curly brackets, and logging output, it becomes two lines of code to satisfy the requirement.</p>
<p class="indent">The interface for <span class="FontName">UserRegistrationService</span> follows:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springbatch;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.Collection;</span><br class="calibre10"/><span class="FontName">import java.util.Date;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface UserRegistrationService {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">Collection&lt;UserRegistration&gt; getOutstandingUserRegistrationBatchForDate(</span><br class="calibre10"/>        <span class="FontName">int quantity, Date date);</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">UserRegistration registerUser(</span><br class="calibre10"/>        <span class="FontName">UserRegistration userRegistrationRegistration);</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In our example, we have no particular implementation for the interface, as it is irrelevant: it could be any interface that Spring Batch doesn’t know about already.</p>
<p id="Sec21" class="Heading">12-4. Processing Input Before Writing</p>
<p id="Sec22" class="Heading1">Problem</p>
<p class="noindent">While transferring data directly from a spreadsheet or CSV dump might be useful, one can imagine having to do some sort of processing on the data before it’s written. Data in a CSV<a id="cXXX.870" class="calibre5"></a> file, and more generally from any source, is not usually exactly the way you expect it to be or immediately suitable for writing. Just because Spring Batch can coerce it into a POJO on your behalf, that doesn’t mean the state of the data is correct. There may be additional data that you need to infer or fill in from other services before the data is suitable for writing.</p>
<p id="Sec23" class="Heading1">Solution</p>
<p class="noindent">Spring Batch will let you do processing on <span class="FontName">reader</span> output<a id="cXXX.871" class="calibre5"></a>. This processing can do virtually anything to the output before it gets passed to the <span class="FontName">writer</span>, including changing the type of the data.</p>
<p id="Sec24" class="Heading1">How It Works</p>
<p class="noindent">Spring Batch gives the implementor a chance to perform any custom logic on the data read from <span class="FontName">reader</span>. The <span class="FontName">processor</span> attribute on the <span class="FontName">chunk</span> element expects a reference to a bean of the interface <span class="FontName">org.springframework.batch.item.ItemProcessor&lt;I,O&gt;</span>. Thus, the revised definition for the <span class="FontName">job</span> from the previous recipe looks like this:</p>
<pre class="calibre11"><span class="FontName">&lt;job id="insertIntoDbFromCsvJob" job-repository="jobRepository"&gt;</span><br class="calibre10"/>     <span class="FontName">&lt;step id="step1"&gt;</span><br class="calibre10"/>         <span class="FontName">&lt;tasklet transaction-manager="transactionManager"&gt;</span><br class="calibre10"/>                        <span class="FontName">&lt;chunk</span><br class="calibre10"/>                 <span class="FontName">reader="csvFileReader"</span><br class="calibre10"/>                <b class="calibre4">processor = "userRegistrationValidationProcessor"</b><br class="calibre10"/>                <span class="FontName">writer="jdbcItemWriter"</span><br class="calibre10"/>                <span class="FontName">commit-interval="5"</span><br class="calibre10"/>             <span class="FontName">/&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/tasklet&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/step&gt;</span><br class="calibre10"/><span class="FontName">&lt;/job&gt;</span></pre>
<p class="indent">Or for those using Java based Job configuration</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">protected Step step1() {</span><br class="calibre10"/>    <span class="FontName">return steps.get("step1")</span><br class="calibre10"/>            <span class="FontName">.&lt;UserRegistration,UserRegistration&gt;chunk(5)</span><br class="calibre10"/>            <span class="FontName">.reader(csvFileReader())</span><br class="calibre10"/>            <b class="calibre4">.processor(userRegistrationValidationItemProcessor())</b><br class="calibre10"/>            <span class="FontName">.writer(jdbcItemWriter())</span><br class="calibre10"/>            <span class="FontName">.build();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The goal is to do certain validations on the data before you authorize it to be written to the database. If you determine the record is invalid, you can stop further processing by returning <span class="FontName">null</span> from the <span class="FontName">ItemProcessor&lt;I,O&gt;</span>. This is crucial and provides a necessary safeguard. One thing that you want to do is ensure that the data is the right format (for example, the schema may require a valid two-letter state name instead of the longer full state name). Telephone numbers<a id="cXXX.872" class="calibre5"></a> are expected to follow a certain format, and you can use this processor to strip the telephone number of any extraneous characters, leaving only a valid (in the United States) ten-digit phone number. The same applies for U.S. zip codes<a id="cXXX.873" class="calibre5"></a>, which consist of five characters and optionally a hyphen followed by a four-digit code. Finally, while a constraint guarding against duplicates is best implemented in the database, there may very well be some other eligibility criteria for a record that can be met only by querying the system before insertion.</p>
<p class="indent">Here’s the configuration for the <span class="FontName">ItemProcessor</span>:<a id="cXXX.874" class="calibre5"></a></p>
<pre class="calibre11"><span class="FontName">&lt;beans:bean id="userRegistrationValidationProcessor"</span><br class="calibre10"/><span class="FontName">class="com.apress.springrecipes.springbatch.UserRegistrationValidationItemProcessor" /&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">The Java config equivalent</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">ItemProcessor&lt;UserRegistration, UserRegistration&gt; userRegistrationValidationItemProcessor() {</span><br class="calibre10"/>    <span class="FontName">return new UserRegistrationValidationItemProcessor();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In the interest of keeping this class short, I won’t reprint it in its entirety, but the salient bits<a id="cXXX.875" class="calibre5"></a> should be obvious:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springbatch;</span><br class="calibre10"/><span class="FontName">import java.util.Arrays;</span><br class="calibre10"/><span class="FontName">import java.util.Collection;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.apache.commons.lang3.StringUtils;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.StepExecution;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.ItemProcessor;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.springbatch.UserRegistration;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class UserRegistrationValidationItemProcessor</span><br class="calibre10"/>  <b class="calibre4">implements ItemProcessor&lt;UserRegistration, UserRegistration&gt; {</b><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private String stripNonNumbers(String input) { /* ... */ }</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private boolean isTelephoneValid(String telephone) { /* ... */ }</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private boolean isZipCodeValid(String zip) { /* ... */ }</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private boolean isValidState(String state) { /* ... */ }</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public UserRegistration process(UserRegistration input) throws Exception {</span><br class="calibre10"/>      <span class="FontName">String zipCode = stripNonNumbers(input.getZip());</span><br class="calibre10"/>      <span class="FontName">String telephone = stripNonNumbers(input.getPhoneNumber());</span><br class="calibre10"/>      <span class="FontName">String state = StringUtils.defaultString(input.getState());</span><br class="calibre10"/>      <span class="FontName">if (isTelephoneValid(telephone) &amp;&amp; isZipCodeValid(zipCode) &amp;&amp; isValidState(state)) {</span><br class="calibre10"/>         <span class="FontName">input.setZip(zipCode);</span><br class="calibre10"/>        <span class="FontName">input.setPhoneNumber(telephone );</span><br class="calibre10"/>        <span class="FontName">return input;</span><br class="calibre10"/>      <span class="FontName">}</span><br class="calibre10"/>      <span class="FontName">return null;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The class is a parameterized type. The type information<a id="cXXX.876" class="calibre5"></a> is the type of the input, as well as the type of the output. The input is what’s given to the method for processing, and the output is the returned data from the method. Because you’re not transforming anything in this example, the two parameterized types<a id="cXXX.877" class="calibre5"></a> are the same.</p>
<p class="indent">Once this process has completed, there’s a lot of useful information to be had in the Spring Batch metadata tables. Issue the following query on your database:</p>
<pre class="calibre11"><span class="FontName">select * from BATCH_STEP_EXECUTION;</span></pre>
<p class="indent">Among other things, you’ll get back the exit status of the job, how many commits occurred, how many items were read, and how many items were filtered. So if the preceding <span class="FontName">job</span> was run on a batch with a 100 rows, each item was read and passed through the processor, and it found 10 items invalid (it returned <span class="FontName">null</span> 10 times), the value for the <span class="FontName">filter_count</span> column would be 10. You could see that a 100 items were read from the <span class="FontName">read_count</span>. The <span class="FontName">write_count</span> column would reflect that 10 items didn’t make it and would show <span class="FontName">90</span>.</p>
<p id="Sec25" class="Heading2">Chaining Processors Together</p>
<p class="noindent">Sometimes you might want to add extra processing that isn’t congruous with the goals of the processor you’ve already set up. Spring Batch provides a convenience class<a id="cXXX.878" class="calibre5"></a>, <span class="FontName">CompositeItemProcessor&lt;I,O&gt;</span>, which forwards the output of the filter to the input of the successive filter. In this way, you can write many, singly focused <span class="FontName">ItemProcessor&lt;I,O&gt;</span>s and then reuse them and chain them as necessary:</p>
<pre class="calibre11"><span class="FontName">&lt;beans:bean id="compositeBankCustomerProcessor"</span><br class="calibre10"/><span class="FontName">class="org.springframework.batch.item.support.CompositeItemProcessor"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;beans:property name="delegates"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;beans:list&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;bean ref="creditScoreValidationProcessor"  /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;bean ref="salaryValidationProcessor" /&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;bean ref="customerEligibilityProcessor" /&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/beans:list&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/beans:property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans:bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;job job-repository="jobRepository" id="insertIntoDbFromCsvJob"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;step id="step1"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;tasklet transaction-manager="transactionManager"&gt;</span><br class="calibre10"/>                 <span class="FontName">&lt;chunk</span><br class="calibre10"/>                    <span class="FontName">reader="csvFileReader"</span><br class="calibre10"/>                    <span class="FontName">processor="compositeBankCustomerProcessor"</span><br class="calibre10"/>                    <span class="FontName">writer="jdbcItemWriter"</span><br class="calibre10"/>                    <span class="FontName">commit-interval="5"</span><br class="calibre10"/>                 <span class="FontName">/&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/tasklet&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/step&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/job&gt;</span></pre>
<p class="indent">The example created a very simple workflow. The first <span class="FontName">ItemProcessor&lt;T&gt;</span> will take an input of whatever’s coming from the <span class="FontName">ItemReader&lt;T&gt;</span> configured for this job, presumably a <span class="FontName">Customer</span> object. It will check the credit score of the <span class="FontName">Customer</span> and, if approved, forward the <span class="FontName">Customer</span> to the salary and income validation processor. If everything checks out there, the <span class="FontName">Customer</span><a id="cXXX.879" class="calibre5"></a> will be forwarded to the eligibility processor, where the system is checked for duplicates or any other invalid data. It will finally be forwarded to the <span class="FontName">writer</span> to be added to the output. If at any point in the three processors the <span class="FontName">Customer</span> fails a check, the executing <span class="FontName">ItemProcessor</span> can simply return <span class="FontName">null</span> and arrest processing.</p>
<p id="Sec26" class="Heading">12-5. Better Living through Transactions<a id="cXXX.880" class="calibre6"></a> <a id="cXXX.881" class="calibre6"></a></p>
<p id="Sec27" class="Heading1">Problem</p>
<p class="noindent">You want your reads and writes to be robust. Ideally, they’ll use transactions where appropriate and correctly react to exceptions.</p>
<p id="Sec28" class="Heading1">Solution</p>
<p class="noindent">Transaction capabilities<a id="cXXX.882" class="calibre5"></a> are built on top of the first class support already provided by the core Spring framework. Where relevant, Spring Batch surfaces the configuration so that you can control it. Within the context of chunk-oriented processing, it also exposes a lot of control over the frequency of commits, rollback semantics, and so on.</p>
<p id="Sec29" class="Heading1">How It Works</p>
<p id="Sec30" class="Heading2">Transactions</p>
<p class="noindent">Spring’s core framework<a id="cXXX.883" class="calibre5"></a> provides first-class support for transactions. You simply wire up a <span class="FontName">TransactionManager</span> and give Spring Batch a reference, just as you would in any regular <span class="FontName">JdbcTemplate</span> or <span class="FontName">HibernateTemplate</span> solution. As you build your Spring Batch solutions, you’ll be given opportunities to control how <span class="FontName">step</span>s behave in a transaction. You’ve already seen some of the support for transactions baked right in.</p>
<p class="indent">The <span class="FontName">batch.xml</span> file, used in all these examples, established a <span class="FontName">BasicDataSource</span> and a <span class="FontName">DataSourceTransactionManager</span> bean. The <span class="FontName">TransactionManager</span> and <span class="FontName">BasicDataSource</span><a id="cXXX.884" class="calibre5"></a> were then wired to the <span class="FontName">JobRepository</span>, which was in turn wired to the <span class="FontName">JobLauncher</span>, which you used to launch all jobs thus far. This enabled all the metadata your <span class="FontName">job</span>s create to be written to the database in a transactional way.</p>
<p class="indent">You might wonder why there is no explicit mention of the <span class="FontName">TransactionManager</span> when you configured the <span class="FontName">JdbcItemWriter</span> with a reference to <span class="FontName">dataSource</span>. The transaction manager reference can be specified, but in your solutions, it wasn’t required because Spring Batch will, by default, try to pluck the <span class="FontName">PlatformTransactionManager</span> named <span class="FontName">transactionManager</span> from the context and use it. If you want to explicitly configure this, you can specify the <span class="FontName">transactionManager</span> property on the <span class="FontName">tasklet</span> element. A simple <span class="FontName">TransactionManager</span> for JDBC work might look like this:</p>
<pre class="calibre11"><span class="FontName">&lt;bean id="myCustomTransactionManager"<br class="calibre10"/>       class="org.springframework.jdbc.datasource.</span><span class="FontName">DataSourceTransactionManager"</span><br class="calibre10"/><span class="FontName">      p:dataSource-ref="dataSource" /&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;job job-repository="jobRepository" id="insertIntoDbFromCsvJob"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;step id="step1"&gt;</span><br class="calibre10"/>            <b class="calibre4">&lt;tasklet transaction-manager="myCustomTransactionManager" &gt;</b><br class="calibre10"/>                <span class="FontName">&lt;!--  ...  --&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;/tasklet&gt;</span><br class="calibre10"/>         <span class="FontName">&lt;/step&gt;</span><br class="calibre10"/><span class="FontName">&lt;/job&gt;</span><br class="calibre10"/>    <span class="FontName">...</span></pre>
<p class="indent">When working with Java based configuration<a id="cXXX.885" class="calibre5"></a> you can use the transactionManager method to set the transaction manager.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">protected Step step1() {</span><br class="calibre10"/>    <span class="FontName">return steps.get("step1")</span><br class="calibre10"/>            <span class="FontName">.&lt;UserRegistration,UserRegistration&gt;chunk(5)</span><br class="calibre10"/>            <span class="FontName">.reader(csvFileReader())</span><br class="calibre10"/>            <span class="FontName">.processor(userRegistrationValidationItemProcessor())</span><br class="calibre10"/>            <span class="FontName">.writer(jdbcItemWriter())</span><br class="calibre10"/>            <b class="calibre4">.transactionManager(new DataSourceTransactionManager(dataSource))</b><br class="calibre10"/>            <span class="FontName">.build();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Items read from an <span class="FontName">ItemReader&lt;T&gt;</span> are normally aggregated. If a commit on the <span class="FontName">ItemWriter&lt;T&gt;</span> fails, the aggregated items are kept and then resubmitted. This process is efficient and works most of the time. One place where it breaks semantics is when reading from a transactional message queue. Reads from a message queue<a id="cXXX.886" class="calibre5"></a> can and should be rolled back if the transaction they participate in (in this case, the transaction for the <span class="FontName">writer</span>) fails:</p>
<pre class="calibre11"><span class="FontName">&lt;tasklet transaction-manager="customTransactionManager" &gt;</span><br class="calibre10"/>    <span class="FontName">&lt;chunk</span><br class="calibre10"/>        <span class="FontName">reader="jmsItemReader" is-reader-transactional-queue="true"</span><br class="calibre10"/>        <span class="FontName">processor="userRegistrationValidationProcessor"</span><br class="calibre10"/>        <span class="FontName">writer="jdbcItemWriter"</span><br class="calibre10"/>        <span class="FontName">commit-interval="5" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;/tasklet&gt;</span></pre>
<p class="indent">Or in Java config</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">protected Step step1() {</span><br class="calibre10"/>    <span class="FontName">return steps.get("step1")</span><br class="calibre10"/>            <span class="FontName">.&lt;UserRegistration,UserRegistration&gt;chunk(5)</span><br class="calibre10"/>            <span class="FontName">.reader(csvFileReader())</span><b class="calibre4">.readerIsTransactionalQueue()</b><br class="calibre10"/>            <span class="FontName">.processor(userRegistrationValidationItemProcessor())</span><br class="calibre10"/>            <span class="FontName">.writer(jdbcItemWriter())</span><br class="calibre10"/>            <span class="FontName">.transactionManager(new DataSourceTransactionManager(dataSource))</span><br class="calibre10"/>            <span class="FontName">.build();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec31" class="Heading2">Rollbacks<a id="cXXX.887" class="calibre6"></a></p>
<p class="noindent">Handling the simple case (“read X items, and every Y items, commit a database transaction every Y items”) is easy. Spring Batch excels in the robustness it surfaces as simple configuration options for the edge and failure cases.</p>
<p class="indent">If a write fails on an <span class="FontName">ItemWriter</span>, or some other exception occurs in processing, Spring Batch will roll back the transaction. This is valid handling for a majority of the cases. There may be some scenarios when you want to control which exceptional cases cause the transaction to roll back.</p>
<p class="indent">You can use the <span class="FontName">no-rollback-exception-classes</span> element to configure this for the <span class="FontName">step</span>. The value is a list of <span class="FontName">Exception</span> classes that should not cause the transaction to roll back:</p>
<pre class="calibre11"><span class="FontName">&lt;step id = "step2"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;tasklet&gt;</span><br class="calibre10"/>               <span class="FontName">&lt;chunk reader="reader" writer="writer" commit-interval="10" /&gt;</span><br class="calibre10"/>                <b class="calibre4">&lt;no-rollback-exception-classes&gt;</b><br class="calibre10"/>                    <b class="calibre4">&lt;include class="com.yourdomain.exceptions.YourBusinessException"/&gt;</b><br class="calibre10"/>                <b class="calibre4">&lt;/no-rollback-exception-classes&gt;</b><br class="calibre10"/>        <span class="FontName">&lt;/tasklet&gt;</span><br class="calibre10"/><span class="FontName">&lt;/step&gt;</span></pre>
<p class="indent">When using Java based configuration to enable rollbacks first the step needs to be a fault tolerant step, which in turn can be used to specify the no-rollback exceptions. First use <span class="FontName">faultTolerant()</span> to obtain a fault tolerant step, next the <span class="FontName">skipLimit()</span> method can be used to specify the number of ignored rollbacks before actually stopping the job execution, finally the <span class="FontName">noRollback()</span> method can be used to specify the exceptions which don’t trigger a rollback. To specify multiple exceptions you can simply chain calls to the <span class="FontName">noRollback ()</span> method.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">protected Step step1() {</span><br class="calibre10"/>    <span class="FontName">return steps.get("step1")</span><br class="calibre10"/>            <span class="FontName">.&lt;UserRegistration,UserRegistration&gt;chunk(10)</span><br class="calibre10"/>            <b class="calibre4">.faultTolerant()</b><br class="calibre10"/>            <b class="calibre4">.noRollback(com.yourdomain.exceptions.YourBusinessException.class)</b><br class="calibre10"/>            <span class="FontName">.reader(csvFileReader())</span><br class="calibre10"/>            <span class="FontName">.processor(userRegistrationValidationItemProcessor())</span><br class="calibre10"/>            <span class="FontName">.writer(jdbcItemWriter())</span><br class="calibre10"/>            <span class="FontName">.build();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec32" class="Heading">12-6. Retrying<a id="cXXX.888" class="calibre6"></a> <a id="cXXX.889" class="calibre6"></a></p>
<p id="Sec33" class="Heading1">Problem</p>
<p class="noindent">You are dealing with a requirement for functionality that may fail but is not transactional. Perhaps it is transactional but unreliable. You want to work with a resource that may fail when you try to read from or write to it. It may fail because of networking connectivity because an endpoint is down or for any other number of reasons. You know that it will likely be back up soon, though, and that it should be retried.</p>
<p id="Sec34" class="Heading1">Solution</p>
<p class="noindent">Use Spring Batch’s retry capabilities to systematically retry the read or write.</p>
<p id="Sec35" class="Heading1">How It Works</p>
<p class="noindent">As you saw in the last recipe, it’s easy to handle transactional resources<a id="cXXX.890" class="calibre5"></a> with Spring Batch. When it comes to transient or unreliable resources, a different tack is required. Such resources tend to be distributed or manifest problems that eventually resolve themselves. Some (such as web services) cannot inherently participate in a transaction because of their distributed nature. There are products that can start a transaction on one server and propagate the transactional context to a distributed server and complete it there, although this tends to be very rare and inefficient. Alternatively, there’s good support for distributed (“global” or XA) transactions if you can use it. Sometimes, however, you may be dealing with a resource that isn’t either of those. A common example might be a call made to a remote service<a id="cXXX.891" class="calibre5"></a>, such as an RMI service or a REST endpoint. Some invocations will fail but may be retried with some likelihood of success in a transactional scenario. For example, an update to the database resulting in <span class="FontName">org.springframework.dao.DeadlockLoserDataAccessException</span> might be usefully retried.</p>
<p id="Sec36" class="Heading2">Configuring a Step</p>
<p class="noindent">The simplest example is in the configuration of a <span class="FontName">step</span>. Here, you can specify exception classes on which to retry the operation. As with the rollback exceptions<a id="cXXX.892" class="calibre5"></a>, you can delimit this list of exceptions with newlines or commas:</p>
<pre class="calibre11"><span class="FontName">&lt;step id = "step23"&gt;</span><br class="calibre10"/><span class="FontName">&lt;tasklet transaction-manager="transactionManager"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;chunk reader="csvFileReader" writer="jdbcItemWriter" commit-interval="10"</span><br class="calibre10"/>               <span class="FontName">retry-limit="3" cache-capacity="10"&gt;</span><br class="calibre10"/>             <span class="FontName">&lt;retryable-exception-classes&gt;</span><br class="calibre10"/>                 <span class="FontName">&lt;include class="org.springframework.dao.DeadlockLoserDataAccessException"/&gt;</span><br class="calibre10"/>             <span class="FontName">&lt;/retryable-exception-classes&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/chunk&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/tasklet&gt;</span><br class="calibre10"/><span class="FontName">&lt;/step&gt;</span></pre>
<p class="indent">When using Java based configuration to enable retrying first the step needs to be a fault tolerant step<a id="cXXX.893" class="calibre5"></a>, which in turn can be used to specify the retry limit and retryable exceptions. First use <span class="FontName">faultTolerant()</span> to obtain a fault tolerant step, next the <span class="FontName">retryLimit()</span> method can be used to specify the number of retry attempts, finally the <span class="FontName">retry()</span> method can be used to specify the exceptions which trigger a retry. To specify multiple exceptions you can simply chain calls to the <span class="FontName">retry()</span> method.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">protected Step step1() {</span><br class="calibre10"/>    <span class="FontName">return steps.get("step1")</span><br class="calibre10"/>            <span class="FontName">.&lt;UserRegistration,UserRegistration&gt;chunk(10)</span><br class="calibre10"/>            <b class="calibre4">.faultTolerant()</b><br class="calibre10"/>            <b class="calibre4">.retryLimit(3).retry(DeadlockLoserDataAccessException.class)</b><br class="calibre10"/>            <span class="FontName">.reader(csvFileReader())</span><br class="calibre10"/>            <span class="FontName">.writer(jdbcItemWriter())</span><br class="calibre10"/>            <span class="FontName">.transactionManager(transactionManager)</span><br class="calibre10"/>            <span class="FontName">.build();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec37" class="Heading2">Retry Template</p>
<p class="noindent">Alternatively, you can leverage Spring Retry support for retries and recovery in your own code. For example, you can have a custom <span class="FontName">ItemWriter&lt;T&gt;</span> in which retry functionality is desired or even an entire service interface for which retry support is desired.</p>
<p class="indent">Spring Batch supports these scenarios through the <span class="FontName">RetryTemplate</span> that (much like its various other <span class="FontName">Template</span> cousins) isolates your logic from the nuances of retries and instead enables you to write the code as though you were only going to attempt it once. Let Spring Batch handle everything else through declarative configuration.</p>
<p class="indent">The <span class="FontName">RetryTemplate</span><a id="cXXX.894" class="calibre5"></a> supports many use cases, with convenient APIs to wrap otherwise tedious retry/fail/recover cycles in concise, single-method invocations.</p>
<p class="indent">Let’s take a look at the modified version of a simple <span class="FontName">ItemWriter&lt;T&gt;</span> from Recipe 12.4 on how to write a custom <span class="FontName">ItemWriter&lt;T&gt;.</span> The solution was simple enough and would ideally work all the time. It fails to handle the error cases for the service, however. When dealing with RPC), always proceed as if it’s almost impossible for things to go right; the service itself may surface a semantic or system violation. An example might be a duplicate database key, invalid credit card number, and so on. This is true whether the service is distributed or in-VM, of course.</p>
<p class="indent">Next, the RPC layer<a id="cXXX.895" class="calibre5"></a> below the system may also fault. Here’s the rewritten code, this time allowing for retries:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springbatch;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.List;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.apache.commons.lang3.builder.ToStringBuilder;</span><br class="calibre10"/><span class="FontName">import org.sfl4j.Logger;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.item.ItemWriter;</span><br class="calibre10"/><span class="FontName">import org.springframework.retry.RetryCallback;</span><br class="calibre10"/><span class="FontName">import org.springframework.retry.RetryContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.retry.support.RetryTemplate;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">/**</span><br class="calibre10"/><span class="FontName">* This class writes the user registration by calling an RPC service (whose</span><br class="calibre10"/> <span class="FontName">* client interface is wired in using Spring</span><br class="calibre10"/> <span class="FontName">*/</span><br class="calibre10"/><span class="FontName">public class RetryableUserRegistrationServiceItemWriter implements ItemWriter&lt;UserRegistration&gt;{</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">private static final Logger logger = LoggerFactory.getLogger(RetryableUserRegistrationServiceItemWriter.class);</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">// this is the client interface to an HTTP Invoker service.</span><br class="calibre10"/>   <span class="FontName">@Autowired</span><br class="calibre10"/>   <span class="FontName">private UserRegistrationService userRegistrationService;</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">@Autowired</span><br class="calibre10"/>   <span class="FontName">private RetryTemplate retryTemplate;</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">/**</span><br class="calibre10"/>    <span class="FontName">* takes aggregated input from the reader and 'writes' them using a custom</span><br class="calibre10"/>    <span class="FontName">* implementation.</span><br class="calibre10"/>    <span class="FontName">*/</span><br class="calibre10"/>   <span class="FontName">public void write(List&lt;? extends UserRegistration&gt; items)</span><br class="calibre10"/>    <span class="FontName">throws Exception {</span><br class="calibre10"/>      <span class="FontName">for (final UserRegistration userRegistration : items) {</span><br class="calibre10"/>         <span class="FontName">User registeredUser = retryTemplate.execute(</span><br class="calibre10"/>         <span class="FontName">new RetryCallback&lt;User&gt;() {</span><br class="calibre10"/>            <span class="FontName">public User doWithRetry(RetryContext context) throws Exception {</span><br class="calibre10"/>               <span class="FontName">return userRegistrationService.registerUser(userRegistration);</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>         <span class="FontName">});</span><br class="calibre10"/>         <span class="FontName">logger.debug("Registered: {}", ToStringBuilder.reflectionToString(registeredUser));</span><br class="calibre10"/>      <span class="FontName">}</span><br class="calibre10"/>   <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">As you can see, the code hasn’t changed much, and the result is much more robust. The <span class="FontName">RetryTemplate</span> itself is configured in the Spring context, although it’s trivial to create in code. I declare it in the Spring context only because there is some surface area for configuration when creating the object, and I try to let Spring handle the configuration.</p>
<p class="indent">One of the more useful settings for the <span class="FontName">RetryTemplate</span> is the <span class="FontName">BackOffPolicy</span><a id="cXXX.896" class="calibre5"></a> in use. The <span class="FontName">BackOffPolicy</span> dictates how long the <span class="FontName">RetryTemplate</span> should back off between retries. Indeed, there’s even support for growing the delay between retries after each failed attempt to avoid lock stepping with other clients attempting the same invocation. This is great for situations in which there are potentially many concurrent attempts on the same resource and a race condition may ensue. There are other <span class="FontName">BackOffPolicies</span>, including one that delays retries by a fixed amount called <span class="FontName">FixedBackOffPolicy</span>.</p>
<pre class="calibre11"><span class="FontName">&lt;beans:bean id="retryTemplate" class="org.springframework.retry.support.RetryTemplate"&gt;</span><br class="calibre10"/>     <span class="FontName">&lt;beans:property name="backOffPolicy" &gt;</span><br class="calibre10"/>     <b class="calibre4">&lt;beans:bean class="org.springframework.batch.retry.backoff.ExponentialBackOffPolicy"</b><br class="calibre10"/>     <b class="calibre4">p:initialInterval="1000" p:maxInterval="10000" p:multiplier="2" /&gt;</b><br class="calibre10"/>     <span class="FontName">&lt;/beans:property&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans:bean&gt;</span></pre>
<p class="indent">You have configured a <span class="FontName">RetryTemplate</span>’s <span class="FontName">backOffPolicy</span> so that the <span class="FontName">backOffPolicy</span> will wait 1 second (1,000 milliseconds) before the initial retry. Subsequent attempts will double that value (the growth is influenced by the multiplier). It’ll continue until the <span class="FontName">maxInterval</span> is met, at which point all subsequent retry intervals will level off, retrying at a consistent interval.</p>
<p id="Sec38" class="Heading2">AOP-Based Retries</p>
<p class="noindent">An alternative is an AOP advisor<a id="cXXX.897" class="calibre5"></a> provided by Spring Batch that will wrap invocations of methods whose success is not guaranteed in retries, as you did with the <span class="FontName">RetryTemplate</span>. In the previous example, you rewrote an <span class="FontName">ItemWriter&lt;T&gt;</span> to make use of the template. Another approach might be to merely advise the entire <span class="FontName">userRegistrationService</span> proxy with this retry logic. In this case, the code could go back to the way it was in the original example, with no <span class="FontName">RetryTemplate</span>!</p>
<pre class="calibre11"><span class="FontName">&lt;aop:config&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;aop:pointcut id="remote"</span><br class="calibre10"/>        <span class="FontName">expression="execution(* com..*UserRegistrationService.*(..))" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;aop:advisor pointcut-ref="remote"  advice-ref="retryAdvice" order="-1"/&gt;</span><br class="calibre10"/><span class="FontName">&lt;/aop:config&gt;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans:bean id="retryAdvice" class="org.springframework.retry.interceptor.RetryOperationsInterceptor"/&gt;</span></pre>
<p id="Sec39" class="Heading">12-7. Controlling Step Execution</p>
<p id="Sec40" class="Heading1">Problem</p>
<p class="noindent">You want to control how <span class="FontName">step</span>s are executed, perhaps to eliminate a needless waste of time by introducing concurrency or by executing <span class="FontName">step</span>s only if a condition is <span class="FontName">true</span>.</p>
<p id="Sec41" class="Heading1">Solution</p>
<p class="noindent">There are different ways to change the runtime profile<a id="cXXX.898" class="calibre5"></a> of your <span class="FontName">job</span>s, mainly by exerting control over the way <span class="FontName">step</span>s are executed: concurrent <span class="FontName">step</span>s, decisions, and sequential <span class="FontName">step</span>s.</p>
<p id="Sec42" class="Heading1">How It Works</p>
<p class="noindent">Thus far, you have explored running one <span class="FontName">step</span> in a <span class="FontName">job</span>. Typical <span class="FontName">job</span>s of almost any complexity will have multiple <span class="FontName">step</span>s, however. A <span class="FontName">step</span> provides a boundary (transactional or not) to the beans and logic it encloses. A <span class="FontName">step</span> can have its own <span class="FontName">reader</span>, <span class="FontName">writer</span>, and <span class="FontName">processor</span>. Each <span class="FontName">step</span> helps decide what the next <span class="FontName">step</span> will be. A <span class="FontName">step</span> is isolated and provides focused functionality that can be assembled using the updated schema and configuration options in Spring Batch in very sophisticated workflows. In fact, some of the concepts and patterns you’re about to see will be very familiar if you have an interest in business process management (BPM)<a id="cXXX.899" class="calibre5"></a><a id="cXXX.900" class="calibre5"></a> <a id="cXXX.901" class="calibre5"></a>systems and workflows. BPM provides many constructs for process or job control that are similar to what you’re seeing here.</p>
<p class="indent">A <span class="FontName">step</span> often corresponds to a bullet point when you outline the definition of a <span class="FontName">job</span> on paper. For example, a batch job to load the daily sales and produce a report might be proposed as follows:</p>
<p class="indent"><b class="calibre4">Daily Sales Report</b><a id="cXXX.902" class="calibre5"></a> <b class="calibre4">Job</b></p>
<ol class="OrderedList">
<li value="1" class="calibre17">Load customers from the CSV file into the database.</li>
<li value="2" class="calibre17">Calculate daily statistics, and write to a report file.</li>
<li value="3" class="calibre17">Send messages to the message queue to notify an external system of the successful registration for each of the newly loaded customers.</li></ol>
<p id="Sec43" class="Heading2">Sequential Steps</p>
<p class="noindent">In the previous example, there’s an implied sequence between the first two <span class="FontName">step</span>s: the audit file<a id="cXXX.903" class="calibre5"></a> can’t be written until all the registrations have completed. This sort of relationship is the default relationship between two <span class="FontName">step</span>s. One occurs after the other. Each <span class="FontName">step</span> executes with its own execution context and shares only a parent <span class="FontName">job</span> execution context and an order.</p>
<pre class="calibre11"><span class="FontName">&lt;job    id="nightlyRegistrationsJob"</span><br class="calibre10"/>    <span class="FontName">job-repository="jobRepository"&gt;</span><br class="calibre10"/>    <b class="calibre4">&lt;step id="loadRegistrations" next="reportStatistics" &gt;</b><br class="calibre10"/>          <span class="FontName">&lt;tasklet ref = "tasklet1"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/step&gt;</span><br class="calibre10"/>    <b class="calibre4">&lt;step id="reportStatistics" next="..." &gt;</b><br class="calibre10"/>          <span class="FontName">&lt;tasklet ref  ="tasklet2"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/step&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;!-- ... other steps ...  --&gt;</span><br class="calibre10"/><span class="FontName">&lt;/job&gt;</span></pre>
<p class="indent">Notice that you specify the next attribute on the <span class="FontName">step</span> elements to tell processing which <span class="FontName">step</span> to go to next.</p>
<p class="indent">When using Java based configuration the <span class="FontName">next()</span> method can be used to specify which step to execute next.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public Job nightlyRegistrationsJob () {</span><br class="calibre10"/>    <span class="FontName">return jobs.get("nightlyRegistrationsJob ")</span><br class="calibre10"/>            <span class="FontName">.start(loadRegistrations())</span><br class="calibre10"/>            <b class="calibre4">.next(reportStatistics())</b><br class="calibre10"/>            <span class="FontName">.next(...)</span><br class="calibre10"/>            <span class="FontName">.build();</span><br class="calibre10"/>    <span class="FontName">}</span></pre>
<p id="Sec44" class="Heading2">Concurrency</p>
<p class="noindent">The first version of Spring Batch was oriented toward batch processing inside the same thread and, with some alteration, perhaps inside the virtual machine<a id="cXXX.904" class="calibre5"></a>. There were workarounds, of course, but the situation was less than ideal.</p>
<p class="indent">In the outline for this example <span class="FontName">job</span>, the first <span class="FontName">step</span> had to come before the second two because the second two are dependent on the first. The second two, however, do not share any such dependencies. There’s no reason why the audit log couldn’t be written at the same time as the JMS messages are being delivered. Spring Batch provides the capability to fork processing to enable just this sort of arrangement:</p>
<pre class="calibre11"><span class="FontName">&lt;job job-repository="jobRepository" id="insertIntoDbFromCsvJob"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;step id="loadRegistrations" next="finalizeRegistrations"&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;!--  ...  --&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/step&gt;</span><br class="calibre10"/>    <b class="calibre4">&lt;split id="finalizeRegistrations" &gt;</b><br class="calibre10"/>        <span class="FontName">&lt;flow&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;step id="reportStatistics" &gt;&lt;!--  ...  --&gt;&lt;/step&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/flow&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;flow&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;step id="sendJmsNotifications" &gt; &lt;!--  ...  --&gt;&lt;/step&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/flow&gt;</span><br class="calibre10"/>    <b class="calibre4">&lt;/split&gt;</b><br class="calibre10"/><span class="FontName">&lt;/job&gt;</span></pre>
<p class="indent">Or for those using Java based configuration can use the <span class="FontName">split()</span> method<a id="cXXX.905" class="calibre5"></a> on the job builder. To make a step into a flow the <span class="FontName">flow()</span> method of the job builder can be used then to add more steps to the flow these can be added with the <span class="FontName">next()</span> method.</p>
<p class="indent">The <span class="FontName">split()</span> method requires a <span class="FontName">TaskExecutor</span><a id="cXXX.906" class="calibre5"></a> to be set, see Recipe 3-22 for more information on scheduling and concurrency.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public Job insertIntoDbFromCsvJob() {</span><br class="calibre10"/>    <b class="calibre4">JobBuilder builder = jobs.get("insertIntoDbFromCsvJob");</b><br class="calibre10"/>    <span class="FontName">return builder</span><br class="calibre10"/>            <span class="FontName">.start(loadRegistrations())</span><br class="calibre10"/>            <span class="FontName">.</span><b class="calibre4">split(taskExecutor())</b><br class="calibre10"/>                <b class="calibre4">.add(</b><br class="calibre10"/>                    <b class="calibre4">builder.flow(reportStatistics()),</b><br class="calibre10"/>                    <b class="calibre4">builder.flow(sendJmsNotifications()))</b><br class="calibre10"/>            <span class="FontName">.build();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In this example, there’s nothing to prevent you from having many <span class="FontName">step</span>s within the <span class="FontName">flow</span> elements, nor was there anything preventing you from having more <span class="FontName">step</span>s after the <span class="FontName">split</span> element. The <span class="FontName">split</span> element, like the <span class="FontName">step</span> elements, takes a <span class="FontName">next</span> attribute as well.</p>
<p class="indent">Spring Batch provides a mechanism to offload processing to another process. This distribution requires some sort of durable, reliable connection. This is a perfect use of JMS because it’s rock-solid and transactional, fast, and reliable. Spring Batch support is modeled at a slightly higher level, on top of the Spring Integration abstractions for Spring Integration channels. This support is not in the main Spring Batch code, it can be found in the <span class="FontName">spring-batch-integration</span> project<a id="cXXX.907" class="calibre5"></a>. Remote chunking lets individual <span class="FontName">step</span>s read and aggregate items as usual in the main thread. This <span class="FontName">step</span> is called the <span class="FontName">Master</span>. Items read are sent to the <span class="FontName">ItemProcessor&lt;I,O&gt;</span>/<span class="FontName">ItemWriter&lt;T&gt;</span> running in another process (this is called the <span class="FontName">Slave</span>). If the <span class="FontName">Slave</span> is an aggressive consumer, you have a simple, generic mechanism to scale: work is instantly farmed out over as many JMS clients as you can throw at it. The <span class="FontName">aggressive-consumer</span> pattern refers to the arrangement of multiple JMS clients all consuming the same queue’s messages. If one client consumes a message and is busy processing, other idle queues will get the message instead. As long as there’s a client that’s idle, the message will be processed instantly.</p>
<p class="indent">Additionally, Spring Batch supports implicitly scaling out using a feature called <i class="calibre8">partitioning</i><a id="cXXX.908" class="calibre5"></a>. This feature is interesting because it’s built in and generally very flexible. You replace your instance of a <span class="FontName">step</span> with a subclass, <span class="FontName">PartitionStep</span>, which knows how to coordinate distributed executors and maintains the metadata for the execution of the <span class="FontName">step</span>, thus eliminating the need for a durable medium of communication as in the “remote chunking” technology.</p>
<p class="indent">The functionality here is also very generic. It could, conceivably, be used with any sort of grid fabric technology such as GridGain or Hadoop. Spring Batch ships with only a <span class="FontName">TaskExecutorPartitionHandler</span>, which executes <span class="FontName">step</span>s in multiple threads using a <span class="FontName">TaskExecutor</span> strategy. This simple improvement might be enough of a justification for this feature! If you’re really hurting, however, you can extend it.</p>
<p id="Sec45" class="Heading2">Conditional Steps with Statuses</p>
<p class="noindent">Using the <span class="FontName">ExitStatus</span><a id="cXXX.909" class="calibre5"></a> of a given job or <span class="FontName">step</span> to determine the next <span class="FontName">step</span> is the simplest example of a conditional flow. Spring Batch facilitates this through the use of the <span class="FontName">stop</span>, <span class="FontName">next</span>, <span class="FontName">fail</span>, and <span class="FontName">end</span> elements. By default, assuming no intervention, a <span class="FontName">step</span> will have an <span class="FontName">ExitStatus</span> that matches its <span class="FontName">BatchStatus</span>, which is a property whose values are defined in an enum and may be any of the following: <span class="FontName">COMPLETED</span>, <span class="FontName">STARTING</span>, <span class="FontName">STARTED</span>, <span class="FontName">STOPPING</span>, <span class="FontName">STOPPED</span>, <span class="FontName">FAILED</span>, <span class="FontName">ABANDONED</span>, or <span class="FontName">UNKNOWN</span>.</p>
<p class="indent">Let’s look at an example that executes one of two <span class="FontName">step</span>s based on the success of a preceding <span class="FontName">step</span>:</p>
<pre class="calibre11"><span class="FontName">&lt;step id="step1" &gt;</span><br class="calibre10"/>    <span class="FontName">&lt;next on="COMPLETED" to="step2" &gt; &lt;!--  ...  --&gt;&lt;/step&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;next on="FAILED" to="failureStep" &gt; &lt;!--  ...  --&gt;&lt;/step&gt;</span><br class="calibre10"/><span class="FontName">&lt;/step&gt;</span></pre>
<p class="indent">It’s also possible to provide a wildcard. This is useful if you want to ensure a certain behavior for any number of <span class="FontName">BatchStatus</span>, perhaps in tandem with a more specific <span class="FontName">next</span> element that matches only one <span class="FontName">BatchStatus</span>.</p>
<pre class="calibre11"><span class="FontName">&lt;step id="step1" &gt;</span><br class="calibre10"/>    <span class="FontName">&lt;next on="COMPLETED" to="step2" &gt; &lt;!--  ...  --&gt;&lt;/step&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;next on="*" to="failureStep" &gt; &lt;!--  ...  --&gt;&lt;/step&gt;</span><br class="calibre10"/><span class="FontName">&lt;/step&gt;</span></pre>
<p class="indent">In this example, you are instructing Spring Batch to perform some step based on any unaccounted-for <span class="FontName">ExitStatus</span>. Another option is to just stop processing altogether with a <span class="FontName">BatchStatus</span> of <span class="FontName">FAILED</span>. You can do this using the <span class="FontName">fail</span> element. A less aggressive rewrite of the preceding example might be the following:</p>
<pre class="calibre11"><span class="FontName">&lt;step id="step1" &gt;</span><br class="calibre10"/>    <span class="FontName">&lt;next on="COMPLETED" to="step2" /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;fail  on="FAILED"  /&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;!--  ...  --&gt;</span><br class="calibre10"/><span class="FontName">&lt;/step&gt;</span></pre>
<p class="indent">In all these examples, you’re reacting to the standard <span class="FontName">BatchStatus</span>es<a id="cXXX.910" class="calibre5"></a> that the Spring Batch framework provides. But it’s also possible to raise your own <span class="FontName">ExitStatus</span>. If, for example, you wanted the whole <span class="FontName">job</span> to fail with a custom <span class="FontName">ExitStatus</span> of <span class="FontName">"MAN DOWN"</span>, you might do something like this:</p>
<pre class="calibre11"><span class="FontName">&lt;step id="step1" next="step2"&gt;&lt;!--  ...  --&gt;&lt;/step&gt;</span><br class="calibre10"/><span class="FontName">&lt;step id="step2" ...&gt;</span><br class="calibre10"/>  <b class="calibre4">&lt;fail on="FAILED" exit-code="MAN DOWN "/&gt;</b><br class="calibre10"/>  <span class="FontName">&lt;next on="*" to="step3"/&gt;</span><br class="calibre10"/><span class="FontName">&lt;/step&gt;</span><br class="calibre10"/><span class="FontName">&lt;step id="step3"&gt;&lt;!--  ...  --&gt;&lt;/step&gt;</span></pre>
<p class="indent">Finally, if all you want to do is end processing with a <span class="FontName">BatchStatus</span> of <span class="FontName">COMPLETED</span>, you can use the <span class="FontName">end</span> element<a id="cXXX.911" class="calibre5"></a>. This is an explicit way of ending a flow as if it had run out of steps and incurred no errors.</p>
<pre class="calibre11"><span class="FontName">&lt;next on="COMPLETED" to="step2" /&gt;</span><br class="calibre10"/><span class="FontName">&lt;step id="step2" &gt;</span><br class="calibre10"/>  <span class="FontName">&lt;end on="COMPLETED"/&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;next on="FAILED" to="errorStep"/&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;!--  ...  --&gt;</span><br class="calibre10"/><span class="FontName">&lt;/step&gt;</span></pre>
<p class="indent">When using Java based configuration there is the on() method to specify what needs to happen. Either one can go to the next step, stop or end the job or explicitly fail the job. For these there are several helper methods<a id="cXXX.912" class="calibre5"></a> like <span class="FontName">to()</span>, <span class="FontName">stop()</span>, <span class="FontName">end()</span> and <span class="FontName">fail()</span> available on the builder.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public Job insertIntoDbFromCsvJob() {</span><br class="calibre10"/>    <span class="FontName">JobBuilder builder = jobs.get("insertIntoDbFromCsvJob");</span><br class="calibre10"/>    <span class="FontName">return builder</span><br class="calibre10"/>            <span class="FontName">.start(step1())</span><br class="calibre10"/>            <b class="calibre4">.on("FAILED").fail()</b><br class="calibre10"/>            <b class="calibre4">.on("COMPLETED").end()</b><br class="calibre10"/>            <b class="calibre4">.on("ERROR").to(errorStep())</b><br class="calibre10"/>            <b class="calibre4">.on("*").to(step2())</b><br class="calibre10"/>            <span class="FontName">.build();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec46" class="Heading2">Conditional Steps with Decisions</p>
<p class="noindent">If you want to vary the execution flow based on some logic more complex than a <span class="FontName">job</span>’s <span class="FontName">ExitStatus</span>es, you may give Spring Batch a helping hand by using a <span class="FontName">decision</span> element and providing it with an implementation of a <span class="FontName">JobExecutionDecider</span><a id="cXXX.913" class="calibre5"></a>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springbatch;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.JobExecution;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.StepExecution;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.job.flow.FlowExecutionStatus;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.job.flow.JobExecutionDecider;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class HoroscopeDecider implements JobExecutionDecider {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private boolean isMercuryIsInRetrograde (){ return Math.random() &gt; .9 ; }</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">public FlowExecutionStatus decide(JobExecution jobExecution,</b> <span class="FontName"></span><br class="calibre10"/>                                      <b class="calibre4">StepExecution stepExecution) {</b><br class="calibre10"/>        <b class="calibre4">if (isMercuryIsInRetrograde()) {</b><br class="calibre10"/>           <b class="calibre4">return new FlowExecutionStatus("MERCURY_IN_RETROGRADE");</b><br class="calibre10"/>        <b class="calibre4">}</b><br class="calibre10"/>        <b class="calibre4">return FlowExecutionStatus.COMPLETED;</b><br class="calibre10"/>    <b class="calibre4">}</b><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">All that remains is the XML configuration<a id="cXXX.914" class="calibre5"></a>:</p>
<pre class="calibre11"><span class="FontName">&lt;beans:bean id="horoscopeDecider" class="com.apress.springrecipes.springbatch.HoroscopeDecider"/&gt;</span>  <br class="calibre10"/><span class="FontName">&lt;job id="job"&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;step id="step1"  next="decision"  &gt;&lt;!--  ...  --&gt;&lt;/step&gt;</span><br class="calibre10"/>  <b class="calibre4">&lt;decision id="decision" decider="horoscopeDecider"&gt;</b><br class="calibre10"/>    <b class="calibre4">&lt;next on="MERCURY_IN_RETROGRADE" to="step2" /&gt;</b><br class="calibre10"/>    <b class="calibre4">&lt;next on="COMPLETED" to="step3" /&gt;</b><br class="calibre10"/>  <b class="calibre4">&lt;/decision&gt;</b><br class="calibre10"/>  <span class="FontName">&lt;step id="step2" next="step3"&gt; &lt;!--  ...  --&gt; &lt;/step&gt;</span><br class="calibre10"/>  <span class="FontName">&lt;step id="step3" parent="s3"&gt;  &lt;!--  ...  --&gt; &lt;/step&gt;</span><br class="calibre10"/><span class="FontName">&lt;/job&gt;</span></pre>
<p class="indent">The equivalent in Java config<a id="cXXX.915" class="calibre5"></a></p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public Job insertIntoDbFromCsvJob() {</span><br class="calibre10"/>    <span class="FontName">JobBuilder builder = jobs.get("insertIntoDbFromCsvJob");</span><br class="calibre10"/>    <span class="FontName">return builder</span><br class="calibre10"/>            <span class="FontName">.start(step1())</span><br class="calibre10"/>            <b class="calibre4">.next((horoscopeDecider())</b><br class="calibre10"/>                <b class="calibre4">.on("MERCURY_IN_RETROGRADE").to(step2())</b><br class="calibre10"/>                <b class="calibre4">.on(("COMPLETED ").to(step3())</b><br class="calibre10"/>            <span class="FontName">.build();</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec47" class="Heading">12-8. Launching a Job<a id="cXXX.916" class="calibre6"></a> <a id="cXXX.917" class="calibre6"></a></p>
<p id="Sec48" class="Heading1">Problem</p>
<p class="noindent">What deployment scenarios does Spring Batch support? How does Spring Batch launch? How does Spring Batch work with a system scheduler<a id="cXXX.918" class="calibre5"></a> such as <span class="FontName">cron</span> or <span class="FontName">autosys</span>, or from a web application?</p>
<p id="Sec49" class="Heading1">Solution</p>
<p class="noindent">Spring Batch works well in all environments that Spring runs: your public static void main, OSGi<a id="cXXX.919" class="calibre5"></a>, a web application—anywhere! Some use cases are uniquely challenging, though: it is rarely practical to run Spring Batch in the same thread as an HTTP response because it might end up stalling execution, for example. Spring Batch supports asynchronous execution for just this scenario. Spring Batch also provides a convenience class that can be readily used with <span class="FontName">cron</span> or <span class="FontName">autosys</span> to support launching <span class="FontName">job</span>s. Additionally, Spring’s excellent scheduler namespace provides a great mechanism to schedule jobs.</p>
<p id="Sec50" class="Heading1">How It Works</p>
<p class="noindent">Before you get into creating a solution, it’s important to know what options are available for deploying and running these solutions. All solutions require, at minimum, a <span class="FontName">job</span> and a <span class="FontName">JobLauncher</span>. You already configured these components in the previous recipe. The <span class="FontName">job</span> is configured in your Spring XML application context, as you’ll see later. The simplest example of launching a Spring Batch solution from Java code is about five lines of Java code, three if you’ve already got a handle to the <span class="FontName">ApplicationContext</span><a id="cXXX.920" class="calibre5"></a>!</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springbatch.;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.Job;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.JobParameters;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.JobParametersBuilder;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.launch.JobLauncher;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.Date;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) throws Throwable {</span><br class="calibre10"/>        <span class="FontName">ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("solution2.xml");</span><br class="calibre10"/><br class="calibre10"/>        <b class="calibre4">JobLauncher jobLauncher = ctx.getBean("jobLauncher", JobLauncher.class);</b><br class="calibre10"/>        <b class="calibre4">Job job = ctx.getBean("myJobName". Job.class);</b><br class="calibre10"/>        <b class="calibre4">JobExecution jobExecution = jobLauncher.run(job, new JobParameters());</b><br class="calibre10"/>    <b class="calibre4">}</b><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">As you can see, the <span class="FontName">JobLauncher</span> reference you configured previously is obtained and used to then launch an instance of a <span class="FontName">Job</span>. The result is a <span class="FontName">JobExecution</span><a id="cXXX.921" class="calibre5"></a>. You can interrogate the <span class="FontName">JobExecution</span> for information on the state of the <span class="FontName">Job</span>, including its exit status and runtime status.</p>
<pre class="calibre11"><span class="FontName">JobExecution jobExecution = jobLauncher.run(job, jobParameters);</span><br class="calibre10"/><span class="FontName">BatchStatus batchStatus = jobExecution.getStatus();</span><br class="calibre10"/><span class="FontName">while(batchStatus.isRunning()) {</span><br class="calibre10"/>        <span class="FontName">System.out.println( "Still running...");</span><br class="calibre10"/>        <span class="FontName">Thread.sleep( 10 * 1000 ); // 10 seconds</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You can also get the <span class="FontName">ExitStatus</span>:</p>
<pre class="calibre11"><span class="FontName">System.out.println( "Exit code: "+ jobExecution.getExitStatus().getExitCode());</span></pre>
<p class="indent">The <span class="FontName">JobExecution</span> also provides a lot of other very useful information like the create time of the <span class="FontName">Job</span>, the start time, the last updated date, and the end time—all as <span class="FontName">java.util.Date</span> instances. If you want to correlate the job back to the database, you’ll need the <span class="FontName">jobInstance</span> and the ID:</p>
<pre class="calibre11"><span class="FontName">JobInstance jobInstance = jobExecution.getJobInstance();</span><br class="calibre10"/><span class="FontName">System.out.println( "job instance Id: "+ jobInstance.getId());</span></pre>
<p class="indent">In our simple example, we use an empty <span class="FontName">JobParameters</span><a id="cXXX.922" class="calibre5"></a> instance. In practice, this will only work once. Spring Batch builds a unique key based on the parameters and uses to keep uniquely identify one run of a given <span class="FontName">Job</span> from another. You’ll learn about parameterizing a <span class="FontName">Job</span> in detail in the next recipe.</p>
<p id="Sec51" class="Heading2">Launching From a Web Application</p>
<p class="noindent">Launching a <span class="FontName">job</span> from a web application requires a slightly different approach, because the client thread (presumably an HTTP request) can’t usually wait for a batch job to finish. The ideal solution<a id="cXXX.923" class="calibre5"></a> is to have the job execute asynchronously when launched from a controller or action in the web tier, unattended by the client thread. Spring Batch supports this scenario through the use of a Spring <span class="FontName">TaskExecutor</span>. This requires a simple change to the configuration for the <span class="FontName">JobLauncher</span>, although the Java code can stay the same. Here, we will use a <span class="FontName">SimpleAsyncTaskExecutor</span><a id="cXXX.924" class="calibre5"></a> that will spawn a thread of execution and manage that thread without blocking.</p>
<pre class="calibre11"><span class="FontName">&lt;beans:bean id="jobLauncher"</span><br class="calibre10"/><span class="FontName">class="org.springframework.batch.execution.launch.support.SimpleJobLauncher"</span><br class="calibre10"/>        <span class="FontName">p:jobRepository-ref="jobRepository" &gt;</span><br class="calibre10"/>        <b class="calibre4">&lt;beans:property name="taskExecutor"&gt;</b><br class="calibre10"/>            <b class="calibre4">&lt;beans:bean class="org.springframework.core.task.SimpleAsyncTaskExecutor" /&gt;</b><br class="calibre10"/>        <b class="calibre4">&lt;/beans:property&gt;</b><br class="calibre10"/><span class="FontName">&lt;/beans:bean&gt;</span></pre>
<p class="indent">To do the same with Java Config requires a bit more work. As we cannot use the default settings anymore we need to add our own implementation of a <span class="FontName">BatchConfigurer</span> to configure the <span class="FontName">TaskExecutor</span> and add it to our <span class="FontName">SimpleJobLauncher</span>. For this implementation we used the <span class="FontName">DefaultBatchConfigurer</span><a id="cXXX.925" class="calibre5"></a> as a reference, we only reimplemented the <span class="FontName">createJobLauncher</span> method to add the <span class="FontName">TaskExecutor</span><a id="cXXX.926" class="calibre5"></a>.</p>
<pre class="calibre11"><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class CustomBatchConfigurer implements BatchConfigurer {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private DataSource dataSource;</span><br class="calibre10"/>    <span class="FontName">private PlatformTransactionManager transactionManager;</span><br class="calibre10"/>    <span class="FontName">private JobRepository jobRepository;</span><br class="calibre10"/>    <span class="FontName">private JobLauncher jobLauncher;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">public void setDataSource(DataSource dataSource) {</span><br class="calibre10"/>        <span class="FontName">this.dataSource = dataSource;</span><br class="calibre10"/>        <span class="FontName">this.transactionManager = new DataSourceTransactionManager(dataSource);</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">protected CustomBatchConfigurer() {}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Override</span><br class="calibre10"/>    <span class="FontName">public JobRepository getJobRepository() {</span><br class="calibre10"/>        <span class="FontName">return jobRepository;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Override</span><br class="calibre10"/>    <span class="FontName">public PlatformTransactionManager getTransactionManager() {</span><br class="calibre10"/>        <span class="FontName">return transactionManager;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Override</span><br class="calibre10"/>    <span class="FontName">public JobLauncher getJobLauncher() {</span><br class="calibre10"/>        <span class="FontName">return jobLauncher;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">public TaskExecutor taskExecutor() {</b><br class="calibre10"/>        <b class="calibre4">return new SimpleAsyncTaskExecutor();</b><br class="calibre10"/>    <b class="calibre4">}</b><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@PostConstruct</span><br class="calibre10"/>    <span class="FontName">public void initialize() throws Exception {</span><br class="calibre10"/>        <span class="FontName">this.jobRepository = createJobRepository();</span><br class="calibre10"/>        <span class="FontName">this.jobLauncher = createJobLauncher();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">protected JobLauncher createJobLauncher() throws Exception {</b><br class="calibre10"/>        <b class="calibre4">SimpleJobLauncher jobLauncher = new SimpleJobLauncher();</b><br class="calibre10"/>        <b class="calibre4">jobLauncher.setJobRepository(jobRepository);</b><br class="calibre10"/>        <b class="calibre4">jobLauncher.setTaskExecutor(taskExecutor());</b><br class="calibre10"/>        <b class="calibre4">return jobLauncher;</b><br class="calibre10"/>    <b class="calibre4">}</b><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">protected JobRepository createJobRepository() throws Exception {</span><br class="calibre10"/>        <span class="FontName">JobRepositoryFactoryBean factory = new JobRepositoryFactoryBean();</span><br class="calibre10"/>        <span class="FontName">factory.setDataSource(dataSource);</span><br class="calibre10"/>        <span class="FontName">factory.setTransactionManager(transactionManager);</span><br class="calibre10"/>        <span class="FontName">factory.afterPropertiesSet();</span><br class="calibre10"/>        <span class="FontName">return  (JobRepository) factory.getObject();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec52" class="Heading2">Running from the Command Line</p>
<p class="noindent">Another common use case is deployment of a batch process from a system scheduler such as <span class="FontName">cron</span> or <span class="FontName">autosys</span>, or even Window’s event scheduler. Spring Batch provides a convenience class that takes as its parameters the name of the XML application context (that contains <i class="calibre8">everything</i> required to run a <span class="FontName">job</span>) as well as the name of the <span class="FontName">job</span> bean itself. Additional parameters may be provided and used to parameterize the <span class="FontName">job</span>. These parameters must be in the form <span class="FontName">name=value</span>. An example invocation of this class on the command line (on a Linux/Unix system), assuming that you set up the classpath, might look like this:</p>
<pre class="calibre11"><span class="FontName">java CommandLineJobRunner jobs.xml hourlyReport date=`date +%m/%d/%Y` time=`date +%H`</span></pre>
<p class="indent">The <span class="FontName">CommandLineJobRunner</span><a id="cXXX.927" class="calibre5"></a> will even return system error codes (0 for success, 1 for failure, and 2 for an issue with loading the batch job) so that a shell (such as used by most system schedulers) can react or do something about the failure. More complicated return codes can be returned by creating and declaring a top-level bean that implements the interface <span class="FontName">ExitCodeMapper</span>, in which you can specify a more useful translation of exit status messages to integer-based error codes that the shell will see on process exit.</p>
<p id="Sec53" class="Heading2">Running On A Schedule</p>
<p class="noindent">Spring 3.0 debuts support for a scheduling framework<a id="cXXX.928" class="calibre5"></a> (see also Recipe 3-22). This framework lends itself perfectly to running Spring Batch. First, let’s modify our existing application context <span class="FontName">batch.xml</span> to use the Spring scheduling namespace. The additions consist mainly of changes to schema imports, as well as the declaration of a few beans. The application context file now starts off like so: <a id="cXXX.929" class="calibre5"></a></p>
<pre class="calibre11"><span class="FontName">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br class="calibre10"/><span class="FontName">&lt;beans:beans</span><br class="calibre10"/>       <span class="FontName"> xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/batch" class="calibre5">http://www.springframework.org/schema/batch</a></span><span class="FontName">"</span><br class="calibre10"/>        <span class="FontName">xmlns:beans="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>        <span class="FontName">xmlns:p="</span><span class="FontName"><a href="http://www.springframework.org/schema/p" class="calibre5">http://www.springframework.org/schema/p</a></span><span class="FontName">"</span><br class="calibre10"/>        <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>        <span class="FontName">xmlns:context="</span><span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span><span class="FontName">"</span><br class="calibre10"/>        <span class="FontName">xmlns:jdbc="</span><span class="FontName"><a href="http://www.springframework.org/schema/jdbc" class="calibre5">http://www.springframework.org/schema/jdbc</a></span><span class="FontName">"</span><br class="calibre10"/>        <span class="FontName">xmlns:task="</span><span class="FontName"><a href="http://www.springframework.org/schema/task" class="calibre5">http://www.springframework.org/schema/task</a></span><span class="FontName">"</span><br class="calibre10"/>        <span class="FontName">xsi:schemaLocation="</span><br class="calibre10"/>  <span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span> <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans.xsd</a></span><br class="calibre10"/> <span class="FontName"><a href="http://www.springframework.org/schema/batch" class="calibre5">http://www.springframework.org/schema/batch</a></span> <span class="FontName"><a href="http://www.springframework.org/schema/batch/spring-batch.xsd" class="calibre5">http://www.springframework.org/schema/batch/spring-batch.xsd</a></span><br class="calibre10"/> <span class="FontName"><a href="http://www.springframework.org/schema/context" class="calibre5">http://www.springframework.org/schema/context</a></span> <span class="FontName"><a href="http://www.springframework.org/schema/context/spring-context.xsd" class="calibre5">http://www.springframework.org/schema/context/spring-context.xsd</a></span><br class="calibre10"/> <span class="FontName"><a href="http://www.springframework.org/schema/jdbc" class="calibre5">http://www.springframework.org/schema/jdbc</a></span> <span class="FontName"><a href="http://www.springframework.org/schema/jdbc/spring-jdbc.xsd" class="calibre5">http://www.springframework.org/schema/jdbc/spring-jdbc.xsd</a></span><br class="calibre10"/> <span class="FontName"><a href="http://www.springframework.org/schema/task" class="calibre5">http://www.springframework.org/schema/task</a></span> <span class="FontName"><a href="http://www.springframework.org/schema/task/spring-task.xsd" class="calibre5">http://www.springframework.org/schema/task/spring-task.xsd</a></span><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;context:component-scan base-package="com.apress.springrecipes.springbatch"/&gt;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">&lt;task:scheduler id="scheduler" pool-size="10"/&gt;</b><br class="calibre10"/>    <b class="calibre4">&lt;task:executor id="executor" pool-size="10"/&gt;</b><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">&lt;task:annotation-driven scheduler="scheduler" executor="executor"/&gt;</b><br class="calibre10"/><br class="calibre10"/><span class="FontName">...</span></pre>
<p class="indent">These imports enable the simplest possible support for scheduling. The preceding declaration ensures that any bean under the package <span class="FontName">com.apress.springrecipes.springbatch</span><a id="cXXX.930" class="calibre5"></a> will be configured and scheduled as required. Our bean is as follows:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.springbatch.scheduler;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.apache.commons.lang3.StringUtils;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.Job;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.JobExecution;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.JobParameters;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.JobParametersBuilder;</span><br class="calibre10"/><span class="FontName">import org.springframework.batch.core.launch.JobLauncher;</span><br class="calibre10"/><span class="FontName">import org.springframework.beans.factory.annotation.Autowired;</span><br class="calibre10"/><span class="FontName">import org.springframework.scheduling.annotation.Scheduled;</span><br class="calibre10"/><span class="FontName">import org.springframework.stereotype.Component;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.util.Date;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Component</span><br class="calibre10"/><span class="FontName">public class JobScheduler {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private JobLauncher jobLauncher;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Autowired</span><br class="calibre10"/>    <span class="FontName">private Job job;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void runRegistrationsJob(Date date) throws Throwable {</span><br class="calibre10"/>        <span class="FontName">System.out.println(StringUtils.repeat("-", 100));</span><br class="calibre10"/>        <span class="FontName">System.out.println("Starting job at " + date.toString());</span><br class="calibre10"/>        <span class="FontName">JobParametersBuilder jobParametersBuilder = new JobParametersBuilder();</span><br class="calibre10"/>        <span class="FontName">jobParametersBuilder.addDate("date", date);</span><br class="calibre10"/>        <span class="FontName">jobParametersBuilder.addString("input.file", "registrations");</span><br class="calibre10"/>        <span class="FontName">JobParameters jobParameters = jobParametersBuilder.toJobParameters();</span><br class="calibre10"/>        <span class="FontName">JobExecution jobExecution = jobLauncher.run(job, jobParameters);</span><br class="calibre10"/>        <span class="FontName">System.out.println("jobExecution finished, exit code: " +jobExecution.getExitStatus().getExitCode());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Scheduled(fixedDelay = 1000 * 10)</span><br class="calibre10"/>    <span class="FontName">public void runRegistrationsJobOnASchedule() throws Throwable {</span><br class="calibre10"/>        <span class="FontName">runRegistrationsJob(new Date());</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/></pre>
<p class="indent">There is nothing particularly novel; it’s a good study of how the different components of the Spring framework work well together. The bean is recognized and becomes part of the application context because of the <span class="FontName">@Component</span> annotation, which we enabled with the <span class="FontName">context:component-scan</span> element in our <span class="FontName">batch.xml</span>. There’s only one <span class="FontName">Job</span> in the <span class="FontName">user-job.xml</span> file and only one <span class="FontName">JobLauncher</span>, so we simply have those auto-wired into our bean. Finally, the logic for kicking off a batch run is inside the <span class="FontName">runRegistrationsJob(java.util.Date date)</span> method<a id="cXXX.931" class="calibre5"></a>. This method could be called from anywhere. Our only client for this functionality is the scheduled method <span class="FontName">runRegistrationsJobOnASchedule</span>. The framework will invoke this method for us, according to the timeline dictated by the <span class="FontName">@Scheduled</span> annotation.</p>
<p class="indent">There are other options for this sort of thing; traditionally in the Java and Spring world, this sort of problem would be a good fit for Quartz<a id="cXXX.932" class="calibre5"></a>. It might still be, as the Spring scheduling support isn’t designed to be as extensible as Quartz. If you are in an environment requiring more traditional, ops-friendly scheduling tools, there are of course old standbys like <span class="FontName">cron</span>, <span class="FontName">autosys</span>, and BMC, too.</p>
<p id="Sec54" class="Heading">12-9. Parameterizing a Job<a id="cXXX.933" class="calibre6"></a> <a id="cXXX.934" class="calibre6"></a></p>
<p id="Sec55" class="Heading1">Problem</p>
<p class="noindent">The previous examples work well enough, but they leave something to be desired in terms of flexibility. To apply the batch code<a id="cXXX.935" class="calibre5"></a> to some other file, you’d have to edit the configuration and hard-code the name in there. The ability to parameterize the batch solution would be very helpful.</p>
<p id="Sec56" class="Heading1">Solution</p>
<p class="noindent">Use <span class="FontName">JobParameters</span> to parameterize a <span class="FontName">job</span>, which is then available to your <span class="FontName">step</span>s through Spring Batch’s expression language or via API calls.</p>
<p id="Sec57" class="Heading1">How It Works</p>
<p id="Sec58" class="Heading2">Launching a Job with Parameters</p>
<p class="noindent">A <span class="FontName">job</span> is a prototype of a <span class="FontName">JobInstance</span><a id="cXXX.936" class="calibre5"></a>. <span class="FontName">JobParameters</span> are used to provide a way of identifying a unique run of a <span class="FontName">job</span> (a <span class="FontName">JobInstance</span>). These <span class="FontName">JobParameters</span> allow you to give input to your batch process, just as you would with a method definition in Java. You’ve seen the <span class="FontName">JobParameters</span> in previous examples but not in detail. The <span class="FontName">JobParameters</span> object is created as you launch the <span class="FontName">job</span> using the <span class="FontName">JobLauncher</span>. To launch a <span class="FontName">job</span> called <span class="FontName">dailySalesFigures</span>, with the date for the job to work with, you would write something like this:</p>
<pre class="calibre11"><span class="FontName">ApplicationContext ctx = new ClassPathXmlApplicationContext("solution2.xml");</span><br class="calibre10"/><span class="FontName">JobLauncher jobLauncher = ctx.getBean("jobLauncher", JobLauncher.class);</span><br class="calibre10"/><b class="calibre4">Job job = (Job) ctx.getBean("dailySalesFigures");</b><br class="calibre10"/><b class="calibre4">jobLauncher.run(job, new JobParametersBuilder().addDate( "date",</b><br class="calibre10"/>    <b class="calibre4">new Date() ).toJobParameters());</b></pre>
<p id="Sec59" class="Heading2">Accessing JobParameters</p>
<p class="noindent">Technically, you can get at <span class="FontName">JobParameters</span> via any of the <span class="FontName">ExecutionContexts</span><a id="cXXX.937" class="calibre5"></a> (<span class="FontName">step</span> and <span class="FontName">job</span>). Once you have it, you can access the parameters in a type-safe way by calling <span class="FontName">getLong()</span>, <span class="FontName">getString()</span>, and so on. A simple way to do this is to bind to the <span class="FontName">@BeforeStep</span> event, save the <span class="FontName">StepExecution</span>, and iterate over the parameters this way. From here, you can inspect the parameters and do anything you want with them. Let’s look at that in terms of the <span class="FontName">ItemProcessor&lt;I,O&gt;</span> you wrote earlier:</p>
<pre class="calibre11"><span class="FontName">// ...</span><br class="calibre10"/><span class="FontName">private StepExecution stepExecution;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@BeforeStep</span><br class="calibre10"/><span class="FontName">public void saveStepExecution(StepExecution stepExecution) {</span><br class="calibre10"/>  <span class="FontName">this.stepExecution = stepExecution;</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public UserRegistration process(UserRegistration input) throws Exception {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">Map&lt;String, JobParameter&gt; params =  stepExecution.getJobParameters().getParameters();</span><br class="calibre10"/><br class="calibre10"/>   <span class="FontName">// iterate over all of the parameters</span><br class="calibre10"/>    <span class="FontName">for (String jobParameterKey : params.keySet()) {</span><br class="calibre10"/>       <span class="FontName">System.out.println(String.format("%s=%s", jobParameterKey,</span><br class="calibre10"/>    <span class="FontName">params.get(jobParameterKey).getValue().toString()));</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">// access specific parameters in a type safe way</span><br class="calibre10"/>    <span class="FontName">Date date = stepExecution.getJobParameters().getDate("date");</span><br class="calibre10"/>    <span class="FontName">// etc ...</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">This turns out to be of limited value. The 80 percent case is that you’ll need to bind parameters from the <span class="FontName">job</span>’s launch to the Spring beans in the application context. These parameters are available only at runtime, whereas the <span class="FontName">step</span>s in the XML application context are configured at design time. This happens in many places. Previous examples demonstrated <span class="FontName">ItemWriter</span>s&lt;T&gt; and <span class="FontName">ItemReader</span>s &lt;T&gt; with hard-coded paths<a id="cXXX.938" class="calibre5"></a>. That works fine unless you want to parameterize the file name. This is hardly acceptable unless you plan on using a <span class="FontName">job</span> just once!</p>
<p class="indent">The core Spring Framework<a id="cXXX.939" class="calibre5"></a> features an enhanced expression language that Spring Batch uses to defer binding of the parameter until the correct time. Or, in this case, until the bean is in the correct scope. Spring Batch 2.0 introduces the <span class="FontName">"step"</span> scope for just this purpose. Let’s take a look at how you’d rework the previous example to use a parameterized file name for the <span class="FontName">ItemReader</span>’s resource:</p>
<pre class="calibre11"><span class="FontName">&lt;beans:bean</span><br class="calibre10"/>        <b class="calibre4">scope="step"</b><br class="calibre10"/>        <span class="FontName">id="csvFileReader"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.batch.item.file.FlatFileItemReader"</span><br class="calibre10"/>        <b class="calibre4">p:resource="file:${user.home}/batches/#{jobParameters['input.fileName']}.csv"&gt;</b><br class="calibre10"/> <span class="FontName">&lt;!--  ... this is the same as before...--&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans:bean&gt;</span></pre>
<p class="indent">All you did is scope the bean (the <span class="FontName">FlatFileItemReader&lt;T&gt;</span>) to the life cycle of a <span class="FontName">step</span> (at which point those <span class="FontName">JobParameters</span> will resolve correctly) and then used the EL syntax to parameterize the path to work off of.</p>
<p class="indent">Note that the earlier versions of Spring Batch (before 2.0) featured an expression language in advance of the Spring Expression Language<a id="cXXX.940" class="calibre5"></a> that debuted in the core framework for 3.0 (SpEL). This expression language is by and large similar to SpEL but is not exact. In the preceding example, we reference the input variable as <span class="FontName">#{jobParameters['input.fileName']}</span>, which works in Spring Batch with SpEL. In the original Spring Batch expression language, however, you could have left off the quotes.</p>
<p id="Sec60" class="Heading">Summary</p>
<p class="noindent">This chapter introduced you to the concepts of batch processing, some of its history, and why it fits in a modern day architecture. You learned about Spring Batch, the batch processing from SpringSource, and how to do reading and writing with <span class="FontName">ItemReader&lt;T&gt;</span> and <span class="FontName">ItemWriter&lt;T&gt;</span> implementations in your batch <span class="FontName">job</span>s. You wrote your own <span class="FontName">ItemReader&lt;T&gt;</span>, and <span class="FontName">ItemWriter &lt;T&gt;</span>implementations as needed and saw how to control the execution of <span class="FontName">step</span>s inside a <span class="FontName">job</span>.</p>
<p class="FootLine">______________________</p>
<p class="FootNote"><span class="FontName"><a id="Fn1" href="part0022.html#_Fn1" class="calibre5"><sup class="calibre18">1</sup></a><a href="https://jcp.org/en/jsr/detail?id=352" class="calibre5">https://jcp.org/en/jsr/detail?id=352</a></span></p></div>
</body></html>
