<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Chapter 11 Spring Transaction Management</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre"><p class="ChapterNumber"><a id="b9781430259084_11" class="calibre6"></a>CHAPTER 11</p>
<p class="Chapimage"><img src="../images/00008.jpeg" alt="image" class="calibre3"/></p>
<p class="ChapterTitle">Spring Transaction Management</p>
<div class="calibre10"><p class="noindent">In this chapter, you will learn about the basic concept of transactions and Spring’s capabilities in the area of transaction management. Transaction management is an essential technique in enterprise applications to ensure data integrity and consistency. Spring, as an enterprise application framework, provides an abstract layer on top of different transaction management APIs. As an application developer, you can use Spring’s transaction management facilities without having to know much about the underlying transaction management APIs.</p>
<p class="indent">Like the bean-managed transaction (BMT<a id="cXXX.775" class="calibre5"></a>)<a id="cXXX.776" class="calibre5"></a> and container-managed transaction (CMT)<a id="cXXX.777" class="calibre5"></a><a id="cXXX.778" class="calibre5"></a> approaches in EJB, Spring supports both programmatic and declarative transaction management. The aim of Spring’s transaction support is to provide an alternative to EJB transactions by adding transaction capabilities to POJOs.</p>
<p class="indent">Programmatic transaction management is achieved by embedding transaction management code in your business methods to control the commit and rollback of transactions. You usually commit a transaction if a method completes normally and roll back a transaction if a method throws certain types of exceptions. With programmatic transaction management, you can define your own rules to commit and roll back transactions.</p>
<p class="indent">However, when managing transactions programmatically, you have to include transaction management code in each transactional operation. As a result, the boilerplate transaction code is repeated in each of these operations. Moreover, it’s hard for you to enable and disable transaction management for different applications. If you have a solid understanding of AOP, you may already have noticed that transaction management is a kind of crosscutting concern.</p>
<p class="indent">Declarative transaction management<a id="cXXX.779" class="calibre5"></a> is preferable to programmatic transaction management in most cases. It’s achieved by separating transaction management code from your business methods via declarations. Transaction management, as a kind of crosscutting concern, can be modularized with the AOP approach. Spring supports declarative transaction management through the Spring AOP framework. This can help you to enable transactions for your applications more easily and define a consistent transaction policy. Declarative transaction management is less flexible than programmatic transaction management. Programmatic transaction management allows you to control transactions through your code—explicitly starting, committing, and joining them as you see fit. You can specify a set of transaction attributes to define your transactions at a fine level of granularity. The transaction attributes supported by Spring include the propagation behavior, isolation level, rollback rules, transaction timeout, and whether or not the transaction is read-only. These attributes allow you to further customize the behavior of your transactions.</p>
<p class="indent">Upon finishing this chapter, you will be able to apply different transaction management strategies in your application. Moreover, you will be familiar with different transaction attributes to finely define your transactions.</p>
<p class="indent">Programmatic transaction management<a id="cXXX.780" class="calibre5"></a> is a good idea in certain cases where you don’t feel the addition of Spring proxies is worth the trouble or negligible performance loss. Here, you might access the native transaction yourself and control the transaction manually. A more convenient option that avoids the overhead of Spring proxies is the <span class="FontName">TransactionTemplate</span> class, which provides a template method around which a transactional boundary is started and then committed.</p>
<p id="Sec1" class="Heading">11-1. Problems with Transaction Management</p>
<p class="noindent">Transaction management<a id="cXXX.781" class="calibre5"></a> is an essential technique in enterprise application development to ensure data integrity and consistency. Without transaction management, your data and resources may be corrupted and left in an inconsistent state. Transaction management is particularly important for recovering from unexpected errors in a concurrent and distributed environment.</p>
<p class="indent">In simple words, a <i class="calibre8">transaction</i> is a series of actions that are treated as a single unit of work. These actions should either complete entirely or take no effect at all. If all the actions go well, the transaction should be committed permanently. In contrast, if any of them goes wrong, the transaction should be rolled back to the initial state as if nothing had happened.</p>
<p class="indent">The concept of transactions can be described with four key properties: <i class="calibre8">atomicity, consistency, isolation, and durability (ACID)</i><a id="cXXX.782" class="calibre5"></a>.</p>
<ul class="bulleted"><li class="calibre17"><i class="calibre8">Atomicity</i>: A <i class="calibre8">transaction</i> is an atomic operation that consists of a series of actions. The atomicity of a transaction ensures that the actions either complete entirely or take no effect at all.</li>
<li class="calibre17"><i class="calibre8">Consistency</i>: Once all actions of a transaction have completed, the transaction is committed. Then your data and resources will be in a consistent state that conforms to business rules.</li>
<li class="calibre17"><i class="calibre8">Isolation</i>: Because there may be many transactions processing with the same data set at the same time, each transaction should be isolated from others to prevent data corruption.</li>
<li class="calibre17"><i class="calibre8">Durability</i>: Once a transaction has completed, its result should be durable to survive any system failure (imagine if the power to your machine was cut right in the middle of a transaction’s commit). Usually, the result of a transaction is written to persistent storage.</li></ul>
<p class="indent">To understand the importance of transaction management, let’s begin with an example about purchasing books from an online bookshop. First, you have to create a new schema for this application in your database. If you are choosing Apache Derby as your database engine, you can connect to it with the JDBC properties<a id="cXXX.783" class="calibre5"></a> shown in <a id="_Tab1" href="part0021.html#Tab1" class="calibre5">Table 11-1</a>. For the examples in this book, we’re using Derby 10.10.2.0.</p>
<div class="Table" id="Tab1">
<p class="TabCapt"><span class="calibre4"><a href="part0021.html#_Tab1" class="calibre5">Table 11-1</a>.</span> JDBC Properties for Connecting to the Application Database</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">Property</p></th><th valign="top" class="calibre14">
<p class="tab-left">Value</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">Driver class</p></td><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">org.apache.derby.jdbc.ClientDriver</span></p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">URL</p></td><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">jdbc:derby://localhost:1527/bookshop;create=true</span></p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">Username</p></td><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">App</span></p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">Password</p></td><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">App</span></p></td></tr></tbody></table>
</div>
<p class="indent">With the preceding configuration, the database will be created for you because of the parameter on the JDBC URL: <span class="FontName">create=true</span>. For your bookshop application, you need a place to store the data. You’ll create a simple database to manage books and accounts.</p>
<p class="indent">The entity relational (ER)<a id="cXXX.784" class="calibre5"></a> diagram for the tables looks like <a id="_Fig1" href="part0021.html#Fig1" class="calibre5">Figure 11-1</a>.</p>
<div class="Figure" id="Fig1">
<p class="img1"><img src="../images/00070.jpeg" alt="9781430259084_Fig11-01.jpg" class="calibre3"/></p>
<p class="FigCapt"><span class="calibre4"><a href="part0021.html#_Fig1" class="calibre5">Figure 11-1</a>.</span> <span class="FontName">BOOK_STOCK</span> describes how many given <span class="FontName">BOOK</span>s exist</p></div>
<p class="indent">Now, let’s create the SQL for the preceding model. You’ll use the <span class="FontName">ij</span> tool that ships with Derby. On a command line, proceed to the directory where Derby is installed (usually just where you unzipped it when you downloaded it.). Descend to the <span class="FontName">bin</span> directory. If Derby’s not already started, run <span class="FontName">startNetworkServer</span> (or <span class="FontName">startNetworkServer.bat</span> on Windows). Now, you need to log in and execute the SQL DDL. Background the Derby Server process or open up a second shell and return to the same <span class="FontName">bin</span> directory in the Derby installation directory. Execute <span class="FontName">ij</span>. In the shell, execute the following:</p>
<pre class="calibre11"><span class="FontName">connect</span> <b class="calibre4">'</b><span class="FontName">jdbc:derby://localhost:1527/bookshop;create=true</span><b class="calibre4">'</b> <span class="FontName">;</span></pre>
<p class="indent">Paste the following SQL into the shell and verify its success:</p>
<pre class="calibre11"><span class="FontName">CREATE TABLE BOOK (</span><br class="calibre10"/>    <span class="FontName">ISBN         VARCHAR(50)    NOT NULL,</span><br class="calibre10"/>    <span class="FontName">BOOK_NAME    VARCHAR(100)   NOT NULL,</span><br class="calibre10"/>    <span class="FontName">PRICE        INT,</span><br class="calibre10"/>    <span class="FontName">PRIMARY KEY (ISBN)</span><br class="calibre10"/><span class="FontName">);</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">CREATE TABLE BOOK_STOCK (</span><br class="calibre10"/>    <span class="FontName">ISBN     VARCHAR(50)    NOT NULL,</span><br class="calibre10"/>    <span class="FontName">STOCK    INT            NOT NULL,</span><br class="calibre10"/>    <span class="FontName">PRIMARY KEY (ISBN),</span><br class="calibre10"/>    <span class="FontName">CHECK (STOCK &gt;=0)</span><br class="calibre10"/><span class="FontName">);</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">CREATE TABLE ACCOUNT (</span><br class="calibre10"/>    <span class="FontName">USERNAME    VARCHAR(50)    NOT NULL,</span><br class="calibre10"/>    <span class="FontName">BALANCE     INT            NOT NULL,</span><br class="calibre10"/>    <span class="FontName">PRIMARY KEY (USERNAME),</span><br class="calibre10"/>    <span class="FontName">CHECK (BALANCE &gt;=0)</span><br class="calibre10"/><span class="FontName">);</span></pre>
<p class="indent">A real-world application of this type would probably feature a price field with a decimal type, but using an <span class="FontName">int</span> makes the programming simpler to follow, so leave it as an <span class="FontName">int</span>.</p>
<p class="indent">The <span class="FontName">BOOK</span> table stores basic book information such as the name and price, with the book ISBN as the primary key. The <span class="FontName">BOOK_STOCK</span> table<a id="cXXX.785" class="calibre5"></a> keeps track of each book’s stock. The stock value is restricted by a <span class="FontName">CHECK</span> constraint to be a positive number. Although the <span class="FontName">CHECK</span> constraint type is defined in SQL-99, not all database engines support it. At the time of this writing, this limitation is mainly true of MySQL because Sybase, Derby, HSQL, Oracle, DB2, SQL Server, Access, PostgreSQL, and FireBird all support it. If your database engine doesn’t support <span class="FontName">CHECK</span> constraints, please consult its documentation for similar constraint support. Finally, the <span class="FontName">ACCOUNT</span> table stores customer accounts and their balances. Again, the balance is restricted to be positive.</p>
<p class="indent">The operations of your bookshop are defined in the following <span class="FontName">BookShop</span> interface. For now, there is only one operation: <span class="FontName">purchase()</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface BookShop {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void purchase(String isbn, String username);</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Because you will implement this interface with JDBC, you create the following <span class="FontName">JdbcBookShop</span> class<a id="cXXX.786" class="calibre5"></a>. To better understand the nature of transactions, let’s implement this class without the help of Spring’s JDBC support.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import java.sql.Connection;</span><br class="calibre10"/><span class="FontName">import java.sql.PreparedStatement;</span><br class="calibre10"/><span class="FontName">import java.sql.ResultSet;</span><br class="calibre10"/><span class="FontName">import java.sql.SQLException;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.sql.DataSource;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcBookShop implements BookShop {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private DataSource dataSource;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setDataSource(DataSource dataSource) {</span><br class="calibre10"/>        <span class="FontName">this.dataSource = dataSource;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void purchase(String isbn, String username) {</span><br class="calibre10"/>        <span class="FontName">Connection conn = null;</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">conn = dataSource.getConnection();</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">PreparedStatement stmt1 = conn.prepareStatement(</span><br class="calibre10"/>                    <span class="FontName">"SELECT PRICE FROM BOOK WHERE ISBN = ?");</span><br class="calibre10"/>            <span class="FontName">stmt1.setString(1, isbn);</span><br class="calibre10"/>            <span class="FontName">ResultSet rs = stmt1.executeQuery();</span><br class="calibre10"/>            <span class="FontName">rs.next();</span><br class="calibre10"/>            <span class="FontName">int price = rs.getInt("PRICE");</span><br class="calibre10"/>            <span class="FontName">stmt1.close();</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">PreparedStatement stmt2 = conn.prepareStatement(</span><br class="calibre10"/>                    <span class="FontName">"UPDATE BOOK_STOCK SET STOCK = STOCK - 1 "+</span><br class="calibre10"/>                    <span class="FontName">"WHERE ISBN = ?");</span><br class="calibre10"/>            <span class="FontName">stmt2.setString(1, isbn);</span><br class="calibre10"/>            <span class="FontName">stmt2.executeUpdate();</span><br class="calibre10"/>            <span class="FontName">stmt2.close();</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">PreparedStatement stmt3 = conn.prepareStatement(</span><br class="calibre10"/>                    <span class="FontName">"UPDATE ACCOUNT SET BALANCE = BALANCE - ? "+</span><br class="calibre10"/>                    <span class="FontName">"WHERE USERNAME = ?");</span><br class="calibre10"/>            <span class="FontName">stmt3.setInt(1, price);</span><br class="calibre10"/>            <span class="FontName">stmt3.setString(2, username);</span><br class="calibre10"/>            <span class="FontName">stmt3.executeUpdate();</span><br class="calibre10"/>            <span class="FontName">stmt3.close();</span><br class="calibre10"/>        <span class="FontName">} catch (SQLException e) {</span><br class="calibre10"/>            <span class="FontName">throw new RuntimeException(e);</span><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">if (conn != null) {</span><br class="calibre10"/>                <span class="FontName">try {</span><br class="calibre10"/>                    <span class="FontName">conn.close();</span><br class="calibre10"/>                <span class="FontName">} catch (SQLException e) {}</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">For the <span class="FontName">purchase()</span> operation<a id="cXXX.787" class="calibre5"></a>, you have to execute three SQL statements in total. The first is to query the book price. The second and third update the book stock and account balance accordingly.</p>
<p class="indent">Then, you can declare a bookshop instance in the Spring IoC container to provide purchasing services. For simplicity’s sake, you can use <span class="FontName">DriverManagerDataSource</span><a id="cXXX.788" class="calibre5"></a>, which opens a new connection to the database for every request.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To access a database running on the Derby server, you have to add the Derby client library to your CLASSPATH. If you’re using Maven, add the following dependency to your project.</p>
<pre class="calibre19"><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.apache.derby&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;derbyclient&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;10.10.2.0&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span></pre></div>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.config;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.bookshop.BookShop;</span><br class="calibre10"/><span class="FontName">import com.apress.springrecipes.bookshop.JdbcBookShop;</span><br class="calibre10"/><span class="FontName">import org.apache.derby.jdbc.ClientDriver;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Bean;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.annotation.Configuration;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import javax.sql.DataSource;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class BookstoreConfiguration {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public DataSource dataSource() {</span><br class="calibre10"/>        <span class="FontName">DriverManagerDataSource dataSource = new DriverManagerDataSource();</span><br class="calibre10"/>        <span class="FontName">dataSource.setDriverClassName(ClientDriver.class.getName());</span><br class="calibre10"/>        <span class="FontName">dataSource.setUrl("jdbc:derby://loca</span><span class="FontName">lhost:1527/bookstore;create=true");</span><br class="calibre10"/>        <span class="FontName">dataSource.setUsername("app");</span><br class="calibre10"/>        <span class="FontName">dataSource.setPassword("app");</span><br class="calibre10"/>        <span class="FontName">return dataSource;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public BookShop bookShop() {</span><br class="calibre10"/>        <span class="FontName">JdbcBookShop bookShop = new JdbcBookShop();</span><br class="calibre10"/>        <span class="FontName">bookShop.setDataSource(dataSource());</span><br class="calibre10"/>        <span class="FontName">return bookShop;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">To demonstrate the problems that can arise without transaction management, suppose you have the data shown in <a id="_Tab2" href="part0021.html#Tab2" class="calibre5">Tables 11-2</a>, <a id="_Tab3" href="part0021.html#Tab3" class="calibre5">11-3</a>, and <a id="_Tab4" href="part0021.html#Tab4" class="calibre5">11-4</a> entered in your <span class="FontName">bookshop</span> database.</p>
<div class="Table" id="Tab2">
<p class="TabCapt"><span class="calibre4"><a href="part0021.html#_Tab2" class="calibre5">Table 11-2</a>.</span> Sample Data in the BOOK Table for Testing Transactions</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">ISBN</p></th><th valign="top" class="calibre14">
<p class="tab-left">BOOK_NAME</p></th><th valign="top" class="calibre14">
<p class="tab-left">PRICE</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">0001</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The First Book</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">30</p></td></tr></tbody></table>
</div>
<div class="Table" id="Tab3">
<p class="TabCapt"><span class="calibre4"><a href="part0021.html#_Tab3" class="calibre5">Table 11-3</a>.</span> Sample Data in the BOOK_STOCK Table for Testing Transactions</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">ISBN</p></th><th valign="top" class="calibre14">
<p class="tab-left">STOCK</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">0001</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">10</p></td></tr></tbody></table>
</div>
<div class="Table" id="Tab4">
<p class="TabCapt"><span class="calibre4"><a href="part0021.html#_Tab4" class="calibre5">Table 11-4</a>.</span> Sample Data in the ACCOUNT Table<a id="cXXX.789" class="calibre5"></a> for Testing Transactions</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">USERNAME</p></th><th valign="top" class="calibre14">
<p class="tab-left">BALANCE</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">user1</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">20</p></td></tr></tbody></table>
</div>
<p class="indent">Then, write the following <span class="FontName">Main</span> class for purchasing the book with ISBN <span class="FontName">0001</span> by the user <span class="FontName">user1</span>. Because that user’s account has only $20, the funds are not sufficient to purchase the book.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.context.ApplicationContext;</span><br class="calibre10"/><span class="FontName">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context =</span> <br class="calibre10"/>            <span class="FontName">new ClassPathXmlApplicationContext("beans.xml");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">BookShop bookShop = (BookShop) context.getBean("bookShop");</span><br class="calibre10"/>        <span class="FontName">bookShop.purchase("0001", "user1");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">When you run this application, you will encounter a <span class="FontName">SQLException</span>, because the <span class="FontName">CHECK</span> constraint of the <span class="FontName">ACCOUNT</span> table has been violated. This is an expected result because you were trying to debit more than the account balance. However, if you check the stock for this book in the <span class="FontName">BOOK_STOCK</span> table, you will find that it was accidentally deducted by this unsuccessful operation! The reason is that you executed the second SQL statement to deduct the stock before you got an exception in the third statement.</p>
<p class="indent">As you can see, the lack of transaction management causes your data to be left in an inconsistent state. To avoid this inconsistency, your three SQL statements for the <span class="FontName">purchase()</span> operation should be executed within a single transaction. Once any of the actions in a transaction fail, the entire transaction should be rolled back to undo all changes made by the executed actions.</p>
<p id="Sec3" class="Heading2">Managing Transactions with JDBC Commit and Rollback</p>
<p class="noindent">When using JDBC to update a database, by default, each SQL statement will be committed immediately after its execution. This behavior is known as <i class="calibre8">auto-commit</i><a id="cXXX.790" class="calibre5"></a>. However, it does not allow you to manage transactions for your operations.</p>
<p class="indent">JDBC supports the primitive transaction management strategy of explicitly calling the <span class="FontName">commit()</span> and <span class="FontName">rollback()</span> methods<a id="cXXX.791" class="calibre5"></a> on a connection. But before you can do that, you must turn off auto-commit, which is turned on by default.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class JdbcBookShop implements BookShop {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public void purchase(String isbn, String username) {</span><br class="calibre10"/>        <span class="FontName">Connection conn = null;</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">conn = dataSource.getConnection();</span><br class="calibre10"/>            <b class="calibre4">conn.setAutoCommit(false);</b><br class="calibre10"/>            <span class="FontName">...</span><br class="calibre10"/>            <b class="calibre4">conn.commit();</b><br class="calibre10"/>        <span class="FontName">} catch (SQLException e) {</span><br class="calibre10"/>            <b class="calibre4">if (conn != null) {</b><br class="calibre10"/>                <b class="calibre4">try {</b><br class="calibre10"/>                    <b class="calibre4">conn.rollback();</b><br class="calibre10"/>                <b class="calibre4">} catch (SQLException e1) {}</b><br class="calibre10"/>            <b class="calibre4">}</b><br class="calibre10"/>            <span class="FontName">throw new RuntimeException(e);</span><br class="calibre10"/>        <span class="FontName">} finally {</span><br class="calibre10"/>            <span class="FontName">if (conn != null) {</span><br class="calibre10"/>                <span class="FontName">try {</span><br class="calibre10"/>                    <span class="FontName">conn.close();</span><br class="calibre10"/>                <span class="FontName">} catch (SQLException e) {}</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">The auto-commit behavior of a database connection can be altered by calling the <span class="FontName">setAutoCommit()</span> method<a id="cXXX.792" class="calibre5"></a>. By default, auto-commit is turned on to commit each SQL statement immediately after its execution. To enable transaction management, you must turn off this default behavior and commit the connection only when all the SQL statements have been executed successfully. If any of the statements go wrong, you must roll back all changes made by this connection.</p>
<p class="indent">Now, if you run your application again, the book stock will not be deducted when the user’s balance is insufficient to purchase the book.</p>
<p class="indent">Although you can manage transactions by explicitly committing and rolling back JDBC connections, the code required for this purpose is boilerplate code that you have to repeat for different methods. Moreover, this code is JDBC specific, so once you have chosen another data access technology, it needs to be changed also. Spring’s transaction support offers a set of technology-independent facilities, including transaction managers (e.g., <span class="FontName">org.springframework.transaction.PlatformTransactionManager</span>), a transaction template (e.g., <span class="FontName">org.springframework.transaction.support.TransactionTemplate</span>), and transaction declaration support to simplify your transaction management tasks.</p>
<p id="Sec4" class="Heading">11-2. Choosing a Transaction Manager Implementation</p>
<p id="Sec5" class="Heading1">Problem</p>
<p class="noindent">Typically, if your application involves only a single data source, you can simply manage transactions by calling the <span class="FontName">commit()</span> and <span class="FontName">rollback()</span> methods on a database connection. However, if your transactions extend across multiple data sources or you prefer to make use of the transaction management capabilities provided by your Java EE application server, you may choose the Java Transaction API (JTA). Besides, you may have to call different proprietary transaction APIs for different object/relational mapping<a id="cXXX.2128" class="calibre5"></a> frameworks such as Hibernate and JPA.</p>
<p class="indent">As a result, you have to deal with different transaction APIs for different technologies. It would be hard for you to switch from one set of APIs to another.</p>
<p id="Sec6" class="Heading1">Solution</p>
<p class="noindent">Spring abstracts a general set of transaction facilities from different transaction management APIs. As an application developer, you can simply utilize Spring’s transaction facilities without having to know much about the underlying transaction APIs. With these facilities, your transaction management code will be independent of any specific transaction technology.</p>
<p class="indent">Spring’s core transaction management abstraction is based on the interface <span class="FontName">PlatformTransactionManager</span><a id="cXXX.793" class="calibre5"></a>. It encapsulates a set of technology-independent methods for transaction management. Remember that a transaction manager is needed no matter which transaction management strategy (programmatic or declarative) you choose in Spring. The <span class="FontName">PlatformTransactionManager</span> interface provides three methods for working with transactions:</p>
<ul class="bulleted"><li class="calibre17"><span class="FontName">TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException</span></li>
<li class="calibre17"><span class="FontName">void commit(TransactionStatus status) throws TransactionException;</span></li>
<li class="calibre17"><span class="FontName">void rollback(TransactionStatus status) throws TransactionException;</span></li></ul>
<p id="Sec7" class="Heading1">How It Works</p>
<p class="noindent"><span class="FontName">PlatformTransactionManager</span> is a general interface for all Spring transaction managers. Spring has several built-in implementations of this interface for use with different transaction management APIs:</p>
<ul class="bulleted"><li class="calibre17">If you have to deal with only a single data source in your application and access it with JDBC, <span class="FontName">DataSourceTransactionManager</span> should meet your needs.</li>
<li class="calibre17">If you are using JTA for transaction management on a Java EE application server, you should use <span class="FontName">JtaTransactionManager</span><a id="cXXX.794" class="calibre5"></a> to look up a transaction from the application server. Additionally, <span class="FontName">JtaTransactionManager</span> is appropriate for distributed transactions (transactions that span multiple resources). Note that while it’s common to use a JTA transaction manager to integrate the application servers’ transaction manager, there’s nothing stopping you from using a stand-alone JTA transaction manager such as Atomikos.</li>
<li class="calibre17">If you are using an object/relational mapping framework to access a database, you should choose a corresponding transaction manager for this framework, such as <span class="FontName">HibernateTransactionManager</span><a id="cXXX.795" class="calibre5"></a> and <span class="FontName">JpaTransactionManager</span>.</li></ul>
<p class="indent"><a id="_Fig2" href="part0021.html#Fig2" class="calibre5">Figure 11-2</a> shows the common implementations of the <span class="FontName">PlatformTransactionManager</span> interface in Spring.</p>
<div class="Figure" id="Fig2">
<p class="img1"><img src="../images/00071.jpeg" alt="9781430259084_Fig11-02.jpg" class="calibre3"/></p>
<p class="FigCapt"><span class="calibre4"><a href="part0021.html#_Fig2" class="calibre5">Figure 11-2</a>.</span> Common implementations of the PlatformTransactionManager interface</p></div>
<p class="indent">A transaction manager is declared in the Spring IoC container as a normal bean. For example, the following bean configuration declares a <span class="FontName">DataSourceTransactionManager</span> instance. It requires the <span class="FontName">dataSource</span> property to be set so that it can manage transactions for connections made by this data source.</p>
<pre class="calibre11"><span class="FontName">@Bean</span><br class="calibre10"/><span class="FontName">public PlatformTransactionManager transactionManager() {</span><br class="calibre10"/>    <span class="FontName">DataSourceTransactionManager transactionManager = new DataSourceTransactionManager()</span><br class="calibre10"/>    <span class="FontName">transactionManager.setDataSource(dataSource());</span><br class="calibre10"/>    <span class="FontName">return transactionManager;</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec8" class="Heading">11-3. Managing Transactions Programmatically with the Transaction Manager API<a id="cXXX.796" class="calibre6"></a></p>
<p id="Sec9" class="Heading1">Problem</p>
<p class="noindent">You need to precisely control when to commit and roll back transactions in your business methods, but you don’t want to deal with the underlying transaction API<a id="cXXX.797" class="calibre5"></a> directly.</p>
<p id="Sec10" class="Heading1">Solution</p>
<p class="noindent">Spring’s transaction manager provides a technology-independent API that allows you to start a new transaction (or obtain the currently active transaction) by calling the <span class="FontName">getTransaction()</span> method and manage it by calling the <span class="FontName">commit()</span> and <span class="FontName">rollback()</span> methods. Because <span class="FontName">PlatformTransactionManager</span> is an abstract unit for transaction management, the methods you called for transaction management are guaranteed to be technology independent.</p>
<p id="Sec11" class="Heading1">How It Works</p>
<p class="noindent">To demonstrate how to use the transaction manager API, let’s create a new class, <span class="FontName">TransactionalJdbcBookShop</span>, which will make use of the Spring JDBC template. Because it has to deal with a transaction manager, you add a property of type <span class="FontName">PlatformTransactionManager</span> and allow it to be injected via a setter method.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">import org.springframework.dao.DataAccessException;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.PlatformTransactionManager;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.TransactionDefinition;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.TransactionStatus;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.support.DefaultTransactionDefinition;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class TransactionalJdbcBookShop extends JdbcDaoSupport implements</span><br class="calibre10"/>        <span class="FontName">BookShop {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private PlatformTransactionManager transactionManager;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setTransactionManager(</span><br class="calibre10"/>            <span class="FontName">PlatformTransactionManager transactionManager) {</span><br class="calibre10"/>        <span class="FontName">this.transactionManager = transactionManager;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void purchase(String isbn, String username) {</span><br class="calibre10"/>        <b class="calibre4">TransactionDefinition def = new DefaultTransactionDefinition();</b><br class="calibre10"/>        <b class="calibre4">TransactionStatus status = transactionManager.getTransaction(def);</b><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">int price = getJdbcTemplate</span><span class="FontName">().queryForInt(</span><br class="calibre10"/>                    <span class="FontName">"SELECT PRICE FROM BOOK WHERE ISBN = ?",</span><br class="calibre10"/>                    <span class="FontName">new Object[] { isbn });</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">getJdbcTemplate().update(</span><br class="calibre10"/>                    <span class="FontName">"UPDATE BOOK_STOCK SET STOCK = STOCK - 1 "+</span><br class="calibre10"/>                    <span class="FontName">"WHERE ISBN = ?", new Object[] { isbn });</span><br class="calibre10"/><br class="calibre10"/>            <span class="FontName">getJdbcTemplate().update(</span><br class="calibre10"/>                    <span class="FontName">"UPDATE ACCOUNT SET BALANCE = BALANCE - ? "+</span><br class="calibre10"/>                    <span class="FontName">"WHERE USERNAME = ?",</span><br class="calibre10"/>                    <span class="FontName">new Object[] { price, username });</span><br class="calibre10"/><br class="calibre10"/>            <b class="calibre4">transactionManager.commit(status);</b><br class="calibre10"/>        <span class="FontName">} catch (DataAccessException e) {</span><br class="calibre10"/>            <b class="calibre4">transactionManager.rollback(status);</b><br class="calibre10"/>            <span class="FontName">throw e;</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Before you start a new transaction, you have to specify the transaction attributes in a transaction definition object of type <span class="FontName">TransactionDefinition</span>. For this example, you can simply create an instance of <span class="FontName">DefaultTransactionDefinition</span> to use the default transaction attributes.</p>
<p class="indent">Once you have a transaction definition, you can ask the transaction manager to start a new transaction with that definition by calling the <span class="FontName">getTransaction()</span> method. Then, it will return a <span class="FontName">TransactionStatus</span> object to keep track of the transaction status. If all the statements execute successfully, you ask the transaction manager to commit this transaction by passing in the transaction status. Because all exceptions thrown by the Spring JDBC template are subclasses of <span class="FontName">DataAccessException</span>, you ask the transaction manager to roll back the transaction when this kind of exception is caught.</p>
<p class="indent">In this class, you have declared the transaction manager property of the general type <span class="FontName">PlatformTransactionManager</span>. Now, you have to inject an appropriate transaction manager implementation. Because you are dealing with only a single data source and accessing it with JDBC, you should choose <span class="FontName">DataSourceTransactionManager</span>. Here, you also wire a <span class="FontName">dataSource</span> because the class is a subclass of Spring’s <span class="FontName">JdbcDaoSupport</span>, which requires it.</p>
<pre class="calibre11"><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class BookstoreConfiguration {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public PlatformTransactionManager transactionManager() {</span><br class="calibre10"/>        <span class="FontName">DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();</span><br class="calibre10"/>        <span class="FontName">transactionManager.setDataSource(dataSource());</span><br class="calibre10"/>        <span class="FontName">return transactionManager;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public BookShop bookShop(</span><span class="FontName">) {</span><br class="calibre10"/>        <span class="FontName">TransactionalJdbcBookShop bookShop = new TransactionalJdbcBookShop();</span><br class="calibre10"/>        <span class="FontName">bookShop.setDataSource(dataSource());</span><br class="calibre10"/>        <b class="calibre4">bookShop.setTransactionManager(transactionManager());</b><br class="calibre10"/>        <span class="FontName">return bookShop;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec12" class="Heading">11-4. Managing Transactions Programmatically with a Transaction Template</p>
<p id="Sec13" class="Heading1">Problem</p>
<p class="noindent">Suppose that you have a code block, but not the entire body, of a business method that has the following transaction requirements:</p>
<ul class="bulleted"><li class="calibre17">Start a new transaction at the beginning of the block.</li>
<li class="calibre17">Commit the transaction after the block completes successfully.</li>
<li class="calibre17">Roll back the transaction if an exception is thrown in the block.</li></ul>
<p class="indent">If you call Spring’s transaction manager API directly, the transaction management code can be generalized in a technology-independent manner. However, you may not want to repeat the boilerplate code for each similar code block.</p>
<p id="Sec14" class="Heading1">Solution</p>
<p class="noindent">As with the JDBC template, Spring also provides a <span class="FontName">TransactionTemplate</span><a id="cXXX.2250" class="calibre5"></a><a id="cXXX.798" class="calibre5"></a> to help you control the overall transaction management process and transaction exception handling. You just have to encapsulate your code block in a callback class that implements the <span class="FontName">TransactionCallback&lt;T&gt;</span> interface and pass it to the <span class="FontName">TransactionTemplate</span>’s <span class="FontName">execute</span> method for execution. In this way, you don’t need to repeat the boilerplate transaction management code for this block. The template objects that Spring provides are lightweight and usually can be discarded or re-created with no performance impact. A JDBC template can be re-created on the fly with a <span class="FontName">DataSource</span> reference, for example, and so too can a <span class="FontName">TransactionTemplate</span> be re-created by providing a reference to a transaction manager. You can, of course, simply create one in your Spring application context, too.</p>
<p id="Sec15" class="Heading1">How It Works</p>
<p class="noindent">A <span class="FontName">TransactionTemplate</span><a id="cXXX.799" class="calibre5"></a> is created on a transaction manager just as a JDBC template is created on a data source. A transaction template executes a transaction callback object that encapsulates a transactional code block. You can implement the callback interface either as a separate class or as an inner class. If it’s implemented as an inner class, you have to make the method arguments <span class="FontName">final</span> for it to access.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.PlatformTransactionManager;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.TransactionStatus;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.support.TransactionCallbackWithoutResult;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.support.TransactionTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class TransactionalJdbcBookShop extends JdbcDaoSupport implements</span><br class="calibre10"/>        <span class="FontName">BookShop {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private PlatformTransactionManager transactionManager;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setTransactionManager(</span><br class="calibre10"/>            <span class="FontName">PlatformTransactionManager transactionManager) {</span><br class="calibre10"/>        <span class="FontName">this.transactionManager = transactionManager;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void purchase(final String isbn, final String username) {</span><br class="calibre10"/>        <b class="calibre4">TransactionTemplate transactionTemplate =</b><br class="calibre10"/>            <b class="calibre4">new TransactionTemplate(transactionManager);</b><br class="calibre10"/><br class="calibre10"/>        <b class="calibre4">transactionTemplate.execute(new TransactionCallbackWithoutResult() {</b><br class="calibre10"/><br class="calibre10"/>            <b class="calibre4">protected void doInTransactionWithoutResult(</b><br class="calibre10"/>                    <b class="calibre4">TransactionStatus status) {</b><br class="calibre10"/><br class="calibre10"/>                <span class="FontName">int price = getJdbcTemplate().queryForObject(</span><br class="calibre10"/>                        <span class="FontName">"SELECT PRICE FROM BOOK WHERE ISBN = ?",</span><br class="calibre10"/>                        <span class="FontName">new Object[] { isbn }, Integer.class);</span><br class="calibre10"/><br class="calibre10"/>                <span class="FontName">getJdbcTemplate().update(</span><br class="calibre10"/>                        <span class="FontName">"UPDATE BOOK_STOCK SET STOCK = STOCK - 1 "+</span><br class="calibre10"/>                        <span class="FontName">"WHERE ISBN = ?", new Object[] { isbn });</span><br class="calibre10"/><br class="calibre10"/>                <span class="FontName">getJdbcTemplate().update(</span><br class="calibre10"/>                        <span class="FontName">"UPDATE ACCOUNT SET BALANCE = BALANCE - ? "+</span><br class="calibre10"/>                        <span class="FontName">"WHERE USERNAME = ?",</span><br class="calibre10"/>                        <span class="FontName">new Object[] { price, username });</span><br class="calibre10"/>            <b class="calibre4">}</b><br class="calibre10"/>        <b class="calibre4">});</b><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">A <span class="FontName">TransactionTemplate</span> can accept a transaction callback object that implements either the <span class="FontName">TransactionCallback&lt;T&gt;</span> or an instance of the one implementer of that interface provided by the framework, the <span class="FontName">TransactionCallbackWithoutResult</span> class. For the code block in the <span class="FontName">purchase()</span> method<a id="cXXX.800" class="calibre5"></a> for deducting the book stock and account balance, there’s no result to be returned, so <span class="FontName">TransactionCallbackWithoutResult</span> is fine. For any code blocks with return values, you should implement the <span class="FontName">TransactionCallback&lt;T&gt;</span> interface instead. The return value of the callback object will finally be returned by the template’s <span class="FontName">T execute()</span> method. The main benefit is that the responsibility of starting, rolling back, or committing the transaction has been removed.</p>
<p class="indent">During the execution of the callback object, if it throws an unchecked exception (e.g., <span class="FontName">RuntimeException</span> and <span class="FontName">DataAccessException</span> fall into this category), or if you explicitly called <span class="FontName">setRollbackOnly()</span> on the <span class="FontName">TransactionStatus</span> argument in the <span class="FontName">doInTransactionWithoutResult</span> method, the transaction will be rolled back. Otherwise, it will be committed after the callback object completes.</p>
<p class="indent">In the bean configuration file, the bookshop bean still requires a transaction manager to create a <span class="FontName">TransactionTemplate</span>.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class BookstoreConfiguration {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public PlatformTransactionManager transactionManager() {</span><br class="calibre10"/>        <span class="FontName">DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();</span><br class="calibre10"/>        <span class="FontName">transactionManager.setDataSource(dataSource());</span><br class="calibre10"/>        <span class="FontName">return transactionManager;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public BookShop bookShop() {</span><br class="calibre10"/>        <span class="FontName">TransactionalJdbcBookShop bookShop = new TransactionalJdbcBookShop();</span><br class="calibre10"/>        <span class="FontName">bookShop.setDataSource(dataSource());</span><br class="calibre10"/>        <b class="calibre4">bookShop.setTransactionManager(transactionManager());</b><br class="calibre10"/>        <span class="FontName">return bookShop;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You can also have the IoC container inject a transaction template instead of creating it directly. Because a transaction template handles all transactions, there’s no need for your class to refer to the transaction manager any more.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.support.TransactionTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class TransactionalJdbcBookShop extends JdbcDaoSupport implements</span><br class="calibre10"/>        <span class="FontName">BookShop {</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">private TransactionTemplate transactionTemplate;</b><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">public void setTransactionTemplate(</b><br class="calibre10"/>            <b class="calibre4">TransactionTemplate transactionTemplate) {</b><br class="calibre10"/>        <b class="calibre4">this.transactionTemplate = transactionTemplate;</b><br class="calibre10"/>    <b class="calibre4">}</b><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void purchase(final String isbn, final String username) {</span><br class="calibre10"/>        <span class="FontName">transactionTemplate.execute(new TransactionCallbackWithoutResult() {</span><br class="calibre10"/>            <span class="FontName">protected void doInTransactionWithoutResult(TransactionStatus status) {</span><br class="calibre10"/>                <span class="FontName">...</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">});</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Then you define a transaction template in the bean configuration file and inject it, instead of the transaction manager, into your bookshop bean. Notice that the transaction template instance can be used for more than one transactional bean because it is a thread-safe object. Finally, don’t forget to set the transaction manager property for your transaction template.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.config;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.support.TransactionTemplate;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">public class BookstoreConfiguration {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public PlatformTransactionManager transactionManager() { ... }</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Bean</b><br class="calibre10"/>    <b class="calibre4">public TransactionTemplate transactionTemplate() {</b><br class="calibre10"/>        <b class="calibre4">TransactionTemplate transactionTemplate = new TransactionTemplate();</b><br class="calibre10"/>        <b class="calibre4">transactionTemplate.setTransactionManager(transactionManager());</b><br class="calibre10"/>        <b class="calibre4">return transactionTemplate;</b><br class="calibre10"/>    <b class="calibre4">}</b><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public BookShop bookShop() {</span><br class="calibre10"/>        <span class="FontName">TransactionalJdbcBookShop bookShop = new TransactionalJdbcBookShop();</span><br class="calibre10"/>        <span class="FontName">bookShop.setDataSource(dataSource());</span><br class="calibre10"/>        <b class="calibre4">bookShop.setTransactionTemplate(transactionTemplate());</b><br class="calibre10"/>        <span class="FontName">return bookShop;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec16" class="Heading">11-5. Managing Transactions Declaratively with Transaction Advices</p>
<p id="Sec17" class="Heading1">Problem</p>
<p class="noindent">Because transaction management is a kind of crosscutting concern, you should manage transactions declaratively with the AOP approach available from Spring 2.x onward. Managing transactions manually can be tedious and error prone. It is simpler to specify, declaratively, what behavior you are expecting<a id="cXXX.801" class="calibre5"></a> and to not prescribe <i class="calibre8">how</i> that behavior is to be achieved.</p>
<p id="Sec18" class="Heading1">Solution</p>
<p class="noindent">Spring (since version 2.0) offers a transaction advice that can be easily configured via the <span class="FontName">&lt;tx:advice&gt;</span> element defined in the <span class="FontName">tx</span> schema. This advice can be enabled with the AOP configuration facilities defined in the <span class="FontName">aop</span> schema.</p>
<p id="Sec19" class="Heading1">How It Works</p>
<p class="noindent">To enable declarative transaction management, you can declare a transaction advice<a id="cXXX.802" class="calibre5"></a> via the <span class="FontName">&lt;tx:advice&gt;</span> element defined in the <span class="FontName">tx</span> schema, so you have to add this schema definition to the <span class="FontName">&lt;beans&gt;</span> root element beforehand. Once you have declared this advice, you need to associate it with a pointcut. Because a transaction advice is declared outside the <span class="FontName">&lt;aop:config&gt;</span> element, it cannot link with a pointcut directly. You have to declare an advisor in the <span class="FontName">&lt;aop:config&gt;</span> element to associate an advice with a pointcut.</p>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  Because Spring AOP uses the AspectJ pointcut expressions to define pointcuts, you have to include the AspectJ Weaver support on your CLASSPATH. If you’re using Maven, add the following dependency to your project.</p>
<pre class="calibre19"><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;1.8.0&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span></pre></div>
<pre class="calibre11"><span class="FontName">&lt;beans  xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>    <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>    <b class="calibre4">xmlns:tx="</b><b class="calibre4"><a href="http://www.springframework.org/schema/tx" class="calibre5">http://www.springframework.org/schema/tx</a></b><b class="calibre4">"</b><br class="calibre10"/>    <b class="calibre4">xmlns:aop="</b><b class="calibre4"><a href="http://www.springframework.org/schema/aop" class="calibre5">http://www.springframework.org/schema/aop</a></b><b class="calibre4">"</b><br class="calibre10"/>    <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/>        <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.0.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</a></span><br class="calibre10"/>        <b class="calibre4"><a href="http://www.springframework.org/schema/tx" class="calibre5">http://www.springframework.org/schema/tx</a></b><br class="calibre10"/>        <b class="calibre4"><a href="http://www.springframework.org/schema/tx/spring-tx-3.0.xsd" class="calibre5">http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</a></b><br class="calibre10"/>        <b class="calibre4"><a href="http://www.springframework.org/schema/aop" class="calibre5">http://www.springframework.org/schema/aop</a></b><br class="calibre10"/>        <b class="calibre4"><a href="http://www.springframework.org/schema/aop/spring-aop-3.0.xsd" class="calibre5">http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</a></b><b class="calibre4">"</b><span class="FontName">&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;tx:advice id="bookShopTxAdvice"</span><br class="calibre10"/>        <span class="FontName">transaction-manager="transactionManager"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;tx:attributes&gt;</span><br class="calibre10"/>            <span class="FontName">&lt;tx:method name="purchase"/&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;/tx:attributes&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/tx:advice&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;aop:config&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;aop:pointcut id="bookShopOperation" expression=</span><br class="calibre10"/>            <span class="FontName">"execution(* com.apress.springrecipes.bookshop.BookShop.*(..))"/&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;aop:advisor advice-ref="bookShopTxAdvice"</span><br class="calibre10"/>            <span class="FontName">pointcut-ref="bookShopOperation"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/aop:config&gt;</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="transactionManager"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="dataSource"ref="dataSource"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="bookShop"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.bookshop.TransactionalJdbcBookShop"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="dataSource" ref="dataSource"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">The preceding AspectJ pointcut expression matches all the methods declared in the <span class="FontName">BookShop</span> interface<a id="cXXX.803" class="calibre5"></a>. However, because Spring AOP is based on proxies, it can apply only to public methods. Thus only public methods can be made transactional with Spring AOP.</p>
<p class="indent">Each transaction advice requires an identifier and a reference to a transaction manager in the IoC container. If you don’t specify a transaction manager explicitly, Spring will search the application context for a <span class="FontName">TransactionManager</span> with a bean name of <span class="FontName">transactionManager</span>. The methods that require transaction management are specified with multiple <span class="FontName">&lt;tx:method&gt;</span> elements inside the <span class="FontName">&lt;tx:attributes&gt;</span> element. The method name supports wildcards for you to match a group of methods. You can also define transaction attributes for each group of methods, but let’s use the default attributes for simplicity’s sake. The defaults are shown in <a id="_Tab5" href="part0021.html#Tab5" class="calibre5">Table 11-5</a>.</p>
<div class="Table" id="Tab5">
<p class="TabCapt"><span class="calibre4"><a href="part0021.html#_Tab5" class="calibre5">Table 11-5</a>.</span> Attributes Used with tx:attributes</p>
<p class="img1"><img src="../images/00072.jpeg" alt="Table11-5.jpg" class="calibre3"/></p></div>
<p class="indent">Now, you can retrieve the <span class="FontName">bookShop</span> bean from the Spring IoC container to use. Because this bean’s methods are matched by the pointcut, Spring will return a proxy that has transaction management enabled for this bean.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">ApplicationContext context = new ClassPathXmlApplicationContext("bookstore-context.xml");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">BookShop bookShop = context.getBean(BookShop.class);</span><br class="calibre10"/>        <span class="FontName">bookShop.purchase("0001", "user1");    }</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec20" class="Heading">11-6. Managing Transactions Declaratively with the @Transactional Annotation<a id="cXXX.804" class="calibre6"></a></p>
<p id="Sec21" class="Heading1">Problem</p>
<p class="noindent">Declaring transactions in the bean configuration file requires knowledge of AOP concepts such as pointcuts, advices, and advisors. Developers who lack this knowledge might find it hard to enable declarative transaction management.</p>
<p id="Sec22" class="Heading1">Solution</p>
<p class="noindent">In addition to declaring transactions in the bean configuration file with pointcuts, advices, and advisors, Spring allows you to declare transactions simply by annotating your transactional methods with <span class="FontName">@Transactional</span> and enabling the <span class="FontName">&lt;tx:annotation-driven&gt;</span> element. However, Java 1.5 or higher is required to use this approach. Note that although you could apply the annotation to an interface method, it’s not a recommended practice.</p>
<p id="Sec23" class="Heading1">How It Works</p>
<p class="noindent">To define a method as transactional, you can simply annotate it with <span class="FontName">@Transactional</span>. Note that you should only annotate public methods due to the proxy-based limitations of Spring AOP.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><span class="FontName">import org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcBookShop extends JdbcDaoSupport implements BookShop {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Transactional</span><br class="calibre10"/>    <span class="FontName">public void purchase(String isbn, String username) {</span><br class="calibre10"/><br class="calibre10"/>      <span class="FontName">int price = getJdbcTemplate().queryForInt(</span><br class="calibre10"/>          <span class="FontName">"SELECT PRICE FROM BOOK WHERE ISBN = ?",</span><br class="calibre10"/>          <span class="FontName">new Object[] { isbn });</span><br class="calibre10"/><br class="calibre10"/>      <span class="FontName">getJdbcTemplate().update(</span><br class="calibre10"/>          <span class="FontName">"UPDATE BOOK_STOCK SET STOCK = STOCK - 1 "+</span><br class="calibre10"/>          <span class="FontName">"WHERE ISBN = ?", new Object[] { isbn });</span><br class="calibre10"/><br class="calibre10"/>      <span class="FontName">getJdbcTemplate().update(</span><br class="calibre10"/>          <span class="FontName">"UPDATE ACCOUNT SET BALANCE = BALANCE - ? "+</span><br class="calibre10"/>          <span class="FontName">"WHERE USERNAME = ?",</span><br class="calibre10"/>          <span class="FontName">new Object[] { price, username });</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Note that, as we are extending <span class="FontName">JdbcDaoSupport</span>, we no longer need the mutators for the <span class="FontName">DataSource</span>; remove it from your DAO class.</p>
<p class="indent">You may apply the <span class="FontName">@Transactional</span> annotation at the method level or the class level. When applying this annotation to a class, all of the public methods within this class will be defined as transactional. Although you can apply <span class="FontName">@Transactional</span> to interfaces or method declarations in an interface, it’s not recommended because it may not work properly with class-based proxies (i.e., CGLIB proxies).</p>
<p class="indent">In the bean configuration file, you only have to enable the <span class="FontName">&lt;tx:annotation-driven&gt;</span> element and specify a transaction manager for it. That’s all you need to make it work. Spring will advise methods with <span class="FontName">@Transactional</span>, or methods in a class with <span class="FontName">@Transactional</span>, from beans declared in the IoC container. As a result, Spring can manage transactions for these methods.</p>
<pre class="calibre11"><span class="FontName">&lt;beans  xmlns="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><span class="FontName">"</span><br class="calibre10"/>  <span class="FontName">xmlns:xsi="</span><span class="FontName"><a href="http://www.w3.org/2001/XMLSchema-instance" class="calibre5">http://www.w3.org/2001/XMLSchema-instance</a></span><span class="FontName">"</span><br class="calibre10"/>  <span class="FontName">xmlns:tx="</span><span class="FontName"><a href="http://www.springframework.org/schema/tx" class="calibre5">http://www.springframework.org/schema/tx</a></span><span class="FontName">"</span> <br class="calibre10"/>  <span class="FontName">xsi:schemaLocation="</span><span class="FontName"><a href="http://www.springframework.org/schema/beans" class="calibre5">http://www.springframework.org/schema/beans</a></span><br class="calibre10"/> <span class="FontName"><a href="http://www.springframework.org/schema/beans/spring-beans-3.0.xsd" class="calibre5">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</a></span><br class="calibre10"/>    <b class="calibre4"><a href="http://www.springframework.org/schema/tx" class="calibre5">http://www.springframework.org/schema/tx</a></b><br class="calibre10"/><b class="calibre4"><a href="http://www.springframework.org/schema/tx/spring-tx-3.0.xsd" class="calibre5">http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</a></b><span class="FontName">"&gt;</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;</b><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;bean id="transactionManager"</span><br class="calibre10"/>        <span class="FontName">class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="dataSource" ref="dataSource"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">&lt;bean id="bookShop"</span><br class="calibre10"/>        <span class="FontName">class="com.apress.springrecipes.bookshop.spring.JdbcBookShop"&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;property name="dataSource" ref="dataSource"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/bean&gt;</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p class="indent">In fact, you can omit the <span class="FontName">transaction-manager</span> attribute in the <span class="FontName">&lt;tx:annotation-driven&gt;</span> element if your transaction manager has the name <span class="FontName">transactionManager</span>. This element will automatically detect a transaction manager with this name. You have to specify a transaction manager only when it has a different name.</p>
<pre class="calibre11"><span class="FontName">&lt;beans ...&gt;</span><br class="calibre10"/>    <b class="calibre4">&lt;tx:annotation-driven /&gt;</b><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<p id="Sec24" class="Heading2">Enable @Transactional with Java-based Configuration</p>
<p class="noindent">When using Java-based configuration transaction management<a id="cXXX.805" class="calibre5"></a> can be enabled by using the <span class="FontName">@EnableTransactionManagement</span> annotation. This annotation is the equivalent of the <span class="FontName">&lt;tx:annotation-driven /&gt;</span>in XML based configuration.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">@EnableTransactionManagement</span><br class="calibre10"/><span class="FontName">public class BookstoreConfiguration {  ... }</span></pre>
<p class="indent">When using the <span class="FontName">@EnableTransactionManagement</span> annotation it isn’t possible to specify which transaction manager to use. When there is only one <span class="FontName">PlatformTransactionManager</span> in your configuration this will be automatically detected and used for managing transactions.</p>
<p class="indent">For the situations where there are multiple <span class="FontName">PlatformTransactionManager</span>s<a id="cXXX.806" class="calibre5"></a> in your configuration, you have to specify on the <span class="FontName">@Transactional</span> annotation which of the transaction managers to use for controlling the transaction. For this you can use the <span class="FontName">value</span> attribute of the <span class="FontName">@Transactional</span> annotation.</p>
<pre class="calibre11"><span class="FontName">@Transaction("transaction-manager-1")</span><br class="calibre10"/><span class="FontName">public void transactionalMethod() { ... }</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">@Transaction("transaction-manager-2")</span><br class="calibre10"/><span class="FontName">public void otherTransactionalMethod() { ... }</span></pre>
<p id="Sec25" class="Heading">11-7. Setting the Propagation Transaction Attribute<a id="cXXX.2140" class="calibre6"></a></p>
<p id="Sec26" class="Heading1">Problem</p>
<p class="noindent">When a transactional method is called by another method, it is necessary to specify how the transaction should be propagated. For example, the method may continue to run within the existing transaction, or it may start a new transaction and run within its own transaction.</p>
<p id="Sec27" class="Heading1">Solution</p>
<p class="noindent">A transaction’s propagation behavior can be specified by the <i class="calibre8">propagation</i> transaction attribute. Spring defines seven propagation behaviors, as shown in <a id="_Tab6" href="part0021.html#Tab6" class="calibre5">Table 11-6</a>. These behaviors are defined in the <span class="FontName">org.springframework.transaction.TransactionDefinition</span> interface. Note that not all types of transaction managers support all of these propagation behaviors<a id="cXXX.807" class="calibre5"></a>. Their behavior is contingent on the underlying resource. Databases, for example, may support varying isolation levels, which constrains what propagation behaviors the transaction manager can support.</p>
<div class="Table" id="Tab6">
<p class="TabCapt"><span class="calibre4"><a href="part0021.html#_Tab6" class="calibre5">Table 11-6</a>.</span> Propagation Behaviors Supported by Spring</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">Propagation</p></th><th valign="top" class="calibre14">
<p class="tab-left">Description</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">REQUIRED</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">If there’s an existing transaction in progress, the current method should run within this transaction. Otherwise, it should start a new transaction and run within its own transaction.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">REQUIRES_NEW</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The current method must start a new transaction and run within its own transaction. If there’s an existing transaction in progress, it should be suspended.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">SUPPORTS</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">If there’s an existing transaction in progress, the current method can run within this transaction. Otherwise, it is not necessary to run within a transaction.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">NOT_SUPPORTED</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The current method should not run within a transaction. If there’s an existing transaction in progress, it should be suspended.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">MANDATORY</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The current method must run within a transaction. If there’s no existing transaction in progress, an exception will be thrown.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">NEVER</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The current method should not run within a transaction. If there’s an existing transaction in progress, an exception will be thrown.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">NESTED</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">If there’s an existing transaction in progress, the current method should run within the nested transaction (supported by the JDBC 3.0 save point feature) of this transaction. Otherwise, it should start a new transaction and run within its own transaction. This feature is unique to Spring (whereas the previous propagation behaviors have analogs in Java EE transaction propagation). The behavior is useful for situations such as batch processing, in which you’ve got a long running process (imagine processing 1 million records) and you want to chunk the commits on the batch. So you commit every 10,000 records. If something goes wrong, you roll back the nested transaction and you’ve lost only 10,000 records’ worth of work (as opposed to the entire 1 million).</p></td></tr></tbody></table>
</div>
<p id="Sec28" class="Heading1">How It Works</p>
<p class="noindent">Transaction propagation happens when a transactional method is called by another method. For example, suppose a customer would like to check out all books to purchase at the bookshop cashier. To support this operation, you define the <span class="FontName">Cashier</span> interface<a id="cXXX.808" class="calibre5"></a> as follows:</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public interface Cashier {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void checkout(List&lt;String&gt; isbns, String username);</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You can implement this interface by delegating the purchases to a bookshop bean by calling its <span class="FontName">purchase()</span> method multiple times. Note that the <span class="FontName">checkout()</span> method<a id="cXXX.809" class="calibre5"></a> is made transactional by applying the <span class="FontName">@Transactional</span> annotation.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class BookShopCashier implements Cashier {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private BookShop bookShop;</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public void setBookShop(BookShop bookShop) {</span><br class="calibre10"/>        <span class="FontName">this.bookShop = bookShop;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Transactional</b><br class="calibre10"/>    <span class="FontName">public void checkout(List&lt;String&gt; isbns, String username) {</span><br class="calibre10"/>        <span class="FontName">for (String isbn : isbns) {</span><br class="calibre10"/>            <span class="FontName">bookShop.purchase(isbn, username);</span><br class="calibre10"/>        <span class="FontName">}</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Then define a cashier bean in your bean configuration file and refer to the bookshop bean for purchasing books.</p>
<pre class="calibre11"><span class="FontName">@Configuration</span><br class="calibre10"/><span class="FontName">@EnableTransactionManagement()</span><br class="calibre10"/><span class="FontName">public class BookstoreConfiguration {</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">@Bean</span><br class="calibre10"/>    <span class="FontName">public Cashier cashier() {</span><br class="calibre10"/>        <span class="FontName">BookShopCashier cashier = new BookShopCashier();</span><br class="calibre10"/>        <span class="FontName">cashier.setBookShop(bookShop());</span><br class="calibre10"/>        <span class="FontName">return cashier;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">To illustrate the propagation behavior of a transaction, enter the data shown in <a id="_Tab7" href="part0021.html#Tab7" class="calibre5">Tables 11-7</a>, <a id="_Tab8" href="part0021.html#Tab8" class="calibre5">11-8</a>, and <a id="_Tab9" href="part0021.html#Tab9" class="calibre5">11-9</a> in your <span class="FontName">bookshop</span> database.</p>
<div class="Table" id="Tab7">
<p class="TabCapt"><span class="calibre4"><a href="part0021.html#_Tab7" class="calibre5">Table 11-7</a>.</span> Sample Data in the BOOK Table for Testing Propagation Behaviors</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">ISBN</p></th><th valign="top" class="calibre14">
<p class="tab-left">BOOK_NAME</p></th><th valign="top" class="calibre14">
<p class="tab-left">PRICE</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">0001</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The First Book</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">30</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">0002</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The Second Book</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">50</p></td></tr></tbody></table>
</div>
<div class="Table" id="Tab8">
<p class="TabCapt"><span class="calibre4"><a href="part0021.html#_Tab8" class="calibre5">Table 11-8</a>.</span> Sample Data in the BOOK_STOCK Table<a id="cXXX.810" class="calibre5"></a> for Testing Propagation Behaviors</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">ISBN</p></th><th valign="top" class="calibre14">
<p class="tab-left">STOCK</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">0001</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">10</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">0002</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">10</p></td></tr></tbody></table>
</div>
<div class="Table" id="Tab9">
<p class="TabCapt"><span class="calibre4"><a href="part0021.html#_Tab9" class="calibre5">Table 11-9</a>.</span> Sample Data in the ACCOUNT Table for Testing Propagation Behaviors</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">USERNAME</p></th><th valign="top" class="calibre14">
<p class="tab-left">BALANCE</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">user1</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">40</p></td></tr></tbody></table>
</div>
<p id="Sec29" class="Heading2">The REQUIRED Propagation Behavior</p>
<p class="noindent">When the user <span class="FontName">user1</span> checks out the two books from the cashier, the balance is sufficient to purchase the first book but not the second.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">Cashier cashier = context.getBean(Cashier.class);</span><br class="calibre10"/>        <span class="FontName">List&lt;String&gt; isbnList = Arrays.asList(new String[] { "0001", "0002"});</span><br class="calibre10"/>        <span class="FontName">cashier.checkout(isbnList, "user1");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">When the bookshop’s <span class="FontName">purchase()</span> method<a id="cXXX.811" class="calibre5"></a> is called by another transactional method, such as <span class="FontName">checkout()</span>, it will run within the existing transaction by default. This default propagation behavior is called <span class="FontName">REQUIRED</span>. That means there will be only one transaction whose boundary is the beginning and ending of the <span class="FontName">checkout()</span> method. This transaction will be committed only at the end of the <span class="FontName">checkout()</span> method. As a result, the user can purchase none of the books. <a id="_Fig3" href="part0021.html#Fig3" class="calibre5">Figure 11-3</a> illustrates the <span class="FontName">REQUIRED</span> propagation behavior.<a id="cXXX.2159" class="calibre5"></a></p>
<div class="Figure" id="Fig3">
<p class="img1"><img src="../images/00073.jpeg" alt="9781430259084_Fig11-03.jpg" class="calibre3"/></p>
<p class="FigCapt"><span class="calibre4"><a href="part0021.html#_Fig3" class="calibre5">Figure 11-3</a>.</span> The REQUIRED transaction propagation behavior</p></div>
<p class="indent">However, if the <span class="FontName">purchase()</span> method is called by a non-transactional method and there’s no existing transaction in progress, it will start a new transaction and run within its own transaction.</p>
<p class="indent">The propagation transaction attribute can be defined in the <span class="FontName">@Transactional</span> annotation<a id="cXXX.812" class="calibre5"></a>. For example, you can set the <span class="FontName">REQUIRED</span> behavior for this attribute as follows. In fact, this is unnecessary, because it’s the default behavior.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Propagation;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcBookShop extends JdbcDaoSupport implements BookShop {</span><br class="calibre10"/>    <span class="FontName">@Transactional(propagation = Propagation.REQUIRED)</span><br class="calibre10"/>    <span class="FontName">public void purchase(String isbn, String username) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Propagation;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class BookShopCashier implements Cashier {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Transactional(propagation = Propagation.REQUIRED)</span><br class="calibre10"/>    <span class="FontName">public void checkout(List&lt;String&gt; isbns, String username) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p id="Sec30" class="Heading2">The REQUIRES_NEW Propagation Behavior<a id="cXXX.2160" class="calibre6"></a></p>
<p class="noindent">Another common propagation behavior is <span class="FontName">REQUIRES_NEW</span>. It indicates that the method must start a new transaction and run within its new transaction. If there’s an existing transaction in progress, it should be suspended first (as, for example, with the checkout method on <span class="FontName">BookShopCashier</span>, with a propagation of <span class="FontName">REQUIRED</span>).</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Propagation;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcBookShop extends JdbcDaoSupport implements BookShop {</span><br class="calibre10"/>    <span class="FontName">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br class="calibre10"/>    <span class="FontName">public void purchase(String isbn, String username) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In this case, there will be three transactions started in total. The first transaction is started by the <span class="FontName">checkout()</span> method, but when the first <span class="FontName">purchase()</span> method is called, the first transaction will be suspended and a new transaction will be started. At the end of the first <span class="FontName">purchase()</span> method, the new transaction completes and commits. When the second <span class="FontName">purchase()</span> method<a id="cXXX.813" class="calibre5"></a> is called, another new transaction will be started. However, this transaction will fail and roll back. As a result, the first book will be purchased successfully, while the second will not. <a id="_Fig4" href="part0021.html#Fig4" class="calibre5">Figure 11-4</a> illustrates the <span class="FontName">REQUIRES_NEW</span> propagation behavior.</p>
<div class="Figure" id="Fig4">
<p class="img1"><img src="../images/00074.jpeg" alt="9781430259084_Fig11-04.jpg" class="calibre3"/></p>
<p class="FigCapt"><span class="calibre4"><a href="part0021.html#_Fig4" class="calibre5">Figure 11-4</a>.</span> The REQUIRES_NEW transaction propagation behavior</p></div>
<p id="Sec31" class="Heading2">Setting the Propagation Attribute in Transaction Advices and APIs</p>
<p class="noindent">In a Spring<a id="cXXX.2235" class="calibre5"></a> transaction advice, the propagation transaction<a id="cXXX.2243" class="calibre5"></a> attribute can be specified in the <span class="FontName">&lt;tx:method&gt;</span> element as follows:</p>
<pre class="calibre11"><span class="FontName">&lt;tx:advice ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;tx:attributes&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;tx:method name="..."</span><br class="calibre10"/>            <span class="FontName">propagation="REQUIRES_NEW"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/tx:attributes&gt;</span><br class="calibre10"/><span class="FontName">&lt;/tx:advice&gt;</span></pre>
<p class="indent">In Spring’s transaction management API, the propagation transaction attribute can be specified in a <span class="FontName">DefaultTransactionDefinition</span><a id="cXXX.814" class="calibre5"></a> object and then passed to a transaction manager’s <span class="FontName">getTransaction()</span> method or a transaction template’s constructor.</p>
<pre class="calibre11"><span class="FontName">DefaultTransactionDefinition def = new DefaultTransactionDefinition();</span><br class="calibre10"/><span class="FontName">def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);</span></pre>
<p id="Sec32" class="Heading">11-8. Setting the Isolation Transaction Attribute</p>
<p id="Sec33" class="Heading1">Problem</p>
<p class="noindent">When multiple transactions of the same applic<a id="cXXX.815" class="calibre5"></a>ation or different applications are operating concurrently on the same dataset, many unexpected problems may arise. You must specify how you expect your transactions to be isolated from one another.</p>
<p id="Sec34" class="Heading1">Solution</p>
<p class="noindent">The problems caused by concurrent transactions can be categorized into four types:</p>
<ul class="bulleted"><li class="calibre17"><i class="calibre8">Dirty read</i>: For two <i class="calibre8">transactions</i> T1 and T2, T1 reads a field that has been updated by T2 but not yet committed. Later, if T2 rolls back, the field read by T1 will be temporary and invalid.</li>
<li class="calibre17"><i class="calibre8">Nonrepeatable read</i>: For two transactions T1 and T2, T1 reads a field and then T2 updates the field. Later, if T1 reads the same field again, the value will be different.</li>
<li class="calibre17"><i class="calibre8">Phantom read</i>: For two transactions T1 and T2, T1 reads some rows from a table and then T2 inserts new rows into the table. Later, if T1 reads the same table again, there will be additional rows.</li>
<li class="calibre17"><i class="calibre8">Lost updates</i>: For two transactions T1 and T2, they both select a row for update, and based on the state of that row, make an update to it. Thus, one overwrites the other when the second transaction to commit should have waited until the first one committed before performing its selection.</li></ul>
<p class="indent">In theory, transactions should be completely isolated from each other (i.e., serializable) to avoid all the mentioned problems. However, this isolation level will have great impact on performance, because transactions have to run in serial order. In practice, transactions can run in lower isolation levels in order to improve performance.</p>
<p class="indent">A transaction’s isolation level can be specified by the <i class="calibre8">isolation</i> transaction attribute. Spring supports five isolation levels, as shown in <a id="_Tab10" href="part0021.html#Tab10" class="calibre5">Table 11-10</a>. These levels are defined in the <span class="FontName">org.springframework.transaction.TransactionDefinition</span> interface.</p>
<div class="Table" id="Tab10">
<p class="TabCapt"><span class="calibre4"><a href="part0021.html#_Tab10" class="calibre5">Table 11-10</a>.</span> Isolation Levels<a id="cXXX.816" class="calibre5"></a> Supported by Spring</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">Isolation</p></th><th valign="top" class="calibre14">
<p class="tab-left">Description</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">DEFAULT</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">Uses the default isolation level of the underlying database. For most databases, the default isolation level is <span class="FontName">READ_COMMITTED</span>.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">READ_UNCOMMITTED</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">Allows a transaction to read uncommitted changes by other transactions. The dirty read, nonrepeatable read, and phantom read problems may occur.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">READ_COMMITTED</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">Allows a transaction to read only those changes that have been committed by other transactions. The dirty read problem can be avoided, but the nonrepeatable read and phantom read problems may still occur.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">REPEATABLE_READ</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">Ensures that a transaction can read identical values from a field multiple times. For the duration of this transaction, updates made by other transactions to this field are prohibited. The dirty read and nonrepeatable read problems can be avoided, but the phantom read problem may still occur.</p></td></tr><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt"><span class="FontName">SERIALIZABLE</span></p></td><td valign="top" class="calibre16">
<p class="tab-leftt">Ensures that a transaction can read identical rows from a table multiple times. For the duration of this transaction, inserts, updates, and deletes made by other transactions to this table are prohibited. All the concurrency problems can be avoided, but the performance will be low.</p></td></tr></tbody></table>
</div>
<p class="indent">Note that transaction isolation is supported by the underlying database engine but not an application or a framework. However, not all database engines support all these isolation levels. You can change the isolation level of a JDBC connection by calling the <span class="FontName">setTransactionIsolation()</span> method on the <span class="FontName">java.sql.Connection</span> i<span class="FontName">java.sql.Connection</span> interface.</p>
<p id="Sec35" class="Heading1">How It Works</p>
<p class="noindent">To illustrate the problems caused by concurrent transactions, let’s add two new operations to your bookshop for increasing and checking the book stock.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public interface BookShop {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">public void increaseStock(String isbn, int stock);</span><br class="calibre10"/>    <span class="FontName">public int checkStock(String isbn);</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">Then, you implement these operations as follows. Note that these two operations should also be declared as transactional.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcBookShop extends JdbcDaoSupport implements BookShop {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <b class="calibre4">@Transactional</b><br class="calibre10"/>    <span class="FontName">public void increaseStock(String isbn, int stock) {</span><br class="calibre10"/>        <span class="FontName">String threadName = Thread.currentThread().getName();</span><br class="calibre10"/>        <b class="calibre4">System.out.println(threadName + "- Prepare to increase book stock");</b><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">getJdbcTemplate().update(</span><br class="calibre10"/>                <span class="FontName">"UPDATE BOOK_STOCK SET STOCK = STOCK + ? "+</span><br class="calibre10"/>                <span class="FontName">"WHERE ISBN = ?",</span><br class="calibre10"/>                <span class="FontName">new Object[] { stock, isbn });</span><br class="calibre10"/><br class="calibre10"/>        <b class="calibre4">System.out.println(threadName + "- Book stock increased by "+ stock);</b><br class="calibre10"/>        <span class="FontName">sleep(threadName);</span><br class="calibre10"/><br class="calibre10"/>        <b class="calibre4">System.out.println(threadName + "- Book stock rolled back");</b><br class="calibre10"/>        <span class="FontName">throw new RuntimeException("Increased by mistake");</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <b class="calibre4">@Transactional</b><br class="calibre10"/>    <span class="FontName">public int checkStock(String isbn) {</span><br class="calibre10"/>        <span class="FontName">String threadName = Thread.currentThread().getName();</span><br class="calibre10"/>        <b class="calibre4">System.out.println(threadName + "- Prepare to check book stock");</b><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">int stock = getJdbcTemplate().queryForInt(</span><br class="calibre10"/>                <span class="FontName">"SELECT STOCK FROM BOOK_STOCK WHERE ISBN = ?",</span><br class="calibre10"/>                <span class="FontName">new Object[] { isbn });</span><br class="calibre10"/><br class="calibre10"/>        <b class="calibre4">System.out.println(threadName + "- Book stock is "+ stock);</b><br class="calibre10"/>        <span class="FontName">sleep(threadName);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">return stock;</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">private void sleep(String threadName) {</span><br class="calibre10"/>        <b class="calibre4">System.out.println(threadName + "- Sleeping");</b><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">Thread.sleep(10000);</span><br class="calibre10"/>        <span class="FontName">} catch (InterruptedException e) {}</span><br class="calibre10"/>        <b class="calibre4">System.out.println(threadName + "- Wake up");</b><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">To simulate concurrency, your operations need to be executed by multiple threads. You can track the current status of the operations through the <span class="FontName">println</span> statements<a id="cXXX.817" class="calibre5"></a>. For each operation, you print a couple of messages to the console around the SQL statement’s execution. The messages should include the thread name for you to know which thread is currently executing the operation.</p>
<p class="indent">After each operation executes the SQL statement, you ask the thread to sleep for 10 seconds. As you know, the transaction will be committed or rolled back immediately once the operation completes. Inserting a sleep statement can help to postpone the commit or rollback. For the <span class="FontName">increase()</span> operation,<a id="cXXX.818" class="calibre5"></a> you eventually throw a <span class="FontName">RuntimeException</span> to cause the transaction to roll back. Let’s look at a simple client that runs these examples.</p>
<p class="indent">Before you start with the isolation level examples, enter the data from <a id="_Tab11" href="part0021.html#Tab11" class="calibre5">Tables 11-11</a> and <a id="_Tab12" href="part0021.html#Tab12" class="calibre5">11-12</a> into your <span class="FontName">bookshop</span> database. (Note that the <span class="FontName">ACCOUNT</span> table isn’t needed in this example.)</p>
<div class="Table" id="Tab11">
<p class="TabCapt"><span class="calibre4"><a href="part0021.html#_Tab11" class="calibre5">Table 11-11</a>.</span> Sample Data in the BOOK Table for Testing Isolation Levels</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">ISBN</p></th><th valign="top" class="calibre14">
<p class="tab-left">BOOK_NAME</p></th><th valign="top" class="calibre14">
<p class="tab-left">PRICE</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">0001</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">The First Book</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">30</p></td></tr></tbody></table>
</div>
<div class="Table" id="Tab12">
<p class="TabCapt"><span class="calibre4"><a href="part0021.html#_Tab12" class="calibre5">Table 11-12</a>.</span> Sample Data in the BOOK_STOCK Table for Testing Isolation Levels</p>
<table border="0" class="calibre12"><thead class="calibre13"><tr class="header"><th valign="top" class="calibre14">
<p class="tab-left">ISBN</p></th><th valign="top" class="calibre14">
<p class="tab-left">STOCK</p></th></tr></thead><tbody class="calibre15"><tr class="noclass"><td valign="top" class="calibre16">
<p class="tab-leftt">0001</p></td><td valign="top" class="calibre16">
<p class="tab-leftt">10</p></td></tr></tbody></table>
</div>
<p id="Sec36" class="Heading2">The READ_UNCOMMITTED and READ_COMMITTED Isolation Levels</p>
<p class="noindent"><span class="FontName">READ_UNCOMMITTED</span><a id="cXXX.819" class="calibre5"></a> is the lowest isolation level that allows a transaction to read uncommitted changes made by other transactions. You can set this isolation level in the <span class="FontName">@Transaction</span> annotation of your <span class="FontName">checkStock()</span> method.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Isolation;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcBookShop extends JdbcDaoSupport implements BookShop {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Transactional(isolation = Isolation.READ_UNCOMMITTED)</span><br class="calibre10"/>    <span class="FontName">public int checkStock(String isbn) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">You can create some threads to experiment on this transaction isolation level. In the following <span class="FontName">Main</span> class<a id="cXXX.820" class="calibre5"></a>, there are two threads you are going to create. Thread 1 increases the book stock, while thread 2 checks the book stock. Thread 1 starts 5 seconds before thread 2.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">final BookShop bookShop = context.getBean(BookShop.class);</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Thread thread1 = new Thread(new Runnable() {</span><br class="calibre10"/>            <span class="FontName">public void run() {</span><br class="calibre10"/>                <span class="FontName">try {</span><br class="calibre10"/>                    <b class="calibre4">bookShop.increaseStock("0001", 5);</b><br class="calibre10"/>                <span class="FontName">} catch (RuntimeException e) {}</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">}, "Thread 1");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Thread thread2 = new Thread(new Runnable() {</span><br class="calibre10"/>            <span class="FontName">public void run() {</span><br class="calibre10"/>                <b class="calibre4">bookShop.checkStock("0001");</b><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">}, "Thread 2");</span><br class="calibre10"/><br class="calibre10"/>        <b class="calibre4">thread1.start();</b><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <b class="calibre4">Thread.sleep(5000);</b><br class="calibre10"/>        <span class="FontName">} catch (InterruptedException e) {}</span><br class="calibre10"/>            <b class="calibre4">thread2.start();</b><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you run the application, you will get the following result:</p>
<div class="thinline">
<pre class="calibre11"><span class="FontName">Thread 1</span>—<span class="FontName">Prepare to increase book stock</span><br class="calibre10"/><span class="FontName">Thread 1</span>—<span class="FontName">Book stock increased by 5</span><br class="calibre10"/><span class="FontName">Thread 1</span>—<span class="FontName">Sleeping</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Prepare to check book stock</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Book stock is 15</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Sleeping</span><br class="calibre10"/><span class="FontName">Thread 1</span>—<span class="FontName">Wake up</span><br class="calibre10"/><span class="FontName">Thread 1</span>—<span class="FontName">Book stock rolled back</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Wake up</span></pre></div>
<p class="indent">First, thread 1 increased the book stock and then went to sleep. At that time, thread 1’s transaction had not yet been rolled back. While thread 1 was sleeping, thread 2 started and attempted to read the book stock. With the <span class="FontName">READ_UNCOMMITTED</span> isolation<a id="cXXX.821" class="calibre5"></a> level, thread 2 would be able to read the stock value that had been updated by an uncommitted transaction.</p>
<p class="indent">However, when thread 1 wakes up, its transaction will be rolled back due to a <span class="FontName">RuntimeException</span>, so the value read by thread 2 is temporary and invalid. This problem is known as <i class="calibre8">dirty read</i>, because a transaction may read values that are “dirty.”</p>
<p class="indent">To avoid the dirty read problem, you should raise the isolation level of <span class="FontName">checkStock()</span> to <span class="FontName">READ_COMMITTED</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Isolation;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcBookShop extends JdbcDaoSupport implements BookShop {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Transactional(isolation = Isolation.READ_COMMITTED)</span><br class="calibre10"/>    <span class="FontName">public int checkStock(String isbn) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you run the application again, thread 2 won’t be able to read the book stock until thread 1 has rolled back the transaction. In this way, the dirty read problem can be avoided by preventing a transaction from reading a field that has been updated by another uncommitted transaction.</p>
<div class="thinline">
<pre class="calibre11"><span class="FontName">Thread 1</span>—<span class="FontName">Prepare to increase book stock</span><br class="calibre10"/><span class="FontName">Thread 1</span>—<span class="FontName">Book stock increased by 5</span><br class="calibre10"/><span class="FontName">Thread 1</span>—<span class="FontName">Sleeping</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Prepare to check book stock</span><br class="calibre10"/><span class="FontName">Thread 1</span>—<span class="FontName">Wake up</span><br class="calibre10"/><span class="FontName">Thread 1</span>—<span class="FontName">Book stock rolled back</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Book stock is 10</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Sleeping</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Wake up</span></pre></div>
<p class="indent">In order for the underlying database to support the <span class="FontName">READ_COMMITTED</span> isolation level, it may acquire an <i class="calibre8">update lock</i> on a row that was updated but not yet committed. Then, other transactions must wait to read that row until the update lock is released, which happens when the locking transaction commits or rolls back.</p>
<p id="Sec37" class="Heading2">The REPEATABLE_READ Isolation Level<a id="cXXX.822" class="calibre6"></a></p>
<p class="noindent">Now, let’s restructure the threads to demonstrate another concurrency problem. Swap the tasks of the two threads so that thread 1 checks the book stock before thread 2 increases the book stock.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">public class Main {</span><br class="calibre10"/><br class="calibre10"/>    <span class="FontName">public static void main(String[] args) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>        <span class="FontName">final BookShop bookShop = (BookShop) context.getBean("bookShop");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Thread thread1 = new Thread(new Runnable() {</span><br class="calibre10"/>            <span class="FontName">public void run() {</span><br class="calibre10"/>                <b class="calibre4">bookShop.checkStock("0001");</b><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">}, "Thread 1");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">Thread thread2 = new Thread(new Runnable() {</span><br class="calibre10"/>            <span class="FontName">public void run() {</span><br class="calibre10"/>                <span class="FontName">try {</span><br class="calibre10"/>                    <b class="calibre4">bookShop.increaseStock("0001", 5);</b><br class="calibre10"/>                <span class="FontName">} catch (RuntimeException e) {}</span><br class="calibre10"/>            <span class="FontName">}</span><br class="calibre10"/>        <span class="FontName">}, "Thread 2");</span><br class="calibre10"/><br class="calibre10"/>        <span class="FontName">thread1.start();</span><br class="calibre10"/>        <span class="FontName">try {</span><br class="calibre10"/>            <span class="FontName">Thread.sleep(5000);</span><br class="calibre10"/>        <span class="FontName">} catch (InterruptedException e) {}</span><br class="calibre10"/>            <span class="FontName">thread2.start();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you run the application, you will get the following result:</p>
<div class="thinline">
<pre class="calibre11"><span class="FontName">Thread 1</span>—<span class="FontName">Prepare to check book stock</span><br class="calibre10"/><span class="FontName">Thread 1</span>—<span class="FontName">Book stock is 10</span><br class="calibre10"/><span class="FontName">Thread 1</span>—<span class="FontName">Sleeping</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Prepare to increase book stock</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Book stock increased by 5</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Sleeping</span><br class="calibre10"/><span class="FontName">Thread 1</span>—<span class="FontName">Wake up</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Wake up</span><br class="calibre10"/><span class="FontName">Thread 2</span>—<span class="FontName">Book stock rolled back</span></pre></div>
<p class="indent">First, thread 1 read the book stock and then went to sleep. At that time, thread 1’s transaction had not yet been committed. While thread 1 was sleeping, thread 2 started and attempted to increase the book stock. With the <span class="FontName">READ_COMMITTED</span> isolation level, thread 2 would be able to update the stock value that was read by an uncommitted transaction.</p>
<p class="indent">However, if thread 1 reads the book stock again, the value will be different from its first read. This problem is known as <i class="calibre8">nonrepeatable read</i><a id="cXXX.823" class="calibre5"></a> because a transaction may read different values for the same field.</p>
<p class="indent">To avoid the nonrepeatable read problem, you should raise the isolation level of <span class="FontName">checkStock()</span> to <span class="FontName">REPEATABLE_READ</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Isolation;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcBookShop extends JdbcDaoSupport implements BookShop {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Transactional(isolation = Isolation.REPEATABLE_READ)</span><br class="calibre10"/>    <span class="FontName">public int checkStock(String isbn) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">If you run the application again, thread 2 won’t be able to update the book stock until thread 1 has committed the transaction. In this way, the nonrepeatable read problem can be avoided by preventing a transaction from updating a value that has been read by another uncommitted transaction.</p>
<div class="thinline">
<pre class="calibre11"><span class="FontName">Thread 1—Prepare to check book stock</span><br class="calibre10"/><span class="FontName">Thread 1—Book stock is 10</span><br class="calibre10"/><span class="FontName">Thread 1—Sleeping</span><br class="calibre10"/><span class="FontName">Thread 2—Prepare to increase book stock</span><br class="calibre10"/><span class="FontName">Thread 1—Wake up</span><br class="calibre10"/><span class="FontName">Thread 2—Book stock increased by 5</span><br class="calibre10"/><span class="FontName">Thread 2—Sleeping</span><br class="calibre10"/><span class="FontName">Thread 2—Wake up</span><br class="calibre10"/><span class="FontName">Thread 2—Book stock rolled back</span></pre></div>
<p class="indent">In order for the underlying database to support the <span class="FontName">REPEATABLE_READ</span> isolation level, it may acquire a <i class="calibre8">read lock</i> on a row that was read but not yet committed. Then, other transactions must wait to update the row until the read lock is released, which happens when the locking transaction commits or rolls back.</p>
<p id="Sec38" class="Heading2">The SERIALIZABLE Isolation Level<a id="cXXX.824" class="calibre6"></a></p>
<p class="noindent">After a transaction has read several rows from a table, another transaction inserts new rows into the same table. If the first transaction reads the same table again, it will find additional rows that are different from the first read. This problem is known as <i class="calibre8">phantom read</i>. Actually, phantom read is very similar to nonrepeatable read but involves multiple rows.</p>
<p class="indent">To avoid the phantom read problem, you should raise the isolation level to the highest: <span class="FontName">SERIALIZABLE</span>. Notice that this isolation level is the slowest because it may acquire a read lock on the full table. In practice, you should always choose the lowest isolation level that can satisfy your requirements.</p>
<p id="Sec39" class="Heading2">Setting the Isolation Level Attribute in Transaction Advices and APIs<a id="cXXX.825" class="calibre6"></a></p>
<p class="noindent">In a Spring transaction advice, the isolation level can be specified in the <span class="FontName">&lt;tx:method&gt;</span> element as follows:</p>
<pre class="calibre11"><span class="FontName">&lt;tx:advice ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;tx:attributes&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;tx:method name="*"</span><br class="calibre10"/>            <span class="FontName">isolation="REPEATABLE_READ"/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/tx:attributes&gt;</span><br class="calibre10"/><span class="FontName">&lt;/tx:advice&gt;</span></pre>
<p class="indent">In Spring’s transaction management API, the isolation level can be specified in a <span class="FontName">DefaultTransactionDefinition</span> object and then passed to a transaction manager’s <span class="FontName">getTransaction()</span> method or a transaction template’s constructor.</p>
<pre class="calibre11"><span class="FontName">DefaultTransactionDefinition def = new DefaultTransactionDefinition();</span><br class="calibre10"/><span class="FontName">def.setIsolationLevel(TransactionDefinition.ISOLATION_REPEATABLE_READ);</span></pre>
<p id="Sec40" class="Heading">11-9. Setting the Rollback Transaction Attribute<a id="cXXX.826" class="calibre6"></a></p>
<p id="Sec41" class="Heading1">Problem</p>
<p class="noindent">By default, only unchecked exceptions (i.e., of type <span class="FontName">RuntimeException</span> and <span class="FontName">Error</span>) will cause a transaction to roll back, while checked exceptions will not. Sometimes, you may wish to break this rule and set your own exceptions for rolling back.</p>
<p id="Sec42" class="Heading1">Solution</p>
<p class="noindent">The exceptions that cause a transaction to roll back or not can be specified by the <i class="calibre8">rollback</i> transaction attribute. Any exceptions not explicitly specified in this attribute will be handled by the default rollback rule (i.e., rolling back for unchecked exceptions and not rolling back for checked exceptions).</p>
<p id="Sec43" class="Heading1">How It Works</p>
<p class="noindent">A transaction’s rollback rule can be defined in the <span class="FontName">@Transactional</span> annotation via the <span class="FontName">rollbackFor</span> and <span class="FontName">noRollbackFor</span> attributes. These two attributes are declared as <span class="FontName">Class[]</span>, so you can specify more than one exception for each attribute.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Propagation;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><span class="FontName">import java.io.IOException;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcBookShop extends JdbcDaoSupport implements BookShop {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Transactional(</span><br class="calibre10"/>            <span class="FontName">propagation = Propagation.REQUIRES_NEW,</span><br class="calibre10"/>            <b class="calibre4">rollbackFor = IOException.class,</b><br class="calibre10"/>            <b class="calibre4">noRollbackFor = ArithmeticException.class</b><span class="FontName">)</span><br class="calibre10"/>    <span class="FontName">public void purchase(String isbn, String username) throws Exception{</span><br class="calibre10"/>   <span class="FontName">throw new ArithmeticException();</span><br class="calibre10"/>             <span class="FontName">//throw new IOException();</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In a Spring transaction advice, the rollback rule can be specified in the <span class="FontName">&lt;tx:method&gt;</span> element. You can separate the exceptions with commas if there’s more than one exception.</p>
<pre class="calibre11"><span class="FontName">&lt;tx:advice ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;tx:attributes&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;tx:method name="..."</span><br class="calibre10"/>            <b class="calibre4">rollback-for="java.io.IOException"</b><br class="calibre10"/>            <b class="calibre4">no-rollback-for="java.lang</b><b class="calibre4">.ArithmeticException"/&gt;</b><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">&lt;/tx:attributes&gt;</span><br class="calibre10"/><span class="FontName">&lt;/tx:advice&gt;</span></pre>
<p class="indent">In Spring’s transaction management API, the rollback rule can be specified in a <span class="FontName">RuleBasedTransactionAttribute</span> object. Because it implements the <span class="FontName">TransactionDefinition</span> interface, it can be passed to a transaction manager’s <span class="FontName">getTransaction()</span> method or a transaction template’s constructor.</p>
<pre class="calibre11"><span class="FontName">RuleBasedTransactionAttribute attr = new RuleBasedTransactionAttribute();</span><br class="calibre10"/><span class="FontName">attr.getRollbackRules().add(</span><br class="calibre10"/>    <span class="FontName">new RollbackRuleAttribute(IOException.class));</span><br class="calibre10"/><span class="FontName">attr.getRollbackRules().add(</span><br class="calibre10"/>    <span class="FontName">new NoRollbackRuleAttribute(SendFailedException.class));</span></pre>
<p id="Sec44" class="Heading">11-10. Setting the Timeout and Read-Only Transaction Attributes<a id="cXXX.827" class="calibre6"></a></p>
<p id="Sec45" class="Heading1">Problem</p>
<p class="noindent">Because a transaction may acquire locks on rows and tables, a long transaction will tie up resources and have an impact on overall performance. Besides, if a transaction only reads but does not update data, the database engine could optimize this transaction. You can specify these attributes to increase the performance of your application.</p>
<p id="Sec46" class="Heading1">Solution</p>
<p class="noindent">The <i class="calibre8">timeout</i> transaction attribute (an integer that describes seconds) indicates how long your transaction can survive before it is forced to roll back. This can prevent a long transaction from tying up resources. The <i class="calibre8">read-only</i> attribute indicates that this transaction will only read but not update data. The read-only flag is just a hint to enable a resource to optimize the transaction, and a resource might not necessarily cause a failure if a write is attempted.</p>
<p id="Sec47" class="Heading1">How It Works</p>
<p class="noindent">The timeout and read-only transaction attributes can be defined in the <span class="FontName">@Transactional</span> annotation. Note that timeout is measured in seconds.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop.spring;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Isolation;</span><br class="calibre10"/><span class="FontName">import org.springframework.transaction.annotation.Transactional;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">public class JdbcBookShop extends JdbcDaoSupport implements BookShop {</span><br class="calibre10"/>    <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">@Transactional(</span><br class="calibre10"/>            <span class="FontName">isolation = Isolation.REPEATABLE_READ,</span><br class="calibre10"/>            <b class="calibre4">timeout = 30,</b><br class="calibre10"/>            <b class="calibre4">readOnly = true</b><span class="FontName">)</span><br class="calibre10"/>    <span class="FontName">public int checkStock(String isbn) {</span><br class="calibre10"/>        <span class="FontName">...</span><br class="calibre10"/>    <span class="FontName">}</span><br class="calibre10"/><span class="FontName">}</span></pre>
<p class="indent">In a Spring 2.0 transactional advice, the timeout and read-only transaction attributes can be specified in the <span class="FontName">&lt;tx:method&gt;</span> element.</p>
<pre class="calibre11"><span class="FontName">&lt;tx:advice ...&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;tx:attributes&gt;</span><br class="calibre10"/>        <span class="FontName">&lt;tx:method name="checkStock"</span><br class="calibre10"/>            <b class="calibre4">timeout="30"</b><br class="calibre10"/>            <b class="calibre4">read-only="true"</b><span class="FontName">/&gt;</span><br class="calibre10"/>    <span class="FontName">&lt;/tx:attributes&gt;</span><br class="calibre10"/><span class="FontName">&lt;/tx:advice&gt;</span></pre>
<p class="indent">In Spring’s transaction management API, the timeout and read-only transaction attributes can be specified in a <span class="FontName">DefaultTransactionDefinition</span> object and then passed to a transaction manager’s <span class="FontName">getTransaction()</span> method or a transaction template’s constructor.</p>
<pre class="calibre11"><span class="FontName">DefaultTransactionDefinition def = new DefaultTransactionDefinition();</span><br class="calibre10"/><b class="calibre4">def.setTimeout(30);</b><br class="calibre10"/><b class="calibre4">def.setReadOnly(true);</b></pre>
<p id="Sec48" class="Heading">11-11. Managing Transactions with Load-Time Weaving<a id="cXXX.828" class="calibre6"></a></p>
<p id="Sec49" class="Heading1">Problem</p>
<p class="noindent">By default, Spring’s declarative transaction management is enabled via its AOP framework. However, as Spring AOP can only advise public methods of beans declared in the IoC container, you are restricted to managing transactions within this scope using Spring AOP. Sometimes, you may wish to manage transactions for nonpublic methods, or methods of objects created outside the Spring IoC container (e.g., domain objects).</p>
<p id="Sec50" class="Heading1">Solution</p>
<p class="noindent">Spring provides an AspectJ aspect named <span class="FontName">AnnotationTransactionAspect</span> that can manage transactions for any methods of any objects, even if the methods are non-public or the objects are created outside the Spring IoC container. This aspect will manage transactions for any methods with the <span class="FontName">@Transactional</span> annotation. You can choose either AspectJ’s compile-time weaving or load-time weaving to enable this aspect.</p>
<p id="Sec51" class="Heading1">How It Works</p>
<p class="noindent">To weave this aspect into your domain classes at load time, you have to put the <span class="FontName">@EnableLoadTimeWeaving</span> annotation on your configuration class. To enable Spring’s <span class="FontName">AnnotationTransactionAspect</span> for transaction management, you just define the <span class="FontName">@EnableTransactionManagement</span> annotation and set its <span class="FontName">mode</span> attribute to <span class="FontName">aspectj</span>. The <span class="FontName">@EnableTransactionManagement</span> annotation takes two values for the <span class="FontName">mode</span> attribute: <span class="FontName">aspectj</span> and <span class="FontName">proxy. aspect</span> stipulates that the container should use load-time or compile-time weaving to enable the transaction advice. This requires the <span class="FontName">spring-instrument</span> jar to be on the classpath, as well as the appropriate configuration at load time or compile time. Alternatively, proxy stipulates that the container should use the Spring AOP mechanisms. It’s important to note that the <span class="FontName">aspect</span> mode doesn’t support configuration of the <span class="FontName">@Transactional</span> annotation on interfaces. Then the transaction aspect will automatically get enabled. You also have to provide a transaction manager for this aspect. By default, it will look for a transaction manager whose name is <span class="FontName">transactionManager</span>.</p>
<pre class="calibre11"><span class="FontName">package com.apress.springrecipes.bookshop;</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">Configuration</span><br class="calibre10"/><span class="FontName">@EnableTransactionManagement(mode = AdviceMode.ASPECTJ)</span><br class="calibre10"/><span class="FontName">@EnableLoadTimeWeaving</span><br class="calibre10"/><span class="FontName">public class BookstoreConfiguration { ... }</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">In XML you add &lt;context:load-time-weaver /&gt;and specify the mode attribute on &lt;tx:annotation-driven /&gt;.</span><br class="calibre10"/><br class="calibre10"/><span class="FontName">&lt;beans ... &gt;</span><br class="calibre10"/><span class="FontName">...</span><br class="calibre10"/>    <b class="calibre4">&lt;context:load-time-weaver /&gt;</b><br class="calibre10"/>    <span class="FontName">&lt;tx:annotation-driven</span> <b class="calibre4">mode="aspectj"</b><span class="FontName">/&gt;</span>  <br class="calibre10"/><span class="FontName">&lt;/beans&gt;</span></pre>
<div class="notepara">
<p class="paraaftertitle"><img src="../images/00016.jpeg" alt="Image" class="calibre3"/> <b class="calibre4">Note</b>  To use the Spring aspect library for AspectJ you have to include <b class="calibre4">spring-aspects</b> module on your CLASSPATH. To enable loadtime weaving we also have to include a javaagent, this is available in the <b class="calibre4">spring-instrument</b> module. If you’re using Maven, add the following dependencies to your project.</p>
<pre class="calibre19"><span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;${spring.version}&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span><br class="calibre2"/><br class="calibre2"/>  <span class="FontName1">&lt;dependency&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;artifactId&gt;spring-instrument&lt;/artifactId&gt;</span><br class="calibre2"/>  <span class="FontName1">&lt;version&gt;${spring.versio</span><span class="FontName1">n}&lt;/version&gt;</span><br class="calibre2"/><span class="FontName1">&lt;/dependency&gt;</span></pre></div>
<p class="indent">For a simple Java application, you can weave this aspect into your classes at load time with the Spring agent specified as a VM argument.</p>
<pre class="calibre11"><span class="FontName">java -javaagent:lib/spring-instrument-4.0.5.RELEASE.jar -jar Recipe_12_11_i.jar</span></pre>
<p id="Sec52" class="Heading">Summary</p>
<p class="noindent">This chapter discussed transactions and why you should use them. You explored the approach taken for transaction management historically in Java EE and then learned how the approach the Spring framework offers differs. You explored explicit use of transactions in your code as well as implicit use with annotation-driven aspects. You set up a database and used transactions to enforce valid state in the database.</p>
<p class="indent">In the next chapter, you will explore Spring Batch. Spring Batch provides infrastructure and components that can be used as the foundation for batch processing jobs.</p></div>
</body></html>
